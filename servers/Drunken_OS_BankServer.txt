--[[
    Drunken OS - Bank Server (v2.15 - Admin Command Hardening)
    by Gemini Gem & MuhendizBey

    Purpose:
    This version provides a full security audit and hardening of all
    account-related admin commands, ensuring they are safe from misuse and
    preventing potential data corruption or server crashes.

    Key Changes:
    - Hardened the 'give' command to prevent it from creating malformed
      accounts and to ensure it only operates on existing users.
    - Hardened the 'balance' command to prevent server crashes when checking
      the balance of a non-existent user.
    - All account modification commands now provide clear error messages if the
      target user does not exist.
]]


--==============================================================================
-- API & Library Initialization
--==============================================================================

-- Load our new, centralized cryptography library.
local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local accounts, currencyRates, currentStock = {}, {}, {}
local mainServerId = nil
local wired_modem_name, wireless_modem_name = nil, nil
local adminInput = ""
local logHistory = {}
local monitor = nil
local startupComplete = false -- Flag to control logging to terminal

-- Database file paths
local LOGS_DIR = "logs"
local TRANSACTIONS_DIR = LOGS_DIR .. "/transactions"
local CURRENCIES_DIR = "currencies"
local ACCOUNTS_DB = "bank_accounts.db"
local STOCK_DB = "bank_stock.db"
local LOG_FILE = LOGS_DIR .. "/bank_server.log"

-- Rednet Protocols
local BANK_PROTOCOL = "DB_Bank"
local AUDIT_PROTOCOL = "DB_Audit"
local AUTH_INTERLINK_PROTOCOL = "Drunken_Auth_Interlink"

-- Auditor Turtle Configuration
local AUDIT_SECRET_KEY = "YourSecretAuditKeyHere"

--==============================================================================
-- UI & Theme Configuration
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then return colors[colorName] end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    title = safeColor("lightBlue", colors.lightBlue),
    prompt = safeColor("cyan", colors.cyan),
    statusBarBg = safeColor("gray", colors.lightGray),
    statusBarText = safeColor("white", colors.white),
    highlightBg = safeColor("blue", colors.blue),
    highlightText = safeColor("white", colors.white),
    error = safeColor("red", colors.red),
}

local currentScreen = "main"
local selectedMenuItem = 1
local needsRedraw = true

--==============================================================================
-- Logging Functions
--==============================================================================

local function logActivity(message, isError)
    local prefix = isError and "[ERROR] " or "[INFO] "
    local logEntry = os.date("[%Y-%m-%d %H:%M:%S] ") .. prefix .. message
    
    if not startupComplete then
        term.write(logEntry .. "\n")
    end
    
    if not fs.exists(LOGS_DIR) then fs.makeDir(LOGS_DIR) end
    local file = fs.open(LOG_FILE, "a")
    if file then
        file.writeLine(logEntry)
        file.close()
    end

    table.insert(logHistory, logEntry)
    if #logHistory > 200 then table.remove(logHistory, 1) end
    
    if currentScreen == "log" then
        needsRedraw = true
    end
end

local function logTransaction(username, transaction_type, data)
    local logEntry = {
        timestamp = os.time(),
        type = transaction_type,
        user = username,
        data = data
    }
    if not fs.exists(LOGS_DIR) then fs.makeDir(LOGS_DIR) end
    if not fs.exists(TRANSACTIONS_DIR) then fs.makeDir(TRANSACTIONS_DIR) end

    local file = fs.open(TRANSACTIONS_DIR .. "/master.log", "a")
    if file then
        file.writeLine(textutils.serializeJSON(logEntry))
        file.close()
    end
end

--==============================================================================
-- Graphical UI Functions
--==============================================================================

local function drawMainMenu()
    if not monitor then return end
    local w, h = monitor.getSize()
    monitor.setBackgroundColor(theme.windowBg)
    monitor.clear()
    
    monitor.setBackgroundColor(theme.title)
    monitor.setCursorPos(1, 1); monitor.write(string.rep(" ", w))
    monitor.setTextColor(colors.white)
    local titleText = " Drunken OS Bank Server "
    monitor.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1)
    monitor.write(titleText)

    monitor.setBackgroundColor(theme.windowBg)
    monitor.setTextColor(theme.text)
    monitor.setCursorPos(3, 3); monitor.write("System Status: "); monitor.setTextColor(colors.green); monitor.write("ONLINE")
    monitor.setTextColor(theme.text)
    monitor.setCursorPos(3, 4); monitor.write("Mainframe Link: "); monitor.setTextColor(mainServerId and colors.green or colors.red); monitor.write(mainServerId and "CONNECTED" or "DISCONNECTED")
    
    local numAccounts = 0; for _ in pairs(accounts) do numAccounts = numAccounts + 1 end
    monitor.setCursorPos(3, 5); monitor.write("Managed Accounts: " .. numAccounts)
    local numCurrencies = 0; for _ in pairs(currencyRates) do numCurrencies = numCurrencies + 1 end
    monitor.setCursorPos(3, 6); monitor.write("Tracked Currencies: " .. numCurrencies)

    local menuOptions = { "View Rates & Stock", "View Server Log", "Open Admin Terminal", "Shutdown Server" }
    for i, option in ipairs(menuOptions) do
        monitor.setCursorPos(3, 8 + i)
        if i == selectedMenuItem then
            monitor.setBackgroundColor(theme.highlightBg); monitor.setTextColor(theme.highlightText)
            monitor.write("> " .. option .. string.rep(" ", w - 6 - #option))
        else
            monitor.setBackgroundColor(theme.windowBg); monitor.setTextColor(theme.text)
            monitor.write("  " .. option .. string.rep(" ", w - 6 - #option))
        end
    end

    monitor.setBackgroundColor(theme.statusBarBg)
    monitor.setCursorPos(1, h); monitor.write(string.rep(" ", w))
    monitor.setTextColor(theme.statusBarText)
    local footerText = "Use UP/DOWN & ENTER or Click to Navigate"
    monitor.setCursorPos(math.floor((w - #footerText) / 2) + 1, h)
    monitor.write(footerText)
    
    needsRedraw = false
end

local function drawLogScreen()
    if not monitor then return end
    local w, h = monitor.getSize()
    monitor.setBackgroundColor(theme.windowBg); monitor.clear()
    monitor.setBackgroundColor(theme.title); monitor.setCursorPos(1, 1); monitor.write(string.rep(" ", w))
    monitor.setTextColor(colors.white); local titleText = " Live Server Log "; monitor.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1); monitor.write(titleText)
    
    local logAreaHeight = h - 2
    local y = h - 1
    for i = #logHistory, 1, -1 do
        if y < 2 then break end
        local line = logHistory[i]
        monitor.setCursorPos(2, y); monitor.write(string.sub(line, 1, w-2))
        y = y - 1
    end

    monitor.setBackgroundColor(theme.statusBarBg); monitor.setCursorPos(1, h); monitor.write(string.rep(" ", w))
    monitor.setTextColor(theme.statusBarText); local footerText = "Press any key to return to main menu"; monitor.setCursorPos(math.floor((w - #footerText) / 2) + 1, h); monitor.write(footerText)
    
    needsRedraw = false
end

--==============================================================================
-- Data Persistence & Core Logic
--==============================================================================

local function saveTableToFile(path, data)
    local tempPath = path .. ".tmp"
    local file, err_open = fs.open(tempPath, "w")
    if not file then
        logActivity("Could not open temporary file " .. tempPath .. ": " .. tostring(err_open), true)
        return false
    end

    local success, err_write = pcall(function()
        file.write(textutils.serializeJSON(data))
        file.close()
    end)

    if not success then
        logActivity("Failed to write to temporary file " .. tempPath .. ': ' .. tostring(err_write), true)
        fs.delete(tempPath) -- Clean up the failed temp file
        return false
    end

    -- This section makes the write atomic.
    if fs.exists(path) then
        fs.delete(path)
    end
    fs.move(tempPath, path)
    
    return true
end

local function loadTableFromFile(path)
    local tempPath = path .. ".tmp"
    -- Recovery: If the main file is gone but the temp file exists, the last write was interrupted after delete but before move.
    if not fs.exists(path) and fs.exists(tempPath) then
        logActivity("Found incomplete save, restoring from " .. tempPath, false)
        fs.move(tempPath, path)
    end

    if fs.exists(path) then
        local file, err_open = fs.open(path, "r")
        if file then
            local data = file.readAll()
            file.close()
            local success, result = pcall(textutils.unserializeJSON, data)
            if success and type(result) == "table" then
                return result
            else
                logActivity("Corrupted data in " .. path .. ". A new file will be created.", true)
            end
        else
            logActivity("Could not open " .. path .. " for reading: " .. tostring(err_open), true)
        end
    end
    return {}
end

local function loadAllData()
    accounts = loadTableFromFile(ACCOUNTS_DB)
    
    currencyRates = {}
    if fs.exists(CURRENCIES_DIR) then
        for _, file in ipairs(fs.list(CURRENCIES_DIR)) do
            -- The filename is now just for organization, we load the *real* name from inside the file.
            local path = fs.combine(CURRENCIES_DIR, file)
            if not fs.isDir(path) then
                local data = loadTableFromFile(path)
                -- THE FIX: The currency name is now stored *inside* the file.
                if data and data.name then
                    currencyRates[data.name] = data
                    logActivity("Loaded currency: '" .. data.name .. "'")
                else
                    logActivity("Found a malformed currency file: " .. file, true)
                end
            end
        end
    end

    currentStock = loadTableFromFile(STOCK_DB)
    logActivity("All banking data loaded successfully.")
end

local function adjustCurrencyRates()
    logActivity("Adjusting currency rates based on new stock report...")
    local changed = false
    for item, data in pairs(currencyRates) do
        if data.target and data.target > 0 then
            local stock = currentStock[item] or 0
            if stock == 0 then stock = 1 end
            local ratio = data.target / stock
            local price_multiplier = ratio ^ 0.5
            local new_price = math.floor(data.base * price_multiplier + 0.5)
            local max_price = data.base * 5
            local min_price = 1
            new_price = math.max(min_price, math.min(max_price, new_price))

            if new_price ~= data.current then
                logActivity(string.format("'%s' price changed from $%d to $%d (Stock: %d/%d)", item, data.current, new_price, currentStock[item] or 0, data.target))
                currencyRates[item].current = new_price
                changed = true
            end
        end
    end

    if changed then
        for itemName, data in pairs(currencyRates) do
            if not saveTableToFile(fs.combine(CURRENCIES_DIR, itemName .. ".json"), data) then
                 logActivity("Failed to save updated rate for " .. itemName, true)
            end
        end
    end
end

local bankHandlers = {}

-- THE FIX: The handler now correctly uses message.pass_hash.
function bankHandlers.login(senderId, message)
    local user, pass_hash = message.user, message.pass_hash
    local account = accounts[user]

    if account then
        if account.pass_hash == pass_hash then
            logTransaction(user, "login", "SUCCESS")
            rednet.send(senderId, { success = true, balance = account.balance, rates = currencyRates }, BANK_PROTOCOL)
        else
            logTransaction(user, "login", "FAIL - Invalid Credentials")
            rednet.send(senderId, { success = false, reason = "Invalid credentials." }, BANK_PROTOCOL)
        end
    else
        logActivity("New customer login attempt: '" .. user .. "'. Verifying with Mainframe...")
        rednet.send(mainServerId, { type = "user_exists_check", user = user }, AUTH_INTERLINK_PROTOCOL)
        local _, response = rednet.receive(AUTH_INTERLINK_PROTOCOL, 5)

        if response and response.exists then
            logActivity("Mainframe verified user. Creating new bank account for '" .. user .. "'.")
            accounts[user] = { pass_hash = pass_hash, balance = 0 }
            if saveTableToFile(ACCOUNTS_DB, accounts) then
                rednet.send(senderId, { success = true, balance = 0, rates = currencyRates }, BANK_PROTOCOL)
                logTransaction(user, "login", "SUCCESS - New account created")
            else
                logActivity("Failed to save new account for " .. user, true)
                rednet.send(senderId, { success = false, reason = "Bank database error." }, BANK_PROTOCOL)
            end
        else
            logActivity("Mainframe verification failed for '" .. user .. "'.", true)
            rednet.send(senderId, { success = false, reason = "User not registered in Mainframe." }, BANK_PROTOCOL)
        end
    end
end

---
-- Handles a request for balance and rates.
function bankHandlers.get_balance_and_rates(senderId, message)
    local account = accounts[message.user]
    local currentBalance = account and account.balance or 0
    rednet.send(senderId, { balance = currentBalance, rates = currencyRates }, BANK_PROTOCOL)
end

-- Handles a deposit of items with real-time stock updates.
function bankHandlers.deposit(senderId, message)
    local user, items = message.user, message.items
    local total_value = 0
    local transaction_summary = {}

    for _, item in ipairs(items) do
        local rateInfo = nil
        local itemName = item.name or "unknown"
        if currencyRates[itemName] then
            rateInfo = currencyRates[itemName]
        else
            local shortName = itemName:match("^minecraft:(.+)")
            if shortName and currencyRates[shortName] then
                rateInfo = currencyRates[shortName]
            end
        end

        if rateInfo then
            local value = item.count * rateInfo.current
            total_value = total_value + value
            table.insert(transaction_summary, string.format("%d %s for $%d", item.count, itemName, value))
            
            -- THE FIX #1: Immediately update the internal stock count upon deposit.
            currentStock[itemName] = (currentStock[itemName] or 0) + item.count
        end
    end

    if total_value > 0 then
        if accounts[user] then
            accounts[user].balance = accounts[user].balance + total_value
            if saveTableToFile(ACCOUNTS_DB, accounts) and saveTableToFile(STOCK_DB, currentStock) then
                rednet.send(senderId, { success = true, newBalance = accounts[user].balance, deposited_value = total_value }, BANK_PROTOCOL)
                local transaction_data = {}
                for _, item in ipairs(items) do
                    local rateInfo = currencyRates[item.name or "unknown"] or currencyRates[item.name:match("^minecraft:(.+)") or ""]
                    if rateInfo then
                        transaction_data[item.name or "unknown"] = { count = item.count, value = item.count * rateInfo.current }
                    end
                end
                logTransaction(user, "DEPOSIT", transaction_data)
                logActivity(string.format("Stock updated for deposit: %s", table.concat(transaction_summary, ", ")))
                needsRedraw = true -- Update the GUI
            else
                rednet.send(senderId, { success = false, reason = "Server database error." }, BANK_PROTOCOL)
            end
        else
            rednet.send(senderId, { success = false, reason = "Account not found for deposit." }, BANK_PROTOCOL)
        end
    else
        logActivity(string.format("Deposit failed for user '%s': No valid currency detected.", user), true)
        for i, item in ipairs(items) do
            logActivity(string.format(" - Received item: '%s' (count: %d)", tostring(item.name), item.count), true)
        end
        rednet.send(senderId, { success = false, reason = "No valid currency detected." }, BANK_PROTOCOL)
    end
end

---
-- PHASE 1: Authorizes a withdrawal but does not deduct funds.
function bankHandlers.withdraw_item(senderId, message)
    local user, itemName, count = message.user, message.item_name, message.count
    local account = accounts[user]
    local rateInfo = currencyRates[itemName]

    if not account then rednet.send(senderId, { success = false, reason = "Account not found." }, BANK_PROTOCOL); return end
    if not rateInfo then rednet.send(senderId, { success = false, reason = "Invalid currency type." }, BANK_PROTOCOL); return end

    local totalCost = rateInfo.current * count
    if account.balance >= totalCost then
        if (currentStock[itemName] or 0) >= count then
            -- Authorize the transaction, but do not change the balance yet.
            rednet.send(senderId, { success = true, authorized = true }, BANK_PROTOCOL)
            logActivity(string.format("Authorized withdrawal for '%s' of %d %s.", user, count, itemName))
        else
            rednet.send(senderId, { success = false, reason = "Insufficient stock in vault." }, BANK_PROTOCOL)
        end
    else
        rednet.send(senderId, { success = false, reason = "Insufficient funds." }, BANK_PROTOCOL)
    end
end

---
-- PHASE 3: Finalizes the transaction and deducts funds and stock after turtle success.
function bankHandlers.finalize_withdrawal(senderId, message)
    local user, itemName, count = message.user, message.item_name, message.count
    local account = accounts[user]
    local rateInfo = currencyRates[itemName]
    
    if not account or not rateInfo then
        logActivity("Finalization failed: account or rate info missing.", true)
        return
    end

    local totalCost = rateInfo.current * count
    account.balance = account.balance - totalCost
    
    -- THE FIX #2: Immediately update the internal stock count upon withdrawal.
    currentStock[itemName] = (currentStock[itemName] or 0) - count
    if currentStock[itemName] < 0 then
        logActivity("CRITICAL: Stock for " .. itemName .. " went negative. Resetting to 0.", true)
        currentStock[itemName] = 0
    end
    
    if saveTableToFile(ACCOUNTS_DB, accounts) and saveTableToFile(STOCK_DB, currentStock) then
        local transaction_data = {
            [itemName] = { count = count, value = totalCost }
        }
        logTransaction(user, "WITHDRAW", transaction_data)
        logActivity(string.format("Finalized withdrawal for '%s'. New balance: $%d", user, account.balance))
        logActivity(string.format("Stock updated for withdrawal: %d %s", count, itemName))
        needsRedraw = true -- Update the GUI
        
        rednet.send(senderId, { success = true, newBalance = account.balance }, BANK_PROTOCOL)
    else
        logActivity("CRITICAL: FAILED TO SAVE DATABASE AFTER FINALIZATION FOR " .. user, true)
        -- This is a critical state that requires manual admin intervention.
    end
end

--==============================================================================
-- Admin Command Handlers & Terminal
--==============================================================================

local adminCommands = {}

local function parseAdminArgs(args)
    local command = table.remove(args, 1)
    if not args or #args == 0 then return command, nil, nil end
    local itemName = args[1]
    local numberValue = tonumber(args[2])
    if #args > 2 and not tonumber(args[2]) then
        itemName = table.concat(args, " ", 1, 2)
        numberValue = tonumber(args[3])
    end
    return command, itemName, numberValue
end

function adminCommands.help()
    print("--- Bank Admin Commands ---")
    print("balance <user>")
    print("setbalance <user> <amount>")
    print("give <user> <amount>")
    print("makecard <user>")
    print("addcurrency <item_name> <base_rate>")
    print("delcurrency <item_name>")
    print("listrates")
    print("settarget <item_name> <target_amount>")
    print("exit - Closes the terminal and returns to the GUI.")
end

function adminCommands.balance(args)
    local _, user = parseAdminArgs(args)
    if not user then print("Usage: balance <user>"); return end
    
    -- THE FIX: Check if the account exists before trying to read from it.
    if accounts[user] then
        print("Balance for " .. user .. ": $" .. accounts[user].balance)
    else
        print("Error: Account for user '" .. user .. "' does not exist.")
    end
end

function adminCommands.setbalance(args)
    local _, user, amount = parseAdminArgs(args)
    if not user or not amount then print("Usage: setbalance <user> <amount>"); return end

    if accounts[user] then
        accounts[user].balance = amount
        saveTableToFile(ACCOUNTS_DB, accounts)
        print("Set balance for " .. user .. " to $" .. amount)
    else
        print("Error: Account for user '" .. user .. "' does not exist.")
    end
end

function adminCommands.give(args)
    local _, user, amount = parseAdminArgs(args)
    if not user or not amount then print("Usage: give <user> <amount>"); return end

    -- THE FIX: Check for the account and only update the balance.
    if accounts[user] then
        accounts[user].balance = accounts[user].balance + amount
        saveTableToFile(ACCOUNTS_DB, accounts)
        print("Gave $" .. amount .. " to " .. user .. ". New balance: $" .. accounts[user].balance)
    else
        print("Error: Account for user '" .. user .. "' does not exist.")
    end
end

function adminCommands.makecard(args)
    local _, user = parseAdminArgs(args)
    if not user then
        print("Usage: makecard <username>")
        return
    end

    print("Verifying user with Mainframe...")
    rednet.send(mainServerId, { type = "user_exists_check", user = user }, AUTH_INTERLINK_PROTOCOL)
    local _, response = rednet.receive(AUTH_INTERLINK_PROTOCOL, 5)

    if not response or not response.exists then
        print("Error: Mainframe reports user '" .. user .. "' does not exist.")
        return
    end

    print("User verified. Please insert a blank disk.")
    local disk = peripheral.find("drive")
    if not disk then
        print("Error: No disk drive attached to this server.")
        return
    end

    if not disk.isDiskPresent() then
        print("Error: No disk in the drive.")
        return
    end

    local mount_path = disk.getMountPath()
    if not mount_path then
        print("Error: Could not get disk mount path.")
        return
    end

    -- FIX: Set the label to the format the ATM expects.
    disk.setDiskLabel("DrunkenBeard_Card_" .. user)

    -- The rest of the function remains the same.
    -- This creates the hidden data file on the card.
    -- NOTE: This assumes you have a way to get the user's password hash.
    -- For now, we'll create the card, but you may need a separate
    -- "set password" step if the hash isn't available here.
    if not accounts[user] then
        print("Warning: User does not have a bank account yet. Creating one.")
        accounts[user] = {
            -- You need a secure way to get this hash. Placeholder for now.
            pass_hash = "placeholder_hash_needs_to_be_set",
            balance = 0
        }
        saveTableToFile(ACCOUNTS_DB, accounts)
    end
    
    local cardData = { pass_hash = accounts[user].pass_hash }
    local cardFile = fs.open(mount_path .. "/.card_data", "w")
    if cardFile then
        cardFile.write(textutils.serialize(cardData))
        cardFile.close()
        print("Successfully created bank card for " .. user)
    else
        print("Error: Could not write data file to disk.")
    end
end

-- NEW: Re-engineered to save the currency name inside the file.
function adminCommands.addcurrency(args)
    local _, itemName, baseRate = parseAdminArgs(args)
    if not itemName or not baseRate then print("Usage: addcurrency <item_name> <base_rate>"); return end
    if currencyRates[itemName] then print("Currency '" .. itemName .. "' already exists."); return end
    if not fs.isDir(CURRENCIES_DIR) then fs.makeDir(CURRENCIES_DIR) end

    -- THE FIX: We create a "safe" filename by replacing the colon,
    -- but store the *real* name inside the file's data.
    local safeFileName = itemName:gsub(":", "_") .. ".json"
    
    local newCurrency = {
        name = itemName, -- The actual name with the colon
        base = baseRate,
        current = baseRate,
        target = nil
    }

    if saveTableToFile(fs.combine(CURRENCIES_DIR, safeFileName), newCurrency) then
        -- Also add it to our live currency table
        currencyRates[itemName] = newCurrency
        print("Added new currency '" .. itemName .. "' with base rate $" .. baseRate)
    else
        print("Failed to save new currency.")
    end
end

function adminCommands.delcurrency(args)
    local _, itemName = parseAdminArgs(args)
    if not itemName then print("Usage: delcurrency <item_name>"); return end
    if not currencyRates[itemName] then print("Currency '" .. itemName .. "' does not exist."); return end
    currencyRates[itemName] = nil
    
    local path = fs.combine(CURRENCIES_DIR, itemName .. ".json")
    if fs.exists(path) then fs.delete(path) end
    
    print("Removed currency '" .. itemName .. "'.")
end

function adminCommands.listrates()
    print("--- Current Exchange Rates ---")
    for name, data in pairs(currencyRates) do
        local stock = currentStock[name] or 0
        local target = data.target and ("/" .. data.target) or "/N/A"
        print(string.format("- %s: $%d (Base: $%d) | Stock: %d%s", name, data.current, data.base, stock, target))
    end
end

function adminCommands.settarget(args)
    local _, itemName, targetAmount = parseAdminArgs(args)
    if not itemName or not targetAmount then print("Usage: settarget <item_name> <target_amount>"); return end
    if not currencyRates[itemName] then print("Currency '" .. itemName .. "' does not exist."); return end
    
    currencyRates[itemName].target = targetAmount
    if saveTableToFile(fs.combine(CURRENCIES_DIR, itemName .. ".json"), currencyRates[itemName]) then
        print("Set target stock for '" .. itemName .. "' to " .. targetAmount)
    else
        print("Failed to set target.")
    end
end

local function handleAdminCommand(command)
    local args = {}; for arg in string.gmatch(command, "[^%s]+") do table.insert(args, arg) end
    local cmd = args[1]
    if cmd == "exit" then return false end -- Signal to exit terminal
    if adminCommands[cmd] then adminCommands[cmd](args) else print("Unknown command. Type 'help'.") end
    return true -- Continue terminal session
end

local function adminTerminal()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1,1)
    print("Bank Admin Terminal. Type 'exit' to return to GUI.")
    
    while true do
        term.write("> ")
        local input = read()
        if not handleAdminCommand(input) then
            break
        end
    end
    
    currentScreen = "main"
    needsRedraw = true
end

--==============================================================================
-- Main Event Loops
--==============================================================================

local function networkListener()
    while true do
        local senderId, message, protocolReceived = rednet.receive()
        
        if protocolReceived == BANK_PROTOCOL and message and message.type and bankHandlers[message.type] then
            bankHandlers[message.type](senderId, message)
        
        elseif protocolReceived == AUDIT_PROTOCOL and message and message.type == "stock_report" then
            local messageToVerify = textutils.serializeJSON(message.report)
            local signature = crypto.hmac_hex(AUDIT_SECRET_KEY, messageToVerify)
            if signature == message.signature then
                logActivity("Received valid, signed stock report from Auditor.")
                currentStock = message.report
                saveTableToFile(STOCK_DB, currentStock)
                adjustCurrencyRates()
                needsRedraw = true -- Update dashboard stats
            else
                logActivity("Received an INVALID or TAMPERED stock report! Ignoring.", true)
            end
        elseif protocolReceived == AUDIT_PROTOCOL and message and message.type == "get_transaction_log" then
            local signature = crypto.hmac_hex(AUDIT_SECRET_KEY, message.timestamp)
            if signature == message.signature then
                local log_path = TRANSACTIONS_DIR .. "/master.log"
                if fs.exists(log_path) then
                    local file = fs.open(log_path, "r")
                    local log_data = file.readAll()
                    file.close()
                    rednet.send(senderId, { success = true, log = log_data }, AUDIT_PROTOCOL)
                else
                    rednet.send(senderId, { success = false, reason = "No transaction log found." }, AUDIT_PROTOCOL)
                end
            else
                logActivity("Received an INVALID or TAMPERED log request! Ignoring.", true)
            end
        end
    end
end

local function guiHandler()
    while true do
        if needsRedraw then
            if currentScreen == "main" then
                drawMainMenu()
            elseif currentScreen == "log" then
                drawLogScreen()
            end
        end

        local event, p1, p2, p3 = os.pullEvent()
        if event == "key" then
            if currentScreen == "main" then
                local menuSize = 4
                if p1 == keys.up then
                    selectedMenuItem = (selectedMenuItem == 1) and menuSize or selectedMenuItem - 1
                    needsRedraw = true
                elseif p1 == keys.down then
                    selectedMenuItem = (selectedMenuItem == menuSize) and 1 or selectedMenuItem + 1
                    needsRedraw = true
                elseif p1 == keys.enter then
                    if selectedMenuItem == 1 then -- View Rates
                        -- Placeholder for rates screen
                    elseif selectedMenuItem == 2 then -- View Log
                        currentScreen = "log"
                        needsRedraw = true
                    elseif selectedMenuItem == 3 then -- Open Terminal
                        currentScreen = "terminal"
                        adminTerminal()
                    elseif selectedMenuItem == 4 then -- Shutdown
                        return -- End the GUI handler
                    end
                end
            elseif currentScreen == "log" then
                currentScreen = "main"
                needsRedraw = true
            end
        elseif event == "monitor_touch" then
            if currentScreen == "main" and p2 >= 9 and p2 <= 12 then
                selectedMenuItem = p2 - 8
                os.queueEvent("key", keys.enter)
            end
        elseif event == "terminate" then
            return
        end
    end
end

local function main()
    local computerTerm = term.current()
    computerTerm.clear()
    computerTerm.setCursorPos(1,1)
    
    print("Drunken OS Bank Server Initializing...")

    monitor = peripheral.find("monitor")
    if not monitor then
        print("FATAL: No advanced monitor attached. GUI cannot start.")
        return
    end

    loadAllData()
    
    print("Scanning for modems...")
    for _, name in ipairs(peripheral.getNames()) do
        if peripheral.getType(name) == "modem" then
            local modem_p = peripheral.wrap(name)
            if modem_p.isWireless() then
                wireless_modem_name = name
            else
                wired_modem_name = name
            end
        end
    end

    if not wireless_modem_name then print("FATAL: No wireless modem attached."); return end
    if not wired_modem_name then print("FATAL: No wired modem for secure interlink."); return end
    
    print("Found Wireless Modem on: " .. wireless_modem_name)
    print("Found Wired Modem on: " .. wired_modem_name)

    print("Identifying Mainframe via secure wired link...")
    local wired_periph = peripheral.wrap(wired_modem_name)
    local remote_names = wired_periph.getNamesRemote()
    for _, name in ipairs(remote_names) do
        if peripheral.getType(name) == "computer" then
            mainServerId = peripheral.call(name, "getID")
            break
        end
    end

    if not mainServerId then print("FATAL: No computer found on the other side of the wired modem."); return end
    print("Mainframe located via wired link at ID " .. mainServerId)

    print("Opening modems...")
    rednet.open(wireless_modem_name)
    rednet.open(wired_modem_name)
    
    rednet.host(BANK_PROTOCOL, "bank.server")
    
    startupComplete = true -- Stop logging to the physical terminal
    computerTerm.clear()
    computerTerm.setCursorPos(1,1)
    computerTerm.write("Bank Server started successfully.\nGUI is now active on the attached monitor.")
    
    -- Redirect all terminal I/O to the monitor for the GUI
    term.redirect(monitor)
    
    -- Run the main loops
    parallel.waitForAny(networkListener, guiHandler)
    
    -- When the loops exit (on shutdown), restore the original terminal
    term.redirect(computerTerm)
    monitor.setBackgroundColor(colors.black)
    monitor.clear()
    term.clear()
    term.setCursorPos(1,1)
    print("Bank Server has shut down.")
end

main()
