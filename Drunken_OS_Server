--[[
    Drunken OS - Mainframe Server (v9.8 - Final Formatted)
    by Gemini Gem

    Purpose:
    This definitive version is fully formatted to the "Gem Standard" of code
    clarity. It uses a stable single event loop and the robust Pastebin
    distribution model for libraries, ensuring the system is both maintainable
    and easy for an administrator to manage.

    Key Changes:
    - Complete code reformatting for clarity. All functions are now properly
      structured in multi-line blocks.
    - Verified the `adminTerminal` event loop to ensure correct input handling.
    - Confirmed the `setlibpaste` logic is correct for seamless client updates.
]]

--==============================================================================
-- Environment Setup
--==============================================================================

-- Add the current program's directory to the package path for the server's own needs.
package.path = fs.getDir(shell.getRunningProgram()) .. "/?.lua;" .. package.path

--==============================================================================
-- API & Library Initialization
--==============================================================================

-- Startup Check: Verify that the server's OWN required libraries exist.
local ok_crypto, crypto = pcall(require, "lib.sha1_hmac")
if not ok_crypto then
    term.setBackgroundColor(colors.red); term.setTextColor(colors.white); term.clear(); term.setCursorPos(1, 1)
    print("================ FATAL ERROR ================")
    print("Required library 'lib/sha1_hmac' not found!")
    print("Please make sure the file exists at either:")
    print(" > " .. fs.getDir(shell.getRunningProgram()) .. "/lib/sha1_hmac.lua")
    print("OR")
    print(" > /lib/sha1_hmac.lua")
    print("=============================================")
    error("Missing required library.", 0)
end

local ok_auth, AuthClient = pcall(require, "HyperAuthClient/api/auth_client")
if not ok_auth then
    term.setBackgroundColor(colors.red); term.setTextColor(colors.white); term.clear(); term.setCursorPos(1, 1)
    print("================ FATAL ERROR ================")
    print("The HyperAuthClient API could not be found.")
    print("Please ensure it exists at:")
    print(" > /HyperAuthClient/api/auth_client.lua")
    print("=============================================")
    print("Server shutting down.")
    error("HyperAuthClient API not found.", 0)
end

--==============================================================================
-- Configuration & State
--==============================================================================

local admins = { ["MuhendizBey"] = true }
local users, lists, games, chatHistory, gameList, pendingAuths = {}, {}, {}, {}, {}, {}
local programVersions, programCode, gameCode, libraryPastes = {}, {}, {}, {}
local logHistory, adminInput, motd = {}, "", ""

local USERS_DB = "users.db"; local LISTS_DB = "lists.db"; local GAMES_DB = "games.db";
local CHAT_DB = "chat.db"; local UPDATER_DB = "updater.db"; local GAMELIST_DB = "gamelist.db";
local GAMES_CODE_DB = "games_code.db"; local LIB_PASTES_DB = "lib_pastes.db";
local MOTD_FILE = "motd.txt"; local LOG_FILE = "server.log";
local AUTH_SERVER_PROTOCOL = "auth.secure.v1";
local AUTH_INTERLINK_PROTOCOL = "Drunken_Auth_Interlink"; local ADMIN_PROTOCOL = "Drunken_Admin";

--==============================================================================
-- UI & Theme
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then
        return colors[colorName]
    end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    title = safeColor("red", colors.red),
    prompt = safeColor("cyan", colors.cyan),
    statusBarBg = safeColor("gray", colors.lightGray),
    statusBarText = safeColor("white", colors.white),
}

local function wordWrap(text, width)
    local finalLines = {}
    for line in string.gmatch(text, "[^\r\n]+") do
        while #line > width do
            local breakPos = width + 1
            local spacePos = line:reverse():find(" ", 1)
            if spacePos then
                breakPos = width - spacePos + 2
            end
            table.insert(finalLines, line:sub(1, breakPos - 1))
            line = line:sub(breakPos):match("^%s*(.*)")
        end
        table.insert(finalLines, line)
    end
    return finalLines
end

local function redrawAdminUI()
    local w, h = term.getSize()
    term.setBackgroundColor(theme.windowBg)
    term.clear()

    term.setBackgroundColor(theme.title)
    term.setCursorPos(1, 1)
    term.write(string.rep(" ", w))
    term.setTextColor(colors.white)
    local titleText = " Mainframe Admin Console "
    term.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1)
    term.write(titleText)

    term.setBackgroundColor(theme.statusBarBg)
    term.setTextColor(theme.statusBarText)
    term.setCursorPos(1, h)
    term.write(string.rep(" ", w))
    local statusText = "RUNNING | Type 'help' for commands"
    term.setCursorPos(2, h)
    term.write(statusText)

    term.setBackgroundColor(theme.windowBg)
    term.setTextColor(theme.text)

    local logAreaHeight = h - 4
    local displayLines = {}
    for i = #logHistory, 1, -1 do
        local wrapped = wordWrap(logHistory[i], w - 2)
        for j = #wrapped, 1, -1 do
            table.insert(displayLines, 1, " " .. wrapped[j])
            if #displayLines >= logAreaHeight then break end
        end
        if #displayLines >= logAreaHeight then break end
    end

    for i = 1, math.min(#displayLines, logAreaHeight) do
        term.setCursorPos(1, 1 + i)
        term.write(displayLines[i])
    end

    term.setCursorPos(1, h - 2)
    term.write(string.rep("-", w))
    term.setCursorPos(1, h - 1)
    term.setTextColor(theme.prompt)
    term.write("> ")
    term.setTextColor(theme.text)
    term.write(adminInput)
end

local function logActivity(message, isError)
    local prefix = isError and "[ERROR] " or "[INFO] "
    local logEntry = os.date("[%H:%M:%S] ") .. prefix .. message
    table.insert(logHistory, logEntry)
    if #logHistory > 200 then
        table.remove(logHistory, 1)
    end
    local file = fs.open(LOG_FILE, "a")
    if file then
        file.writeLine(os.date("[%Y-%m-%d %H:%M:%S] ") .. prefix .. message)
        file.close()
    end
    redrawAdminUI()
end

--==============================================================================
-- Data Persistence & Core Logic
--==============================================================================

local function saveTableToFile(path, data)
    local file = fs.open(path, "w")
    if not file then
        logActivity("Save failed: " .. path, true)
        return false
    end
    local success, err = pcall(function()
        file.write(textutils.serialize(data))
        file.close()
    end)
    if not success then
        logActivity("Write failed: " .. path .. ": " .. tostring(err), true)
    end
    return success
end

local function loadTableFromFile(path)
    if fs.exists(path) then
        local file = fs.open(path, "r")
        if file then
            local data = file.readAll()
            file.close()
            local success, result = pcall(textutils.unserialize, data)
            if success and type(result) == "table" then
                return result
            else
                logActivity("Corrupt data: " .. path, true)
            end
        end
    end
    return {}
end

local function loadAllData()
    users = loadTableFromFile(USERS_DB)
    lists = loadTableFromFile(LISTS_DB)
    games = loadTableFromFile(GAMES_DB)
    chatHistory = loadTableFromFile(CHAT_DB)
    gameList = loadTableFromFile(GAMELIST_DB)
    local updaterData = loadTableFromFile(UPDATER_DB)
    programVersions = updaterData.v or {}
    programCode = updaterData.c or {}
    gameCode = loadTableFromFile(GAMES_CODE_DB)
    libraryPastes = loadTableFromFile(LIB_PASTES_DB)
    if fs.exists(MOTD_FILE) then
        local file = fs.open(MOTD_FILE, "r")
        motd = file.readAll()
        file.close()
    end
    logActivity("All Mainframe data loaded.")
end

local function saveItem(user, item, itemType)
    local dir = itemType .. "/" .. user
    if not fs.exists(dir) then
        fs.makeDir(dir)
    end
    local id = os.time() .. "-" .. math.random(100, 999)
    saveTableToFile(dir .. "/" .. id, item)
end

local function loadMail(user)
    local path = "mail/" .. user
    local userMail = {}
    if fs.exists(path) and fs.isDir(path) then
        for _, fileName in ipairs(fs.list(path)) do
            local mailPath = path .. "/" .. fileName
            local mailFile = fs.open(mailPath, "r")
            if mailFile then
                local data = mailFile.readAll()
                mailFile.close()
                local success, item = pcall(textutils.unserialize, data)
                if success and item then
                    item.id = fileName
                    table.insert(userMail, item)
                else
                    logActivity("Could not read corrupted mail file: " .. mailPath, true)
                end
            end
        end
    end
    return userMail
end

local function deleteItem(user, id, itemType)
    local path = itemType .. "/" .. user .. "/" .. id
    if fs.exists(path) then
        fs.delete(path)
        return true
    end
    return false
end

local function requestAuthCode(username, password, nickname, senderId, purpose)
    logActivity("Requesting auth for '" .. username .. "'...")
    local request_reply, request_err = AuthClient.requestCode(AUTH_SERVER_PROTOCOL, {
        username   = username,
        password   = password,
        vendorID   = "DrunkenOS_Mainframe",
        computerID = os.getComputerID(),
        extra      = { purpose = purpose or "unknown" },
    })
    if not request_reply then
        logActivity("HyperAuth err: " .. tostring(request_err), true)
        rednet.send(senderId, { success = false, reason = "Auth service err." }, "SimpleMail")
        return nil
    end
    logActivity("HyperAuth success. ID: " .. request_reply.request_id)
    pendingAuths[username] = {
        request_id = request_reply.request_id,
        password = password,
        nickname = nickname,
        senderId = senderId,
        timestamp = os.time()
    }
    return request_reply.request_id
end

--==============================================================================
-- Network & Admin Handlers
--==============================================================================

local mailHandlers = {}
local gameHandlers = {}
local adminCommands = {}

function mailHandlers.get_version(s, m)
    rednet.send(s, { version = programVersions[m.program] or 0 }, "SimpleMail")
end

function mailHandlers.get_update(s, m)
    rednet.send(s, { code = programCode[m.program] }, "SimpleMail")
end

function mailHandlers.get_lib_paste(s, m)
    local libName = m.lib_name
    logActivity("Client " .. s .. " requested paste for: " .. libName)
    rednet.send(s, { code = libraryPastes[libName] }, "SimpleMail")
end

function mailHandlers.register(s, m)
    if users[m.user] then
        rednet.send(s, {success = false, reason = "Username taken."}, "SimpleMail")
        return
    end
    local r = requestAuthCode(m.user, crypto.hex(m.pass), m.nickname, s, "register")
    if r then
        rednet.send(s, {success = true, needs_auth = true}, "SimpleMail")
    end
end

function mailHandlers.login(s, m)
    local h = users[m.user] and users[m.user].password
    if not h or h ~= crypto.hex(m.pass) then
        rednet.send(s, {success = false, reason = "Invalid login."}, "SimpleMail")
        return
    end
    if m.session_token and users[m.user].session_token == m.session_token then
        logActivity("User '" .. m.user .. "' logged in with token.")
        rednet.send(s, {success = true, needs_auth = false, nickname = users[m.user].nickname, unreadCount = #loadMail(m.user), isAdmin = admins[m.user] or false}, "SimpleMail")
        return
    end
    local r = requestAuthCode(m.user, crypto.hex(m.pass), nil, s, "login")
    if r then
        rednet.send(s, {success = true, needs_auth = true}, "SimpleMail")
    end
end

function mailHandlers.submit_auth_token(s, m)
    local u, c = m.user, m.token
    local d = pendingAuths[u]
    if not d then
        rednet.send(s, {success = false, reason = "No auth pending."}, "SimpleMail")
        return
    end
    local r, e = AuthClient.verifyCode(AUTH_SERVER_PROTOCOL, {request_id = d.request_id, code = c})
    if not r then
        logActivity("HyperAuth verify err: " .. tostring(e), true)
        rednet.send(s, {success = false, reason = "Auth service err."}, "SimpleMail")
        return
    end
    if r.ok then
        local p = {}
        local nst = crypto.hex(os.time() .. math.random())
        if not users[u] then
            users[u] = {password = d.password, nickname = d.nickname, session_token = nst}
            if saveTableToFile(USERS_DB, users) then
                p = {success = true, unreadCount = 0, nickname = d.nickname, session_token = nst, isAdmin = admins[u] or false}
                logActivity("User '" .. u .. "' registered.")
            else
                p = {success = false, reason = "DB error."}
            end
        else
            users[u].session_token = nst
            saveTableToFile(USERS_DB, users)
            p = {success = true, unreadCount = #loadMail(u), nickname = users[u].nickname, session_token = nst, isAdmin = admins[u] or false}
            logActivity("User '" .. u .. "' logged in.")
        end
        rednet.send(s, p, "SimpleMail")
        pendingAuths[u] = nil
    else
        rednet.send(s, {success = false, reason = r.reason or "Invalid code."}, "SimpleMail")
        logActivity("Auth fail " .. u .. ": " .. (r.reason or "Unknown"), true)
    end
end

function mailHandlers.set_nickname(s, m)
    local u, n = m.user, m.new_nickname
    if users[u] and n and n ~= "" then
        users[u].nickname = n
        if saveTableToFile(USERS_DB, users) then
            rednet.send(s, {success = true, new_nickname = n}, "SimpleMail")
            logActivity("'" .. u .. "' set nick to '" .. n .. "'")
        else
            rednet.send(s, {success = false, reason = "DB err."}, "SimpleMail")
        end
    else
        rednet.send(s, {success = false, reason = "Invalid req."}, "SimpleMail")
    end
end

function mailHandlers.user_exists(s, m)
    local r = m.user
    local e = false
    if r and r ~= "" then
        if r == "@all" then
            e = true
        elseif r:sub(1, 1) == "@" then
            e = lists[r:sub(2)] ~= nil
        else
            e = users[r] ~= nil
        end
    end
    rednet.send(s, {exists = e}, "SimpleMail")
end

function mailHandlers.send(s, m)
    local mail = m.mail
    if mail.to == "@all" then
        for u, _ in pairs(users) do
            saveItem(u, mail, "mail")
        end
        logActivity("Mail from '" .. mail.from_nickname .. "' to @all")
    elseif mail.to:sub(1, 1) == "@" then
        local ln = mail.to:sub(2)
        if lists[ln] then
            for _, mem in ipairs(lists[ln]) do
                saveItem(mem, mail, "mail")
            end
            logActivity("Mail from '" .. mail.from_nickname .. "' to list '" .. ln .. "'")
        end
    else
        saveItem(mail.to, mail, "mail")
        logActivity("Mail from '" .. mail.from_nickname .. "' to '" .. mail.to .. "'")
    end
    rednet.send(s, {status = "Mail sent."}, "SimpleMail")
end

function mailHandlers.fetch(s, m)
    rednet.send(s, {mail = loadMail(m.user)}, "SimpleMail")
end

function mailHandlers.delete(s, m)
    if deleteItem(m.user, m.id, "mail") then
        logActivity("User '" .. m.user .. "' deleted mail '" .. m.id .. "'")
    end
end

function mailHandlers.create_list(s, m)
    if lists[m.name] then
        rednet.send(s, {success = false, status = "List exists."}, "SimpleMail")
    else
        lists[m.name] = {[1] = m.creator}
        if saveTableToFile(LISTS_DB, lists) then
            rednet.send(s, {success = true, status = "List created."}, "SimpleMail")
            logActivity("User '" .. m.creator .. "' created list '" .. m.name .. "'")
        end
    end
end

function mailHandlers.join_list(s, m)
    if not lists[m.name] then
        rednet.send(s, {success = false, status = "No such list."}, "SimpleMail")
        return
    end
    for _, mem in ipairs(lists[m.name]) do
        if mem == m.user then
            rednet.send(s, {success = false, status = "Already member."}, "SimpleMail")
            return
        end
    end
    table.insert(lists[m.name], m.user)
    if saveTableToFile(LISTS_DB, lists) then
        rednet.send(s, {success = true, status = "Joined list."}, "SimpleMail")
        logActivity("User '" .. m.user .. "' joined list '" .. m.name .. "'")
    end
end

function mailHandlers.get_lists(s, m)
    rednet.send(s, {lists = lists}, "SimpleMail")
end

function mailHandlers.get_motd(s, m)
    rednet.send(s, {motd = motd}, "SimpleMail")
end

function mailHandlers.get_chat_history(s, m)
    rednet.send(s, {history = chatHistory}, "SimpleMail")
end

function mailHandlers.get_unread_count(s, m)
    rednet.send(s, {type = "unread_count_response", count = #loadMail(m.user)}, "SimpleMail")
end

function mailHandlers.get_gamelist(s, m)
    rednet.send(s, {type = "gamelist_response", games = gameList}, "SimpleMail")
end

function mailHandlers.get_all_game_versions(s, m)
    local v = {}
    for f, d in pairs(gameCode) do
        v[f] = d.version
    end
    rednet.send(s, {type = "game_versions_response", versions = v}, "SimpleMail")
end

function mailHandlers.get_game_update(s, m)
    local f = m.filename
    if gameCode[f] then
        rednet.send(s, {type = "game_update_response", filename = f, code = gameCode[f].code}, "SimpleMail")
    end
end

function gameHandlers.submit_score(s, m)
    local g, u, sc = m.game, m.user, m.score
    if not games[g] then games[g] = {} end
    if not games[g][u] or sc > games[g][u] then
        games[g][u] = sc
        if saveTableToFile(GAMES_DB, games) then
            logActivity("New high score for '" .. u .. "' in '" .. g .. "': " .. sc)
        end
    end
end

function gameHandlers.get_leaderboard(s, m)
    local g = m.game
    local l = (games[g]) or {}
    rednet.send(s, {leaderboard = l}, "ArcadeGames")
end

function adminCommands.help()
    print("Commands: users, deluser, lists, dellist, board, delscore")
    print("motd, broadcast, publish, setlibpaste, addgame, delgame, games, publishgame")
end

function adminCommands.users()
    logActivity("Users:")
    for u, d in pairs(users) do
        logActivity("- " .. u .. " (Nick: " .. (d.nickname or "N/A") .. ")")
    end
end

function adminCommands.deluser(a)
    local u = a[2]
    if not u then
        logActivity("Usage: deluser <name>")
        return
    end
    if users[u] then
        users[u] = nil
        saveTableToFile(USERS_DB, users)
        logActivity("Deleted user: " .. u)
    else
        logActivity("User not found: " .. u)
    end
end

function adminCommands.lists()
    logActivity("Lists:")
    for n, m in pairs(lists) do
        logActivity("- " .. n .. " (" .. #m .. " members)")
    end
end

function adminCommands.dellist(a)
    local n = a[2]
    if not n then
        logActivity("Usage: dellist <name>")
        return
    end
    if lists[n] then
        lists[n] = nil
        saveTableToFile(LISTS_DB, lists)
        logActivity("Deleted list: " .. n)
    else
        logActivity("List not found: " .. n)
    end
end

function adminCommands.board(a)
    local g = a[2]
    if not g then
        logActivity("Usage: board <game>")
        return
    end
    if games[g] then
        logActivity("Board for " .. g .. ":")
        for u, s in pairs(games[g]) do
            logActivity("- " .. u .. ": " .. s)
        end
    else
        logActivity("No board for game: " .. g)
    end
end

function adminCommands.delscore(a)
    local g, u = a[2], a[3]
    if not g or not u then
        logActivity("Usage: delscore <game> <user>")
        return
    end
    if games[g] and games[g][u] then
        games[g][u] = nil
        saveTableToFile(GAMES_DB, games)
        logActivity("Deleted score for '" .. u .. "' in '" .. g .. "'")
    else
        logActivity("No score for user '" .. u .. "' in game '" .. g .. "'")
    end
end

function adminCommands.motd(a)
    table.remove(a, 1)
    motd = table.concat(a, " ")
    local f = fs.open(MOTD_FILE, "w")
    if f then
        f.write(motd)
        f.close()
    end
    logActivity("New MOTD set.")
end

function adminCommands.broadcast(a)
    table.remove(a, 1)
    local t = table.concat(a, " ")
    rednet.broadcast({type = "broadcast", text = t}, "SimpleMail")
    logActivity("Broadcast: " .. t)
end

function adminCommands.publish(a)
    local p, v = a[2], a[3]
    if not p or not v then
        logActivity("Usage: publish <prog> <ver>")
        return
    end
    local n = tonumber(v)
    if not n then
        logActivity("Version must be a number.")
        return
    end
    logActivity("Waiting for '" .. p .. "' v" .. n)
    local _, m = rednet.receive("Publication", 15)
    if m and m.code then
        programCode[p] = m.code
        programVersions[p] = n
        saveTableToFile(UPDATER_DB, {v = programVersions, c = programCode})
        logActivity("Published " .. p .. " v" .. n)
    else
        logActivity("Publish timed out.")
    end
end

function adminCommands.setlibpaste(args)
    local libName = args[2]
    local pasteCode = args[3]
    if not libName or not pasteCode then
        logActivity("Usage: setlibpaste <lib_name> <pastebin_code>", true)
        logActivity("Example: setlibpaste sha1_hmac aBcDeFgH", true)
        return
    end

    libraryPastes[libName] = pasteCode
    if saveTableToFile(LIB_PASTES_DB, libraryPastes) then
        logActivity("Set pastebin code for '"..libName.."' to "..pasteCode)
    else
        logActivity("Error: Could not save library paste database.", true)
        libraryPastes[libName] = nil -- Revert change on failure
    end
end

function adminCommands.addgame(a)
    local n, f = a[2], a[3]
    if not n or not f then
        logActivity("Usage: addgame <DisplayName> <filename>")
        return
    end
    table.insert(gameList, {name = n, file = f})
    saveTableToFile(GAMELIST_DB, gameList)
    logActivity("Added game '" .. n .. "'")
end

function adminCommands.delgame(a)
    local n = a[2]
    if not n then
        logActivity("Usage: delgame <DisplayName>")
        return
    end
    for i, g in ipairs(gameList) do
        if g.name == n then
            table.remove(gameList, i)
            saveTableToFile(GAMELIST_DB, gameList)
            logActivity("Removed game '" .. n .. "'")
            return
        end
    end
    logActivity("Game '" .. n .. "' not found.")
end

function adminCommands.games()
    logActivity("Games:")
    for _, g in ipairs(gameList) do
        logActivity("- " .. g.name .. " (file: " .. g.file .. ")")
    end
end

function adminCommands.publishgame(a)
    local f = a[2]
    if not f then
        logActivity("Usage: publishgame <filename>", true)
        return
    end
    if not fs.exists(f) then
        logActivity("File not found: " .. f, true)
        return
    end
    local h = fs.open(f, "r")
    if not h then
        logActivity("Cannot open file.", true)
        return
    end
    local c = h.readAll()
    h.close()
    local v = c:match("%-%-%s*Version:%s*([%d%.]+)")
    if not v then
        logActivity("No version comment in file.", true)
        return
    end
    gameCode[f] = {code = c, version = tonumber(v)}
    if saveTableToFile(GAMES_CODE_DB, gameCode) then
        logActivity("Published game '" .. f .. "' v" .. v)
    else
        logActivity("Failed to save game DB.", true)
    end
end

local function executeAdminCommand(command)
    local output = {}
    local oldPrint = print
    _G.print = function(...)
        local args = {...}
        local line = ""
        for i = 1, #args do
            line = line .. tostring(args[i]) .. "\t"
        end
        table.insert(output, line)
    end
    local args = {}
    for arg in command:gmatch("[^%s]+") do
        table.insert(args, arg)
    end
    local cmd = args[1]
    if adminCommands[cmd] then
        adminCommands[cmd](args)
    else
        print("Unknown command.")
    end
    _G.print = oldPrint
    return table.concat(output, "\n")
end

--==============================================================================
-- Main Program Loops
--==============================================================================

local function handleRednetMessage(senderId, message, protocol)
    if protocol == "SimpleMail" and message and message.type and mailHandlers[message.type] then
        mailHandlers[message.type](senderId, message)
    elseif protocol == "SimpleChat" and message and message.from then
        local nickname = (users[message.from] and users[message.from].nickname) or message.from
        local entry = string.format("[%s]: %s", nickname, message.text)
        table.insert(chatHistory, entry)
        if #chatHistory > 100 then table.remove(chatHistory, 1) end
        saveTableToFile(CHAT_DB, chatHistory)
        rednet.broadcast({ from = nickname, text = message.text }, "SimpleChat")
    elseif protocol == "ArcadeGames" and message and message.type and gameHandlers[message.type] then
        gameHandlers[message.type](senderId, message)
    elseif protocol == AUTH_INTERLINK_PROTOCOL and message.type == "user_exists_check" then
        local user = message.user
        rednet.send(senderId, { user = user, exists = (users[user] ~= nil) }, AUTH_INTERLINK_PROTOCOL)
    elseif protocol == ADMIN_PROTOCOL and message.type == "execute_command" then
        if message.user and admins[message.user] then
            logActivity("Executing remote command from admin: " .. message.user)
            local output = executeAdminCommand(message.command)
            rednet.send(senderId, { output = output }, ADMIN_PROTOCOL)
        else
            logActivity("Unauthorized admin command attempt from user: " .. (message.user or "unknown"), true)
            rednet.send(senderId, { output = "Error: Access denied." }, ADMIN_PROTOCOL)
        end
    end
end

local function handleTerminalInput(event, p1)
    if event == "key" then
        if p1 == keys.enter then
            if adminInput ~= "" then
                logActivity("Executing local command: " .. adminInput)
                local output = executeAdminCommand(adminInput)
                for line in output:gmatch("[^\n]+") do
                    logActivity(line)
                end
                adminInput = ""
            end
        elseif p1 == keys.backspace then
            adminInput = string.sub(adminInput, 1, -2)
        end
    elseif event == "char" then
        adminInput = adminInput .. p1
    end
    redrawAdminUI()
end

local function mainEventLoop()
    while true do
        local event, p1, p2, p3 = os.pullEvent()
        if event == "rednet_message" then
            handleRednetMessage(p1, p2, p3)
        elseif event == "key" or event == "char" then
            handleTerminalInput(event, p1)
        elseif event == "terminate" then
            break
        end
    end
end

local function main()
    loadAllData()
    -- Open all attached modems
    for _, side in ipairs(rs.getSides()) do
        if peripheral.getType(side) == "modem" then
            rednet.open(side)
        end
    end

    rednet.host("SimpleMail", "mail.server")
    rednet.host("SimpleChat", "chat.server")
    rednet.host("ArcadeGames", "arcade.server")
    rednet.host(ADMIN_PROTOCOL, "admin.server")
    logActivity("Mainframe Server started.")
    
    mainEventLoop()
end

main()

