--[[
    Drunken OS - Mainframe Server (v10.11 - Definitive Auth Fix)
    by Gemini Gem & MuhendizBey

    Purpose:
    This definitive version reverts the authentication logic to a stable,
    synchronous model based on user-provided working code. This resolves all
    timeout, race condition, and data handling issues, while retaining the
    necessary password hashing fixes.

    Key Changes:
    - Removed all asynchronous `parallel` calls from the authentication flow.
    - Re-engineered the `register` and `login` handlers to follow a simple,
      synchronous (blocking) sequence, eliminating the race condition.
    - Restored the user-provided, working `submit_auth_token` logic.
    - This is the new stable baseline for the server.
]]

--==============================================================================
-- Environment Setup
--==============================================================================

-- Add the current program's directory to the package path. This allows us to use
-- a local `lib` folder for our required modules.
package.path = fs.getDir(shell.getRunningProgram()) .. "/?.lua;" .. package.path

--==============================================================================
-- API & Library Initialization
--==============================================================================

-- Securely load the cryptography library. If it fails, the server cannot run.
local ok_crypto, crypto = pcall(require, "lib.sha1_hmac")
if not ok_crypto then
    term.setBackgroundColor(colors.red); term.setTextColor(colors.white); term.clear(); term.setCursorPos(1, 1)
    print("================ FATAL ERROR ================")
    print("Required library 'lib/sha1_hmac' not found!")
    print("Please ensure the file exists at either:")
    print(" > /lib/sha1_hmac.lua")
    print(" > " .. fs.getDir(shell.getRunningProgram()) .. "/lib/sha1_hmac.lua")
    print("=============================================")
    print("Server shutting down.")
    error("sha1_hmac library not found.", 0)
end

-- Securely load the HyperAuthClient API. This is critical for authentication.
local ok_auth, AuthClient = pcall(require, "HyperAuthClient/api/auth_client")
if not ok_auth then
    term.setBackgroundColor(colors.red); term.setTextColor(colors.white); term.clear(); term.setCursorPos(1, 1)
    print("================ FATAL ERROR ================")
    print("The HyperAuthClient API could not be found.")
    print("Please ensure the file exists at:")
    print(" > /HyperAuthClient/api/auth_client.lua")
    print("=============================================")
    print("Server shutting down.")
    error("HyperAuthClient API not found.", 0)
end

--==============================================================================
-- Configuration & State
--==============================================================================

local admins = { ["MuhendizBey"] = true }
local users, lists, games, chatHistory, gameList, pendingAuths, libraryPastes = {}, {}, {}, {}, {}, {}, {}
local programVersions, programCode, gameCode = {}, {}, {}
local logHistory, adminInput, motd = {}, "", ""

-- Database file paths
local USERS_DB = "users.db"
local LISTS_DB = "lists.db"
local GAMES_DB = "games.db"
local CHAT_DB = "chat.db"
local UPDATER_DB = "updater.db"
local GAMELIST_DB = "gamelist.db"
local MOTD_FILE = "motd.txt"
local LOG_FILE = "server.log"
local GAMES_CODE_DB = "games_code.db"
local LIB_PASTES_DB = "lib_pastes.db"

-- Network protocols
local AUTH_SERVER_PROTOCOL = "auth.secure.v1"
local AUTH_INTERLINK_PROTOCOL = "Drunken_Auth_Interlink"
local ADMIN_PROTOCOL = "Drunken_Admin"

--==============================================================================
-- UI & Theme Configuration
--==============================================================================

local hasColor = term.isColor and term.isColor()
local theme = {
    bg = hasColor and colors.black or colors.black,
    text = hasColor and colors.white or colors.white,
    windowBg = hasColor and colors.darkGray or colors.gray,
    title = hasColor and colors.red or colors.red,
    prompt = hasColor and colors.cyan or colors.cyan,
    statusBarBg = hasColor and colors.gray or colors.lightGray,
    statusBarText = hasColor and colors.white or colors.white
}

---
-- Wraps long lines of text to fit within a specified width.
-- @param text The string to wrap.
-- @param width The maximum width of each line.
-- @return {table} A table of strings, each representing a wrapped line.
local function wordWrap(text, width)
    local lines = {}
    for line in text:gmatch("[^\n]+") do
        if #line <= width then
            table.insert(lines, line)
        else
            local currentLine = ""
            for word in line:gmatch("[^%s]+") do
                if #currentLine + #word + 1 > width then
                    table.insert(lines, currentLine)
                    currentLine = word
                else
                    currentLine = currentLine == "" and word or (currentLine .. " " .. word)
                end
            end
            table.insert(lines, currentLine)
        end
    end
    return lines
end

---
-- Redraws the entire admin console UI on the server's terminal.
local function redrawAdminUI()
    local w, h = term.getSize()
    term.setBackgroundColor(theme.windowBg)
    term.clear()

    -- Draw title bar
    term.setBackgroundColor(theme.title)
    term.setCursorPos(1, 1)
    term.write((" "):rep(w))
    term.setTextColor(colors.white)
    local title = " Mainframe Admin Console "
    term.setCursorPos(math.floor((w - #title) / 2) + 1, 1)
    term.write(title)

    -- Draw status bar
    term.setBackgroundColor(theme.statusBarBg)
    term.setTextColor(theme.statusBarText)
    term.setCursorPos(1, h)
    term.write((" "):rep(w))
    local status = "RUNNING | Type 'help' for commands"
    term.setCursorPos(2, h)
    term.write(status)

    -- Draw log area
    term.setBackgroundColor(theme.windowBg)
    term.setTextColor(theme.text)
    local logAreaHeight = h - 4
    local displayLines = {}
    for i = #logHistory, 1, -1 do
        local wrappedLines = wordWrap(logHistory[i], w - 2)
        for j = #wrappedLines, 1, -1 do
            table.insert(displayLines, 1, " " .. wrappedLines[j])
            if #displayLines >= logAreaHeight then break end
        end
        if #displayLines >= logAreaHeight then break end
    end
    for i = 1, math.min(#displayLines, logAreaHeight) do
        term.setCursorPos(1, 1 + i)
        term.write(displayLines[i])
    end

    -- Draw input area
    term.setCursorPos(1, h - 2)
    term.write(('-'):rep(w))
    term.setCursorPos(1, h - 1)
    term.setTextColor(theme.prompt)
    term.write("> ")
    term.setTextColor(theme.text)
    term.write(adminInput)
end

---
-- Logs a message to the admin console and a file.
-- @param message The message to log.
-- @param isError (Optional) True if the message is an error.
local function logActivity(message, isError)
    local prefix = isError and "[ERROR] " or "[INFO] "
    local logEntry = os.date("[%H:%M:%S] ") .. prefix .. message
    
    table.insert(logHistory, logEntry)
    if #logHistory > 200 then table.remove(logHistory, 1) end
    
    local file = fs.open(LOG_FILE, "a")
    if file then
        file.writeLine(os.date("[%Y-%m-%d %H:%M:%S] ") .. prefix .. message)
        file.close()
    end
    
    redrawAdminUI()
end

--==============================================================================
-- Data Persistence Functions
--==============================================================================

---
-- Saves a Lua table to a file using textutils.serialize.
-- @param path The file path to save to.
-- @param data The table to save.
-- @return {boolean} True on success, false on failure.
local function saveTableToFile(path, data)
    local file = fs.open(path, "w")
    if not file then
        logActivity("Could not open " .. path, true)
        return false
    end
    local success, err = pcall(function()
        file.write(textutils.serialize(data))
        file.close()
    end)
    if not success then
        logActivity("Failed to write to " .. path .. ': ' .. tostring(err), true)
        return false
    end
    return true
end

---
-- Loads a Lua table from a file.
-- @param path The file path to load from.
-- @return {table} The loaded table, or an empty table on failure.
local function loadTableFromFile(path)
    if fs.exists(path) then
        local file = fs.open(path, "r")
        if file then
            local data = file.readAll()
            file.close()
            local success, result = pcall(textutils.unserialize, data)
            if success and type(result) == "table" then
                return result
            else
                logActivity("Corrupted data in " .. path, true)
            end
        end
    end
    return {}
end

---
-- Loads all server databases from disk into memory.
local function loadAllData()
    users = loadTableFromFile(USERS_DB)
    lists = loadTableFromFile(LISTS_DB)
    games = loadTableFromFile(GAMES_DB)
    chatHistory = loadTableFromFile(CHAT_DB)
    gameList = loadTableFromFile(GAMELIST_DB)
    libraryPastes = loadTableFromFile(LIB_PASTES_DB)
    local updaterData = loadTableFromFile(UPDATER_DB)
    programVersions = updaterData.v or {}
    programCode = updaterData.c or {}
    gameCode = loadTableFromFile(GAMES_CODE_DB)
    if fs.exists(MOTD_FILE) then
        local file = fs.open(MOTD_FILE, "r")
        motd = file.readAll()
        file.close()
    end
    logActivity("Mainframe data loaded.")
end

--==============================================================================
-- Mail & List Management Functions
--==============================================================================

local function saveItem(user, item, itemType)
    local dir = itemType .. "/" .. user
    if not fs.exists(dir) then fs.makeDir(dir) end
    local id = os.time() .. "-" .. math.random(100, 999)
    saveTableToFile(dir .. "/" .. id, item)
end

local function loadMail(user)
    local path = "mail/" .. user
    local mail = {}
    if fs.exists(path) and fs.isDir(path) then
        for _, fileName in ipairs(fs.list(path)) do
            local mailPath = path .. "/" .. fileName
            local handle = fs.open(mailPath, "r")
            if handle then
                local data = handle.readAll()
                handle.close()
                local success, item = pcall(textutils.unserialize, data)
                if success and item then
                    item.id = fileName
                    table.insert(mail, item)
                else
                    logActivity("Corrupted mail file: " .. mailPath, true)
                end
            end
        end
    end
    return mail
end

local function deleteItem(user, id, itemType)
    local path = itemType .. "/" .. user .. "/" .. id
    if fs.exists(path) then
        fs.delete(path)
        return true
    end
    return false
end

--==============================================================================
-- Authentication Helper Functions
--==============================================================================

local function requestAuthCode(username, password, nickname, senderId, purpose)
    logActivity("Requesting auth code for '" .. username .. "'...")
    local reply, err = AuthClient.requestCode(AUTH_SERVER_PROTOCOL, {
        username = username,
        password = password,
        vendorID = "DrunkenOS_Mainframe",
        computerID = os.getComputerID(),
        extra = { purpose = purpose or "unknown" },
    })
    
    if not reply then
        logActivity("HyperAuth error: " .. tostring(err), true)
        rednet.send(senderId, { success = false, reason = "Auth service error." }, "SimpleMail")
        return nil
    end
    
    logActivity("Auth request ID created: " .. reply.request_id)
    pendingAuths[username] = {
        request_id = reply.request_id,
        password = password,
        nickname = nickname,
        senderId = senderId,
        timestamp = os.time()
    }
    return true
end

--==============================================================================
-- Network Request Handlers
--==============================================================================

local mailHandlers = {}

function mailHandlers.get_version(senderId, message)
    rednet.send(senderId, { version = programVersions[message.program] or 0 }, "SimpleMail")
end

function mailHandlers.get_update(senderId, message)
    rednet.send(senderId, { code = programCode[message.program] }, "SimpleMail")
end

-- UNIFIED LIBRARY HANDLER: Serves code directly from the programCode database.
function mailHandlers.get_lib_code(senderId, message)
    local libName = message.lib
    if not libName then return end

    if programCode[libName] then
        rednet.send(senderId, { success = true, code = programCode[libName] }, "SimpleMail")
        logActivity("Served library '" .. libName .. "' to client " .. senderId)
    else
        logActivity("Client requested non-existent library: '" .. libName .. "'", true)
        rednet.send(senderId, { success = false, reason = "Library not in server database." }, "SimpleMail")
    end
end

function mailHandlers.register(senderId, message)
    if users[message.user] then
        rednet.send(senderId, { success = false, reason = "Username taken." }, "SimpleMail")
        return
    end

    -- This now waits for the auth code request to complete before replying.
    if requestAuthCode(message.user, message.pass, message.nickname, senderId, "register") then
        rednet.send(senderId, { success = true, needs_auth = true }, "SimpleMail")
    end
end

---
-- Handles a user login using a synchronous flow and graceful migration.
function mailHandlers.login(senderId, message)
    local userData = users[message.user]
    local receivedHash = message.pass

    if not userData then
        rednet.send(senderId, { success = false, reason = "Invalid credentials." }, "SimpleMail")
        return
    end

    local storedHash = userData.password
    local loginSuccess = false
    local needsMigration = false

    if storedHash == receivedHash then
        loginSuccess = true
    elseif storedHash == crypto.hex(receivedHash) then
        loginSuccess = true
        needsMigration = true
        logActivity("Legacy password for '" .. message.user .. "' detected. Migrating.")
    end

    if not loginSuccess then
        rednet.send(senderId, { success = false, reason = "Invalid credentials." }, "SimpleMail")
        return
    end

    if needsMigration then
        users[message.user].password = receivedHash
        saveTableToFile(USERS_DB, users)
    end
    
    if message.session_token and users[message.user].session_token == message.session_token then
        logActivity("'" .. message.user .. "' logged in via session.")
        rednet.send(senderId, { success = true, needs_auth = false, nickname = users[message.user].nickname, unreadCount = #loadMail(message.user), isAdmin = admins[message.user] or false }, "SimpleMail")
        return
    end
    
    -- This now waits for the auth code request to complete before replying.
    if requestAuthCode(message.user, receivedHash, nil, senderId, "login") then
        rednet.send(senderId, { success = true, needs_auth = true }, "SimpleMail")
    end
end

function mailHandlers.submit_auth_token(senderId, message)
    local user, code = message.user, message.token
    logActivity("Received auth submission from '" .. user .. "'")
    
    local authData = pendingAuths[user]
    if not authData then
        rednet.send(senderId, { success = false, reason = "No pending auth." }, "SimpleMail")
        return
    end

    logActivity("Verifying code for RID: " .. authData.request_id)
    local reply, err = AuthClient.verifyCode(AUTH_SERVER_PROTOCOL, { request_id = authData.request_id, code = code })
    
    if not reply then
        logActivity("Auth verify error: " .. tostring(err), true)
        rednet.send(senderId, { success = false, reason = "Auth service error." }, "SimpleMail")
        return
    end

    if reply.ok then
        local payload = {}
        local token = crypto.hex(os.time() .. math.random())
        if not users[user] then -- This is a registration
            users[user] = { password = authData.password, nickname = authData.nickname, session_token = token }
            if saveTableToFile(USERS_DB, users) then
                payload = { success = true, unreadCount = 0, nickname = authData.nickname, session_token = token, isAdmin = admins[user] or false }
                logActivity("User '" .. user .. "' registered.")
            else
                payload = { success = false, reason = "DB error." }
            end
        else -- This is a login
            users[user].session_token = token
            saveTableToFile(USERS_DB, users)
            payload = { success = true, unreadCount = #loadMail(user), nickname = users[user].nickname, session_token = token, isAdmin = admins[user] or false }
            logActivity("User '" .. user .. "' logged in.")
        end
        rednet.send(senderId, payload, "SimpleMail")
        pendingAuths[user] = nil
    else
        rednet.send(senderId, { success = false, reason = reply.reason or "Invalid code." }, "SimpleMail")
        logActivity("Auth fail for " .. user .. ': ' .. (reply.reason or "Unknown"), true)
    end
end

function mailHandlers.user_exists(senderId, message)
    local recipient = message.user
    local exists = false
    if recipient and recipient ~= "" then
        if recipient == "@all" then
            exists = true
        elseif recipient:sub(1, 1) == "@" then
            exists = lists[recipient:sub(2)] ~= nil
        else
            exists = users[recipient] ~= nil
        end
    end
    rednet.send(senderId, { exists = exists }, "SimpleMail")
end

function mailHandlers.send(senderId, message)
    local mail = message.mail
    if mail.to == "@all" then
        for user, _ in pairs(users) do saveItem(user, mail, "mail") end
        logActivity(string.format("Mail from '%s' to @all", mail.from_nickname))
    elseif mail.to:sub(1, 1) == "@" then
        local list = mail.to:sub(2)
        if lists[list] then
            for _, member in ipairs(lists[list]) do saveItem(member, mail, "mail") end
            logActivity(string.format("Mail from '%s' to list '%s'", mail.from_nickname, list))
        end
    else
        saveItem(mail.to, mail, "mail")
        logActivity(string.format("Mail from '%s' to '%s'", mail.from_nickname, mail.to))
    end
    rednet.send(senderId, { status = "Sent!" }, "SimpleMail")
end

function mailHandlers.fetch(senderId, message)
    rednet.send(senderId, { mail = loadMail(message.user) }, "SimpleMail")
end

function mailHandlers.delete(senderId, message)
    if deleteItem(message.user, message.id, "mail") then
        logActivity(string.format("User '%s' deleted mail '%s'", message.user, message.id))
    end
end

function mailHandlers.create_list(senderId, message)
    if lists[message.name] then
        rednet.send(senderId, { success = false, status = "List exists." }, "SimpleMail")
    else
        lists[message.name] = { message.creator }
        if saveTableToFile(LISTS_DB, lists) then
            rednet.send(senderId, { success = true, status = "List created." }, "SimpleMail")
            logActivity(string.format("'%s' created list '%s'", message.creator, message.name))
        end
    end
end

function mailHandlers.join_list(senderId, message)
    if not lists[message.name] then
        rednet.send(senderId, { success = false, status = "List not found." }, "SimpleMail")
        return
    end
    for _, member in ipairs(lists[message.name]) do
        if member == message.user then
            rednet.send(senderId, { success = false, status = "Already a member." }, "SimpleMail")
            return
        end
    end
    table.insert(lists[message.name], message.user)
    if saveTableToFile(LISTS_DB, lists) then
        rednet.send(senderId, { success = true, status = "Joined list." }, "SimpleMail")
        logActivity(string.format("'%s' joined list '%s'", message.user, message.name))
    end
end

function mailHandlers.get_lists(senderId, message)
    rednet.send(senderId, { lists = lists }, "SimpleMail")
end

function mailHandlers.get_motd(senderId, message)
    rednet.send(senderId, { motd = motd }, "SimpleMail")
end

function mailHandlers.get_chat_history(senderId, message)
    rednet.send(senderId, { history = chatHistory }, "SimpleMail")
end

function mailHandlers.get_unread_count(senderId, message)
    rednet.send(senderId, { type = "unread_count_response", count = #loadMail(message.user) }, "SimpleMail")
end

function mailHandlers.get_gamelist(senderId, message)
    rednet.send(senderId, { type = "gamelist_response", games = gameList }, "SimpleMail")
end

function mailHandlers.get_all_game_versions(senderId, message)
    local versions = {}
    for filename, data in pairs(gameCode) do
        versions[filename] = data.version
    end
    rednet.send(senderId, { type = "game_versions_response", versions = versions }, "SimpleMail")
end

function mailHandlers.get_game_update(senderId, message)
    local filename = message.filename
    if gameCode[filename] then
        rednet.send(senderId, { type = "game_update_response", filename = filename, code = gameCode[filename].code }, "SimpleMail")
    end
end

local gameHandlers = {}

function gameHandlers.submit_score(senderId, message)
    local game, user, score = message.game, message.user, message.score
    if not games[game] then games[game] = {} end
    if not games[game][user] or score > games[game][user] then
        games[game][user] = score
        if saveTableToFile(GAMES_DB, games) then
            logActivity(string.format("New score for '%s' in '%s': %d", user, game, score))
        end
    end
end

function gameHandlers.get_leaderboard(senderId, message)
    local game = message.game
    local leaderboard = (games[game]) or {}
    rednet.send(senderId, { leaderboard = leaderboard }, "ArcadeGames")
end

--==============================================================================
-- Admin Command Handlers & Main Loops (REPAIRED)
--==============================================================================

local adminCommands = {}

function adminCommands.help()
    logActivity("--- Mainframe Admin Commands ---")
    logActivity("users, deluser, lists, dellist, board, delscore")
    logActivity("motd, broadcast, publish, addgame, delgame, games, publishgame")
end

function adminCommands.users()
    logActivity("Users:")
    for u, d in pairs(users) do
        logActivity("- " .. u .. " (Nick: " .. (d.nickname or "N/A") .. ")")
    end
end

function adminCommands.deluser(a)
    local u = a[2]
    if not u then
        logActivity("Usage: deluser <name>")
        return
    end
    if users[u] then
        users[u] = nil
        saveTableToFile(USERS_DB, users)
        logActivity("Deleted user: " .. u)
    else
        logActivity("User not found: " .. u)
    end
end

function adminCommands.lists()
    logActivity("Lists:")
    for n, m in pairs(lists) do
        logActivity("- " .. n .. " (" .. #m .. " members)")
    end
end

function adminCommands.dellist(a)
    local n = a[2]
    if not n then
        logActivity("Usage: dellist <name>")
        return
    end
    if lists[n] then
        lists[n] = nil
        saveTableToFile(LISTS_DB, lists)
        logActivity("Deleted list: " .. n)
    else
        logActivity("List not found: " .. n)
    end
end

function adminCommands.board(a)
    local g = a[2]
    if not g then
        logActivity("Usage: board <game>")
        return
    end
    if games[g] then
        logActivity("Board for " .. g .. ":")
        for u, s in pairs(games[g]) do
            logActivity("- " .. u .. ": " .. s)
        end
    else
        logActivity("No board for game: " .. g)
    end
end

function adminCommands.delscore(a)
    local g, u = a[2], a[3]
    if not g or not u then
        logActivity("Usage: delscore <game> <user>")
        return
    end
    if games[g] and games[g][u] then
        games[g][u] = nil
        saveTableToFile(GAMES_DB, games)
        logActivity("Deleted score for '" .. u .. "' in '" .. g .. "'")
    else
        logActivity("No score for user '" .. u .. "' in game '" .. g .. "'")
    end
end

function adminCommands.motd(a)
    table.remove(a, 1)
    motd = table.concat(a, " ")
    local f = fs.open(MOTD_FILE, "w")
    if f then
        f.write(motd)
        f.close()
    end
    logActivity("New MOTD set.")
end

function adminCommands.broadcast(a)
    table.remove(a, 1)
    local t = table.concat(a, " ")
    rednet.broadcast({type = "broadcast", text = t}, "SimpleMail")
    logActivity("Broadcast: " .. t)
end

function adminCommands.publish(a)
    local progName, versionOrPath = a[2], a[3]
    if not progName or not versionOrPath then
        logActivity("Usage: publish <name> <version_or_path>")
        logActivity("For programs: publish Drunken_OS_Client 11.9")
        logActivity("For libraries: publish sha1_hmac /lib/sha1_hmac.lua")
        return
    end

    local isLibrary = fs.exists(versionOrPath)

    if isLibrary then
        -- This is a library publication
        local filePath = versionOrPath
        local file, err = fs.open(filePath, "r")
        if not file then
            logActivity("Error opening file: " .. tostring(err), true)
            return
        end

        local code = file.readAll()
        file.close()

        programCode[progName] = code
        if saveTableToFile(UPDATER_DB, {v = programVersions, c = programCode}) then
            logActivity("Published library '" .. progName .. "' to code database.")
        else
            logActivity("Error: Could not save updater database.", true)
            programCode[progName] = nil -- Revert on failure
        end
    else
        -- This is a versioned program publication
        local n = tonumber(versionOrPath)
        if not n then
            logActivity("Version must be a number for programs.", true)
            return
        end
        logActivity("Waiting for '" .. progName .. "' v" .. n .. " publication...")
        local _, m = rednet.receive("Publication", 15)
        if m and m.code then
            programCode[progName] = m.code
            programVersions[progName] = n
            saveTableToFile(UPDATER_DB, {v = programVersions, c = programCode})
            logActivity("Published " .. progName .. " v" .. n)
        else
            logActivity("Publish timed out.")
        end
    end
end

function adminCommands.setlibpaste(args)
    local libName = args[2]
    local pasteCode = args[3]
    if not libName or not pasteCode then
        logActivity("Usage: setlibpaste <lib_name> <pastebin_code>", true)
        logActivity("Example: setlibpaste sha1_hmac aBcDeFgH", true)
        return
    end
    libraryPastes[libName] = pasteCode
    if saveTableToFile(LIB_PASTES_DB, libraryPastes) then
        logActivity("Set pastebin code for '"..libName.."' to "..pasteCode)
    else
        logActivity("Error: Could not save library paste database.", true)
        libraryPastes[libName] = nil -- Revert change on failure
    end
end

function adminCommands.addgame(a)
    local n, f = a[2], a[3]
    if not n or not f then
        logActivity("Usage: addgame <DisplayName> <filename>")
        return
    end
    table.insert(gameList, {name = n, file = f})
    saveTableToFile(GAMELIST_DB, gameList)
    logActivity("Added game '" .. n .. "'")
end

function adminCommands.delgame(a)
    local n = a[2]
    if not n then
        logActivity("Usage: delgame <DisplayName>")
        return
    end
    for i, g in ipairs(gameList) do
        if g.name == n then
            table.remove(gameList, i)
            saveTableToFile(GAMELIST_DB, gameList)
            logActivity("Removed game '" .. n .. "'")
            return
        end
    end
    logActivity("Game '" .. n .. "' not found.")
end

function adminCommands.games()
    logActivity("Games:")
    for _, g in ipairs(gameList) do
        logActivity("- " .. g.name .. " (file: " .. g.file .. ")")
    end
end

function adminCommands.publishgame(a)
    local f = a[2]
    if not f then
        logActivity("Usage: publishgame <filename>", true)
        return
    end
    if not fs.exists(f) then
        logActivity("File not found: " .. f, true)
        return
    end
    local h = fs.open(f, "r")
    if not h then
        logActivity("Cannot open file.", true)
        return
    end
    local c = h.readAll()
    h.close()
    local v = c:match("%-%-%s*Version:%s*([%d%.]+)")
    if not v then
        logActivity("No version comment in file.", true)
        return
    end
    gameCode[f] = {code = c, version = tonumber(v)}
    if saveTableToFile(GAMES_CODE_DB, gameCode) then
        logActivity("Published game '" .. f .. "' v" .. v)
    else
        logActivity("Failed to save game DB.", true)
    end
end

local function executeAdminCommand(command)
    local output = {}
    local oldPrint = print
    _G.print = function(...)
        local args = {...}
        local line = ""
        for i = 1, #args do
            line = line .. tostring(args[i]) .. "\t"
        end
        table.insert(output, line)
    end
    local args = {}
    for arg in command:gmatch("[^%s]+") do
        table.insert(args, arg)
    end
    local cmd = args[1]
    if adminCommands[cmd] then
        adminCommands[cmd](args)
    else
        print("Unknown command.")
    end
    _G.print = oldPrint
    return table.concat(output, "\n")
end

local function handleRednetMessage(senderId, message, protocol)
    if protocol == "SimpleMail" and message and message.type and mailHandlers[message.type] then
        mailHandlers[message.type](senderId, message)
    elseif protocol == "SimpleChat" and message and message.from then
        local nickname = users[message.from] and users[message.from].nickname or message.from
        local entry = string.format("[%s]: %s", nickname, message.text)
        table.insert(chatHistory, entry)
        if #chatHistory > 100 then table.remove(chatHistory, 1) end
        saveTableToFile(CHAT_DB, chatHistory)
        rednet.broadcast({ from = nickname, text = message.text }, "SimpleChat")
    elseif protocol == "ArcadeGames" and message and message.type and gameHandlers[message.type] then
        gameHandlers[message.type](senderId, message)
    elseif protocol == AUTH_INTERLINK_PROTOCOL and message.type == "user_exists_check" then
        local user = message.user
        rednet.send(senderId, { user = user, exists = (users[user] ~= nil) }, AUTH_INTERLINK_PROTOCOL)
    elseif protocol == ADMIN_PROTOCOL and message.type == "execute_command" then
        if message.user and admins[message.user] then
            logActivity("Remote cmd from " .. message.user)
            local output = executeAdminCommand(message.command)
            rednet.send(senderId, { output = output }, ADMIN_PROTOCOL)
        else
            logActivity("Unauthorized cmd from " .. (message.user or "unknown"), true)
            rednet.send(senderId, { output = "Access denied." }, ADMIN_PROTOCOL)
        end
    end
end

local function handleTerminalInput(event, p1)
    if event == "key" then
        if p1 == keys.enter then
            if adminInput ~= "" then
                logActivity("Local cmd: " .. adminInput)
                local output = executeAdminCommand(adminInput)
                for line in output:gmatch("[^\n]+") do logActivity(line) end
                adminInput = ""
            end
        elseif p1 == keys.backspace then
            adminInput = adminInput:sub(1, -2)
        end
    elseif event == "char" then
        adminInput = adminInput .. p1
    end
    redrawAdminUI()
end

local function mainEventLoop()
    while true do
        local event, p1, p2, p3 = os.pullEvent()
        if event == "rednet_message" then
            handleRednetMessage(p1, p2, p3)
        elseif event == "key" or event == "char" then
            handleTerminalInput(event, p1)
        elseif event == "terminate" then
            break
        end
    end
end

local function main()
    loadAllData()
    for _, side in ipairs(rs.getSides()) do
        if peripheral.getType(side) == "modem" then
            rednet.open(side)
        end
    end
    rednet.host("SimpleMail", "mail.server")
    rednet.host("SimpleChat", "chat.server")
    rednet.host("ArcadeGames", "arcade.server")
    rednet.host(ADMIN_PROTOCOL, "admin.server")
    logActivity("Mainframe Server v10.11 Initialized.")
    mainEventLoop()
end

main()
