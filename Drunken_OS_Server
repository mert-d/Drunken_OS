--[[
    Drunken OS - Mainframe Server (v8.6 - Robust Pathing & Lib Check)
    by Gemini Gem

    Purpose:
    This version includes a more robust fix for the `require()` system. It
    now explicitly gets the running script's directory and adds a startup
    check to ensure all required libraries are present, providing a clearer
    error message to the user if a file is missing.

    Key Changes:
    - Replaced `shell.dir()` with `fs.getDir(shell.getRunningProgram())` for
      a more reliable way to determine the script's location.
    - Added a startup check that verifies the existence of the `sha1_hmac`
      library and provides a user-friendly error if it's not found.
]]

--==============================================================================
-- Environment Setup
--==============================================================================

-- Explicitly get the directory of the running program.
local program_directory = fs.getDir(shell.getRunningProgram())

-- Add this program's directory to the list of places Lua looks for libraries.
-- This ensures that `require("lib.sha1_hmac")` will work correctly.
package.path = program_directory .. "/?.lua;" .. package.path

-- Startup Check: Verify that required libraries exist before trying to load them.
local crypto_path = fs.combine(program_directory, "lib/sha1_hmac.lua")
if not fs.exists(crypto_path) then
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1, 1)
    print("================ FATAL ERROR ================")
    print("Required library not found!")
    print("Please make sure the following file exists:")
    print(" > " .. crypto_path)
    print("=============================================")
    error("Missing required library.", 0)
end

--==============================================================================
-- API & Library Initialization
--==============================================================================

-- Load our new, centralized cryptography library.
local crypto = require("lib.sha1_hmac")

-- Load the HyperAuth Client API for secure authentication.
local AuthClient = require("HyperAuthClient/api/auth_client")

if not AuthClient then
    term.setBackgroundColor(colors.red)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1, 1)
    print("================ FATAL ERROR ================")
    print("The HyperAuthClient API could not be found.")
    print("Please ensure the file exists at:")
    print(" > /HyperAuthClient/api/auth_client.lua")
    print("=============================================")
    print("Server shutting down.")
    error("HyperAuthClient API not found.", 0)
end

--==============================================================================
-- Configuration
--==============================================================================
-- A list of users who are allowed to use the remote admin console.
local admins = {
    ["MuhendizBey"] = true,
}

--==============================================================================
-- State Variables
--==============================================================================

local users, lists, games, chatHistory, gameList, pendingAuths = {}, {}, {}, {}, {}, {}
local programVersions, programCode, gameCode = {}, {}, {}
local logHistory, adminInput, motd = {}, "", ""

-- Database file paths
local USERS_DB = "users.db"
local LISTS_DB = "lists.db"
local GAMES_DB = "games.db"
local CHAT_DB = "chat.db"
local UPDATER_DB = "updater.db"
local GAMELIST_DB = "gamelist.db"
local MOTD_FILE = "motd.txt"
local LOG_FILE = "server.log"
local GAMES_CODE_DB = "games_code.db"

-- HyperAuth Server Configuration
local AUTH_SERVER_PROTOCOL = "auth.secure.v1"
local AUTH_INTERLINK_PROTOCOL = "Drunken_Auth_Interlink"
local ADMIN_PROTOCOL = "Drunken_Admin"

--==============================================================================
-- UI & Theme Configuration (for the admin terminal)
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then return colors[colorName] end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    title = safeColor("red", colors.red),
    prompt = safeColor("cyan", colors.cyan),
    statusBarBg = safeColor("gray", colors.lightGray),
    statusBarText = safeColor("white", colors.white),
}

local function wordWrap(text, width)
    local finalLines = {}
    for line in string.gmatch(text, "[^\n]+") do
        if #line <= width then
            table.insert(finalLines, line)
        else
            local currentWrappedLine = ""
            for word in string.gmatch(line, "[^%s]+") do
                if #currentWrappedLine + #word + 1 > width then
                    table.insert(finalLines, currentWrappedLine)
                    currentWrappedLine = word
                else
                    currentWrappedLine = currentWrappedLine == "" and word or (currentWrappedLine .. " " .. word)
                end
            end
            table.insert(finalLines, currentWrappedLine)
        end
    end
    return finalLines
end

local function redrawAdminUI()
    local w, h = term.getSize()
    term.setBackgroundColor(theme.windowBg); term.clear()
    term.setBackgroundColor(theme.title); term.setCursorPos(1, 1); term.write(string.rep(" ", w)); term.setTextColor(colors.white)
    local titleText = " Mainframe Admin Console "; term.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1); term.write(titleText)
    term.setBackgroundColor(theme.statusBarBg); term.setTextColor(theme.statusBarText); term.setCursorPos(1, h); term.write(string.rep(" ", w))
    local statusText = "RUNNING | Type 'help' for commands"; term.setCursorPos(2, h); term.write(statusText)
    term.setBackgroundColor(theme.windowBg); term.setTextColor(theme.text)
    local logAreaHeight = h - 4
    local displayLines = {}
    for i = #logHistory, 1, -1 do
        local wrapped = wordWrap(logHistory[i], w - 2)
        for j = #wrapped, 1, -1 do
            table.insert(displayLines, 1, " " .. wrapped[j])
            if #displayLines >= logAreaHeight then break end
        end
        if #displayLines >= logAreaHeight then break end
    end
    for i = 1, math.min(#displayLines, logAreaHeight) do term.setCursorPos(1, 1 + i); term.write(displayLines[i]) end
    term.setCursorPos(1, h - 2); term.write(string.rep("-", w))
    term.setCursorPos(1, h - 1); term.setTextColor(theme.prompt); term.write("> "); term.setTextColor(theme.text); term.write(adminInput)
end

local function logActivity(message, isError)
    local prefix = isError and "[ERROR] " or "[INFO] "
    local logEntry = os.date("[%H:%M:%S] ") .. prefix .. message
    table.insert(logHistory, logEntry)
    if #logHistory > 200 then table.remove(logHistory, 1) end
    local file = fs.open(LOG_FILE, "a")
    if file then file.writeLine(os.date("[%Y-%m-%d %H:%M:%S] ") .. prefix .. message); file.close() end
    redrawAdminUI()
end

--==============================================================================
-- Data Persistence Functions
--==============================================================================

local function saveTableToFile(path, data)
    local file = fs.open(path, "w")
    if not file then logActivity("Could not open " .. path .. " for writing.", true); return false end
    local success, err = pcall(function() file.write(textutils.serialize(data)); file.close() end)
    if not success then logActivity("Failed to write to " .. path .. ": " .. tostring(err), true); return false end
    return true
end

local function loadTableFromFile(path)
    if fs.exists(path) then
        local file = fs.open(path, "r")
        if file then
            local data = file.readAll(); file.close()
            local success, result = pcall(textutils.unserialize, data)
            if success and type(result) == "table" then return result
            else logActivity("Corrupted data in " .. path .. ". A new file will be created.", true) end
        end
    end
    return {}
end

local function loadAllData()
    users = loadTableFromFile(USERS_DB)
    lists = loadTableFromFile(LISTS_DB)
    games = loadTableFromFile(GAMES_DB)
    chatHistory = loadTableFromFile(CHAT_DB)
    gameList = loadTableFromFile(GAMELIST_DB)
    local updaterData = loadTableFromFile(UPDATER_DB)
    programVersions = updaterData.v or {}
    programCode = updaterData.c or {}
    gameCode = loadTableFromFile(GAMES_CODE_DB)
    if fs.exists(MOTD_FILE) then local file = fs.open(MOTD_FILE, "r"); motd = file.readAll(); file.close() end
    logActivity("All Mainframe data loaded successfully.")
end

--==============================================================================
-- Mail & List Management Functions
--==============================================================================

local function saveItem(user, item, itemType)
    local dir = itemType .. "/" .. user
    if not fs.exists(dir) then fs.makeDir(dir) end
    local id = os.time() .. "-" .. math.random(100, 999)
    saveTableToFile(dir .. "/" .. id, item)
end

local function loadMail(user)
    local path = "mail/" .. user
    local userMail = {}
    if fs.exists(path) and fs.isDir(path) then
        for _, fileName in ipairs(fs.list(path)) do
            local mailPath = path .. "/" .. fileName
            local mailFile = fs.open(mailPath, "r")
            if mailFile then
                local data = mailFile.readAll(); mailFile.close()
                local success, item = pcall(textutils.unserialize, data)
                if success and item then item.id = fileName; table.insert(userMail, item)
                else logActivity("Could not read corrupted mail file: " .. mailPath, true) end
            end
        end
    end
    return userMail
end

local function deleteItem(user, id, itemType)
    local path = itemType .. "/" .. user .. "/" .. id
    if fs.exists(path) then fs.delete(path); return true end
    return false
end

--==============================================================================
-- Authentication Helper Functions
--==============================================================================

local function requestAuthCode(username, password, nickname, senderId, purpose)
    logActivity("Requesting auth code for '" .. username .. "' via HyperAuth API...")
    
    local request_reply, request_err = AuthClient.requestCode(AUTH_SERVER_PROTOCOL, {
        username   = username,
        password   = password, -- This is the hashed password
        vendorID   = "DrunkenOS_Mainframe",
        computerID = os.getComputerID(),
        extra      = { purpose = purpose or "unknown" },
    })

    if not request_reply then
        logActivity("HyperAuth requestCode error: " .. tostring(request_err), true)
        rednet.send(senderId, { success = false, reason = "Authentication service error." }, "SimpleMail")
        return nil
    end

    logActivity("HyperAuth API success. Request ID: " .. request_reply.request_id)
    
    pendingAuths[username] = {
        request_id = request_reply.request_id,
        password = password,
        nickname = nickname,
        senderId = senderId,
        timestamp = os.time()
    }
    
    return request_reply.request_id
end

--==============================================================================
-- Network Request Handlers
--==============================================================================

local mailHandlers = {}
function mailHandlers.get_version(senderId, message) rednet.send(senderId, { version = programVersions[message.program] or 0 }, "SimpleMail") end
function mailHandlers.get_update(senderId, message) rednet.send(senderId, { code = programCode[message.program] }, "SimpleMail") end

-- Handler for the client's auto-installer
function mailHandlers.get_library(senderId, message)
    local path = message.path
    logActivity("Client " .. senderId .. " requested library at path: " .. path)
    -- Security: Only allow requests for files in the 'lib' directory.
    if path and string.sub(path, 1, 4) == "lib/" and fs.exists(path) then
        local file = fs.open(path, "r")
        if file then
            local content = file.readAll()
            file.close()
            rednet.send(senderId, { code = content }, "SimpleMail")
            logActivity("Sent library '" .. path .. "' to client " .. senderId)
            return
        end
    end
    -- If file doesn't exist or is not allowed, send back nil.
    rednet.send(senderId, { code = nil }, "SimpleMail")
    logActivity("Could not find or access library '" .. (path or "nil") .. "' for client " .. senderId, true)
end

function mailHandlers.register(senderId, message)
    if users[message.user] then
        rednet.send(senderId, { success = false, reason = "Username taken." }, "SimpleMail")
        return
    end
    local requestId = requestAuthCode(message.user, crypto.hex(message.pass), message.nickname, senderId, "register")
    if requestId then
        rednet.send(senderId, { success = true, needs_auth = true }, "SimpleMail")
    end
end

function mailHandlers.login(senderId, message)
    local storedHash = users[message.user] and users[message.user].password
    if not storedHash or storedHash ~= crypto.hex(message.pass) then
        rednet.send(senderId, { success = false, reason = "Invalid username or password." }, "SimpleMail")
        return
    end

    if message.session_token and users[message.user].session_token == message.session_token then
        logActivity("User '" .. message.user .. "' logged in with session token.")
        rednet.send(senderId, {
            success = true,
            needs_auth = false,
            nickname = users[message.user].nickname,
            unreadCount = #loadMail(message.user),
            isAdmin = admins[message.user] or false
        }, "SimpleMail")
        return
    end

    local requestId = requestAuthCode(message.user, crypto.hex(message.pass), nil, senderId, "login")
    if requestId then
        rednet.send(senderId, { success = true, needs_auth = true }, "SimpleMail")
    end
end

function mailHandlers.submit_auth_token(senderId, message)
    local user, code = message.user, message.token
    logActivity("Received auth code from user '" .. user .. "'")

    local authData = pendingAuths[user]
    if not authData then
        rednet.send(senderId, { success = false, reason = "No pending authentication for this user." }, "SimpleMail")
        return
    end

    logActivity("Verifying code with HyperAuth server for request ID: " .. authData.request_id)
    local verify_reply, verify_err = AuthClient.verifyCode(AUTH_SERVER_PROTOCOL, {
        request_id = authData.request_id,
        code       = code,
    })

    if not verify_reply then
        logActivity("HyperAuth verifyCode error: " .. tostring(verify_err), true)
        rednet.send(senderId, { success = false, reason = "Authentication service error." }, "SimpleMail")
        return
    end

    if verify_reply.ok then
        local response_payload = {}
        local new_session_token = crypto.hex(os.time() .. math.random())
        
        if not users[user] then -- This is a registration
            users[user] = { password = authData.password, nickname = authData.nickname, session_token = new_session_token }
            if saveTableToFile(USERS_DB, users) then
                response_payload = { success = true, unreadCount = 0, nickname = authData.nickname, session_token = new_session_token, isAdmin = admins[user] or false }
                logActivity("New user '" .. user .. "' successfully verified and registered.")
            else
                response_payload = { success = false, reason = "Server database error." }
            end
        else -- This is a login
            users[user].session_token = new_session_token
            saveTableToFile(USERS_DB, users)
            response_payload = { success = true, unreadCount = #loadMail(user), nickname = users[user].nickname, session_token = new_session_token, isAdmin = admins[user] or false }
            logActivity("User '" .. user .. "' successfully verified and logged in.")
        end
        rednet.send(senderId, response_payload, "SimpleMail")
        pendingAuths[user] = nil
    else
        rednet.send(senderId, { success = false, reason = verify_reply.reason or "Invalid authentication code." }, "SimpleMail")
        logActivity("Auth failed for "..user..": " .. (verify_reply.reason or "Unknown reason"), true)
    end
end

function mailHandlers.set_nickname(senderId, message)
    local user, new_nickname = message.user, message.new_nickname
    if users[user] and new_nickname and new_nickname ~= "" then
        users[user].nickname = new_nickname
        if saveTableToFile(USERS_DB, users) then
            rednet.send(senderId, { success = true, new_nickname = new_nickname }, "SimpleMail")
            logActivity("User '" .. user .. "' changed nickname to '" .. new_nickname .. "'.")
        else
            rednet.send(senderId, { success = false, reason = "Database error." }, "SimpleMail")
        end
    else
        rednet.send(senderId, { success = false, reason = "Invalid request." }, "SimpleMail")
    end
end

function mailHandlers.user_exists(senderId, message)
    local recipient = message.user; local exists = false
    if recipient and recipient ~= "" then
        if recipient == "@all" then exists = true
        elseif string.sub(recipient, 1, 1) == "@" then exists = lists[string.sub(recipient, 2)] ~= nil
        else exists = users[recipient] ~= nil end
    end
    rednet.send(senderId, { exists = exists }, "SimpleMail")
end

function mailHandlers.send(senderId, message)
    local mail = message.mail
    if mail.to == "@all" then
        for user, _ in pairs(users) do saveItem(user, mail, "mail") end
        logActivity(string.format("Mail from '%s' sent to @all", mail.from_nickname))
    elseif string.sub(mail.to, 1, 1) == "@" then
        local listName = string.sub(mail.to, 2)
        if lists[listName] then
            for _, member in ipairs(lists[listName]) do saveItem(member, mail, "mail") end
            logActivity(string.format("Mail from '%s' sent to list '%s'", mail.from_nickname, listName))
        end
    else
        saveItem(mail.to, mail, "mail")
        logActivity(string.format("Mail sent from '%s' to '%s'", mail.from_nickname, mail.to))
    end
    rednet.send(senderId, { status = "Mail sent successfully!" }, "SimpleMail")
end
function mailHandlers.fetch(senderId, message) rednet.send(senderId, { mail = loadMail(message.user) }, "SimpleMail") end
function mailHandlers.delete(senderId, message) if deleteItem(message.user, message.id, "mail") then logActivity(string.format("User '%s' deleted mail item '%s'", message.user, message.id)) end end
function mailHandlers.create_list(senderId, message)
    if lists[message.name] then rednet.send(senderId, { success = false, status = "A list with that name already exists." }, "SimpleMail")
    else
        lists[message.name] = { message.creator }
        if saveTableToFile(LISTS_DB, lists) then
            rednet.send(senderId, { success = true, status = "List '"..message.name.."' created." }, "SimpleMail")
            logActivity(string.format("User '%s' created list '%s'", message.creator, message.name))
        end
    end
end
function mailHandlers.join_list(senderId, message)
    if not lists[message.name] then rednet.send(senderId, { success = false, status = "That list does not exist." }, "SimpleMail"); return end
    for _, member in ipairs(lists[message.name]) do if member == message.user then rednet.send(senderId, { success = false, status = "You are already a member of that list." }, "SimpleMail"); return end end
    table.insert(lists[message.name], message.user)
    if saveTableToFile(LISTS_DB, lists) then
        rednet.send(senderId, { success = true, status = "Successfully joined list '"..message.name.."'." }, "SimpleMail")
        logActivity(string.format("User '%s' joined list '%s'", message.user, message.name))
    end
end
function mailHandlers.get_lists(senderId, message) rednet.send(senderId, { lists = lists }, "SimpleMail") end
function mailHandlers.get_motd(senderId, message) rednet.send(senderId, { motd = motd }, "SimpleMail") end
function mailHandlers.get_chat_history(senderId, message) rednet.send(senderId, { history = chatHistory }, "SimpleMail") end
function mailHandlers.get_unread_count(senderId, message) rednet.send(senderId, { type = "unread_count_response", count = #loadMail(message.user) }, "SimpleMail") end
function mailHandlers.get_gamelist(senderId, message) rednet.send(senderId, { type = "gamelist_response", games = gameList }, "SimpleMail") end
function mailHandlers.get_all_game_versions(senderId, message)
    local versions = {}
    for filename, data in pairs(gameCode) do
        versions[filename] = data.version
    end
    rednet.send(senderId, { type = "game_versions_response", versions = versions }, "SimpleMail")
end
function mailHandlers.get_game_update(senderId, message)
    local filename = message.filename
    if gameCode[filename] then
        rednet.send(senderId, { type = "game_update_response", filename = filename, code = gameCode[filename].code }, "SimpleMail")
    end
end

local gameHandlers = {}
function gameHandlers.submit_score(senderId, message)
    local game, user, score = message.game, message.user, message.score
    if not games[game] then games[game] = {} end
    if not games[game][user] or score > games[game][user] then
        games[game][user] = score
        if saveTableToFile(GAMES_DB, games) then
            logActivity(string.format("New high score for '%s' in '%s': %d", user, game, score))
        end
    end
end
function gameHandlers.get_leaderboard(senderId, message)
    local game = message.game
    local leaderboard = (games[game]) or {}
    rednet.send(senderId, { leaderboard = leaderboard }, "ArcadeGames")
end

--==============================================================================
-- Admin Command Handlers & Main Loops
--==============================================================================

local adminCommands = {}
function adminCommands.help()
    print("--- Mainframe Admin Commands ---")
    print("users, deluser, lists, dellist, board, delscore")
    print("motd, broadcast, publish, publishlib, addgame, delgame, games, publishgame")
end
function adminCommands.users() logActivity("Registered Users:"); for user, data in pairs(users) do logActivity("- " .. user .. " (Nick: " .. (data.nickname or "N/A") .. ")") end end
function adminCommands.deluser(args) local user = args[2]; if not user then logActivity("Usage: deluser <name>"); return end; if users[user] then users[user] = nil; saveTableToFile(USERS_DB, users); logActivity("Deleted user: " .. user) else logActivity("User not found: " .. user) end end
function adminCommands.lists() logActivity("Mailing Lists:"); for name, members in pairs(lists) do logActivity(string.format("- %s (%d members)", name, #members)) end end
function adminCommands.dellist(args) local listName = args[2]; if not listName then logActivity("Usage: dellist <name>"); return end; if lists[listName] then lists[listName] = nil; saveTableToFile(LISTS_DB, lists); logActivity("Deleted list: " .. listName) else logActivity("List not found: " .. listName) end end
function adminCommands.board(args)
    local gameName = args[2]; if not gameName then logActivity("Usage: board <game_name>"); return end
    if games[gameName] then
        logActivity("Leaderboard for " .. gameName .. ":")
        for user, score in pairs(games[gameName]) do logActivity(string.format("- %s: %d", user, score)) end
    else logActivity("No leaderboard found for game: " .. gameName) end
end
function adminCommands.delscore(args)
    local gameName, user = args[2], args[3]; if not gameName or not user then logActivity("Usage: delscore <game_name> <user_name>"); return end
    if games[gameName] and games[gameName][user] then
        games[gameName][user] = nil; saveTableToFile(GAMES_DB, games)
        logActivity(string.format("Deleted score for '%s' in '%s'", user, gameName))
    else logActivity(string.format("No score for user '%s' in game '%s'", user, gameName)) end
end
function adminCommands.motd(args) table.remove(args, 1); motd = table.concat(args, " "); local file = fs.open(MOTD_FILE, "w"); if file then file.write(motd); file.close() end; logActivity("New MOTD set.") end
function adminCommands.broadcast(args) table.remove(args, 1); local text = table.concat(args, " "); rednet.broadcast({ type = "broadcast", text = text }, "SimpleMail"); logActivity("Broadcast sent: " .. text) end
function adminCommands.publish(args)
    local progName, newVersionStr = args[2], args[3]; if not progName or not newVersionStr then logActivity("Usage: publish <prog> <ver>"); return end
    local newVersion = tonumber(newVersionStr); if not newVersion then logActivity("Error: Version must be a number."); return end
    logActivity("Waiting for publication of '"..progName.."' v"..newVersion.."..."); local _, message = rednet.receive("Publication", 15)
    if message and message.code then programCode[progName] = message.code; programVersions[progName] = newVersion; saveTableToFile(UPDATER_DB, {v=programVersions, c=programCode}); logActivity("Published "..progName.." version "..programVersions[progName])
    else logActivity("Publication timed out or failed.") end
end
-- Admin command to upload a library file.
function adminCommands.publishlib(args)
    local libPath = args[2]
    if not libPath or string.sub(libPath, 1, 4) ~= "lib/" then
        logActivity("Usage: publishlib lib/<name>.lua", true)
        return
    end
    logActivity("Waiting for publication of library '" .. libPath .. "'...");
    local _, message = rednet.receive("Publication", 15)
    if message and message.code then
        local dir = fs.getDir(libPath)
        if not fs.exists(dir) then fs.makeDir(dir) end
        local file = fs.open(libPath, "w")
        if file then
            file.write(message.code)
            file.close()
            logActivity("Published library " .. libPath)
        else
            logActivity("Could not open file '"..libPath.."' for writing.", true)
        end
    else
        logActivity("Publication timed out or failed.")
    end
end
function adminCommands.addgame(args)
    local name, file = args[2], args[3]; if not name or not file then logActivity("Usage: addgame <DisplayName> <filename>"); return end
    table.insert(gameList, {name = name, file = file}); saveTableToFile(GAMELIST_DB, gameList)
    logActivity("Added game '"..name.."' to the list.")
end
function adminCommands.delgame(args)
    local name = args[2]; if not name then logActivity("Usage: delgame <DisplayName>"); return end
    for i, game in ipairs(gameList) do
        if game.name == name then
            table.remove(gameList, i); saveTableToFile(GAMELIST_DB, gameList)
            logActivity("Removed game '"..name.."' from the list."); return
        end
    end
    logActivity("Game '"..name.."' not found in the list.")
end
function adminCommands.games()
    logActivity("Available Games:")
    for _, game in ipairs(gameList) do logActivity("- "..game.name.." (file: "..game.file..")") end
end
function adminCommands.publishgame(args)
    local filename = args[2]
    if not filename then logActivity("Usage: publishgame <filename>", true); return end
    if not fs.exists(filename) then logActivity("Error: File '"..filename.."' not found.", true); return end
    
    local file = fs.open(filename, "r")
    if not file then logActivity("Error: Could not open file.", true); return end
    local content = file.readAll()
    file.close()

    local version = string.match(content, "%-%-%s*Version:%s*([%d%.]+)")
    if not version then
        logActivity("Error: Game file must contain a version comment, e.g. '-- Version: 1.0'", true)
        return
    end
    
    gameCode[filename] = { code = content, version = tonumber(version) }
    if saveTableToFile(GAMES_CODE_DB, gameCode) then
        logActivity("Published game '"..filename.."' version " .. version)
    else
        logActivity("Error: Failed to save game code to database.", true)
    end
end

local function executeAdminCommand(command)
    local output = {}
    local oldPrint = print
    _G.print = function(...)
        local args = {...}
        local line = ""
        for i = 1, #args do
            line = line .. tostring(args[i]) .. "\t"
        end
        table.insert(output, line)
    end

    local args = {}; for arg in string.gmatch(command, "[^%s]+") do table.insert(args, arg) end
    local cmd = args[1]
    if adminCommands[cmd] then
        adminCommands[cmd](args)
    else
        print("Unknown command. Type 'help'.")
    end

    _G.print = oldPrint
    return table.concat(output, "\n")
end

local function networkListener()
    while true do
        local senderId, message, protocol = rednet.receive()
        if protocol == "SimpleMail" and message and message.type and mailHandlers[message.type] then
            mailHandlers[message.type](senderId, message)
        
        elseif protocol == "SimpleChat" and message and message.from then
            local nickname = (users[message.from] and users[message.from].nickname) or message.from
            local entry = string.format("[%s]: %s", nickname, message.text)
            table.insert(chatHistory, entry)
            if #chatHistory > 100 then table.remove(chatHistory, 1) end
            saveTableToFile(CHAT_DB, chatHistory)
            rednet.broadcast({ from = nickname, text = message.text }, "SimpleChat")
        
        elseif protocol == "ArcadeGames" and message and message.type and gameHandlers[message.type] then
            gameHandlers[message.type](senderId, message)
        
        elseif protocol == AUTH_INTERLINK_PROTOCOL and message.type == "user_exists_check" then
            local user = message.user
            rednet.send(senderId, { user = user, exists = (users[user] ~= nil) }, AUTH_INTERLINK_PROTOCOL)
        
        elseif protocol == ADMIN_PROTOCOL and message.type == "execute_command" then
            if message.user and admins[message.user] then
                logActivity("Executing remote command from admin: " .. message.user)
                local output = executeAdminCommand(message.command)
                rednet.send(senderId, { output = output }, ADMIN_PROTOCOL)
            else
                logActivity("Unauthorized admin command attempt from user: " .. (message.user or "unknown"), true)
                rednet.send(senderId, { output = "Error: Access denied." }, ADMIN_PROTOCOL)
            end
        end
    end
end

local function adminTerminal()
    while true do
        local event, p1 = os.pullEvent()
        if event == "key" then
            if p1 == keys.enter then
                if adminInput ~= "" then 
                    logActivity("Executing local command: " .. adminInput)
                    local output = executeAdminCommand(adminInput)
                    for line in output:gmatch("[^\n]+") do
                        logActivity(line)
                    end
                    adminInput = "" 
                end
            elseif p1 == keys.backspace then adminInput = string.sub(adminInput, 1, -2) end
        elseif event == "char" then adminInput = adminInput .. p1 end
        redrawAdminUI()
    end
end

local function main()
    loadAllData()
    -- Open all attached modems to listen on both wired and wireless networks
    for _, side in ipairs(rs.getSides()) do
        if peripheral.getType(side) == "modem" then
            rednet.open(side)
        end
    end

    rednet.host("SimpleMail", "mail.server")
    rednet.host("SimpleChat", "chat.server")
    rednet.host("ArcadeGames", "arcade.server")
    rednet.host(ADMIN_PROTOCOL, "admin.server") -- Host the new admin protocol
    logActivity("Mainframe Server started. Type 'help' for commands.")
    parallel.waitForAny(networkListener, adminTerminal)
end

main()

