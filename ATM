--[[
    Drunken Beard Bank - ATM Terminal (v4.3 - Refactored Crypto)
    by Gemini Gem

    Purpose:
    This version refactors the cryptographic functions into the new, separate
    `lib/sha1_hmac.lua` library. This is the final step in modularizing the
    entire OS.

    Key Changes:
    - Removed the embedded SHA1 library block.
    - Added a `require()` call to the new `lib/sha1_hmac` library.
    - Updated password hashing calls to use the new crypto library.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

-- It is assumed the `sha1_hmac` library is available, as the user would
-- typically install it with the main Drunken_OS_Client first.
local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local balance = 0
local currencyRates = {}

-- Rednet protocols
local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- UI & Theme
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then return colors[colorName] end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    title = safeColor("lightBlue", colors.lightBlue),
    prompt = safeColor("cyan", colors.cyan),
    highlightBg = safeColor("blue", colors.blue),
    highlightText = safeColor("white", colors.white),
    error = safeColor("red", colors.red),
}

local function getSafeSize() local w, h = term.getSize(); while not w or not h do sleep(0.05); w, h = term.getSize() end; return w, h end
local function wordWrap(text, width)
    local finalLines = {}
    for line in string.gmatch(text, "[^\n]+") do
        if #line <= width then
            table.insert(finalLines, line)
        else
            local currentWrappedLine = ""
            for word in string.gmatch(line, "[^%s]+") do
                if #currentWrappedLine + #word + 1 > width then
                    table.insert(finalLines, currentWrappedLine)
                    currentWrappedLine = word
                else
                    currentWrappedLine = currentWrappedLine == "" and word or (currentWrappedLine .. " " .. word)
                end
            end
            table.insert(finalLines, currentWrappedLine)
        end
    end
    return finalLines
end
local function clear() term.setBackgroundColor(theme.bg); term.clear(); term.setCursorPos(1, 1) end
local function drawWindow(title)
    clear()
    local w, h = getSafeSize()
    term.setBackgroundColor(theme.windowBg); for y = 1, h do term.setCursorPos(1, y); term.write(string.rep(" ", w)) end
    term.setBackgroundColor(theme.title); term.setCursorPos(1, 1); term.write(string.rep(" ", w)); term.setTextColor(colors.white)
    local titleText = " " .. title .. " "; term.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1); term.write(titleText)
    term.setBackgroundColor(theme.windowBg); term.setTextColor(theme.text)
end
local function drawMenu(options, selectedIndex, startX, startY)
    for i, option in ipairs(options) do
        term.setCursorPos(startX, startY + i - 1)
        if i == selectedIndex then
            term.setBackgroundColor(theme.highlightBg); term.setTextColor(theme.highlightText)
            term.write("> " .. option)
        else
            term.setBackgroundColor(theme.windowBg); term.setTextColor(theme.text)
            term.write("  " .. option)
        end
    end
    term.setBackgroundColor(theme.windowBg)
end
local function showMessage(title, message, isError)
    drawWindow(title)
    local w, h = getSafeSize()
    if isError then term.setTextColor(theme.error) else term.setTextColor(theme.text) end
    local lines = wordWrap(message, w - 4)
    for i, line in ipairs(lines) do term.setCursorPos(3, 4 + i - 1); term.write(line) end
    term.setCursorPos(3, 4 + #lines + 1); term.setTextColor(theme.prompt); term.write("Press any key to continue..."); os.pullEvent("key"); term.setTextColor(theme.text)
end
local function readInput(prompt, y, hideText)
    local x = 2; term.setTextColor(theme.prompt); term.setCursorPos(x, y); term.write(prompt); term.setTextColor(theme.text)
    term.setCursorPos(x + #prompt, y); term.setCursorBlink(true)
    local input = hideText and read("*") or read()
    term.setCursorBlink(false); return input
end

--==============================================================================
-- Banking Functions
--==============================================================================

local function login()
    clear()
    term.setCursorPos(1,1)
    print("Please enter your Drunken OS password.")
    write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)

    if not pass or pass == "" then return false end

    local pass_hash = crypto.hex(pass)

    if pass_hash == card_data.pass_hash then
        print("Password verified. Contacting bank server...")
        
        -- THE ONLY CHANGE IS HERE: We now include the verified pass_hash.
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = pass_hash }, BANK_PROTOCOL)
        
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            print("Login successful!")
            sleep(1)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.")
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.")
        return false
    end
end

local function deposit()
    drawWindow("Deposit")
    term.setCursorPos(2, 4); term.write("Please place all items for deposit into the barrel.")
    term.setCursorPos(2, 5); term.write("Press ENTER when ready.")
    os.pullEvent("key")

    drawWindow("Processing..."); term.setCursorPos(2, 4); term.write("Contacting vault clerk...")
    rednet.send(turtleClerkId, { type = "request_deposit" }, TURTLE_CLERK_PROTOCOL)
    
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 10)
    if not response or not response.items then
        showMessage("Error", "No response from vault clerk.", true)
        return
    end

    local depositItems = response.items
    if #depositItems > 0 then
        term.setCursorPos(2, 6); term.write("Clerk found items. Confirming with bank...")
        rednet.send(bankServerId, { type = "deposit", user = username, items = depositItems }, BANK_PROTOCOL)
        local _, server_response = rednet.receive(BANK_PROTOCOL, 5)

        if server_response and server_response.success then
            balance = server_response.newBalance
            rednet.send(turtleClerkId, { type = "confirm_deposit" }, TURTLE_CLERK_PROTOCOL)
            showMessage("Success", "Deposited items for a total of $" .. server_response.deposited_value)
        else
            rednet.send(turtleClerkId, { type = "cancel_deposit" }, TURTLE_CLERK_PROTOCOL)
            showMessage("Error", "Deposit failed on server. Items returned.", true)
        end
    else
        rednet.send(turtleClerkId, { type = "cancel_deposit" }, TURTLE_CLERK_PROTOCOL)
        showMessage("Deposit Cancelled", "No valid currency found in the deposit barrel.")
    end
end

local function withdraw()
    local availableCurrencies = {}
    for name, data in pairs(currencyRates) do
        table.insert(availableCurrencies, { name = name, rate = data.current })
    end
    table.sort(availableCurrencies, function(a, b) return a.name < b.name end)
    
    if #availableCurrencies == 0 then
        showMessage("Withdrawal", "There are no currencies available for withdrawal.")
        return
    end

    local selected = 1
    while true do
        drawWindow("Select Currency to Withdraw")
        term.setCursorPos(2, 4); term.write("Your balance: $" .. balance)
        local menuOptions = {}
        for _, c in ipairs(availableCurrencies) do
            table.insert(menuOptions, string.format("%s ($%d)", c.name, c.rate))
        end
        table.insert(menuOptions, "Cancel")
        drawMenu(menuOptions, selected, 2, 6)

        local event, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #menuOptions or selected - 1
        elseif key == keys.down then selected = (selected == #menuOptions) and 1 or selected + 1
        elseif key == keys.q or key == keys.tab then break
        elseif key == keys.enter then
            if selected > #availableCurrencies then break end -- Cancel selected

            local chosenCurrency = availableCurrencies[selected]
            local amountStr = readInput("How many " .. chosenCurrency.name .. " to withdraw?: ", 6 + #menuOptions)
            local amount = tonumber(amountStr)
            if not amount or amount <= 0 then
                showMessage("Error", "Invalid amount.", true)
            else
                drawWindow("Processing..."); term.setCursorPos(2, 4); term.write("Contacting bank...")
                rednet.send(bankServerId, {
                    type = "withdraw_item",
                    user = username,
                    item_name = chosenCurrency.name,
                    count = amount
                }, BANK_PROTOCOL)
                local _, response = rednet.receive(BANK_PROTOCOL, 10)

                if response and response.success then
                    balance = response.newBalance
                    term.setCursorPos(2, 6); term.write("Transaction approved. Requesting dispense...")
                    rednet.send(turtleClerkId, { type = "request_dispense", item_name = chosenCurrency.name, count = amount }, TURTLE_CLERK_PROTOCOL)
                    
                    local _, turtle_response = rednet.receive(TURTLE_CLERK_PROTOCOL, 15)
                    if turtle_response and turtle_response.success then
                        showMessage("Success", "Withdrew " .. amount .. " " .. chosenCurrency.name .. ". Please collect items.")
                    else
                        showMessage("Error", turtle_response and turtle_response.reason or "Dispense failed.", true)
                    end
                else
                    showMessage("Error", response and response.reason or "Withdrawal failed.", true)
                end
            end
            break -- Return to main menu after transaction attempt
        end
    end
end

--==============================================================================
-- Main Program Logic
--==============================================================================

local function runSession()
    local drive = peripheral.find("drive")
    if not drive then
        showMessage("ATM Error", "No disk drive attached.", true)
        return
    end

    rednet.open("back")
    drawWindow("Connecting..."); term.setCursorPos(2, 4); term.write("Finding Bank Server...")
    bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
    if not bankServerId then
        showMessage("Error", "Could not connect to the bank server.", true)
        rednet.close("back"); return
    end
    
    term.setCursorPos(2, 5); term.write("Finding Vault Clerk...")
    turtleClerkId = rednet.lookup(TURTLE_CLERK_PROTOCOL)
    if not turtleClerkId then
        showMessage("Error", "Could not connect to the vault clerk.", true)
        rednet.close("back"); return
    end

    drawWindow("Drunken Beard Bank")
    term.setCursorPos(2, 4); term.write("Please insert your bank card...")
    
    local user_from_card = nil
    while not user_from_card do
        local event, side = os.pullEvent("disk")
        
        if drive.isDiskPresent() then
            local mount_path = drive.getMountPath()
            if mount_path and fs.exists(mount_path .. "/.bankcard") then
                local file = fs.open(mount_path .. "/.bankcard", "r")
                if file then
                    user_from_card = file.readAll()
                    file.close()
                end
            end
        end
    end
    
    if not login(user_from_card) then
        drive.ejectDisk()
        showMessage("Login Failed", "Please take your card.", true)
        rednet.close("back"); return
    end

    -- Fetch latest rates after successful login
    rednet.send(bankServerId, { type = "get_balance_and_rates", user = username }, BANK_PROTOCOL)
    local _, response = rednet.receive(BANK_PROTOCOL, 5)
    if response then
        balance = response.balance or balance
        currencyRates = response.rates or {}
    end

    local options = {"View Balance & Rates", "Deposit", "Withdraw", "Exit"}
    local selected = 1
    while true do
        drawWindow("Drunken Beard Bank")
        term.setCursorPos(2, 4); term.write("Welcome, " .. username)
        term.setCursorPos(2, 5); term.write("Current Balance: $" .. balance)
        drawMenu(options, selected, 2, 8)
        
        local event, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then
            if selected == 1 then
                rednet.send(bankServerId, { type = "get_balance_and_rates", user = username }, BANK_PROTOCOL)
                local _, rate_response = rednet.receive(BANK_PROTOCOL, 5)
                if rate_response and rate_response.balance then
                    balance = rate_response.balance
                    currencyRates = rate_response.rates
                    drawWindow("Balance & Rates")
                    term.setCursorPos(2, 4); term.write("Current Balance: $" .. balance)
                    term.setCursorPos(2, 6); term.write("--- Live Exchange Rates ---")
                    local y = 7
                    for item, data in pairs(currencyRates) do
                        local name = item:gsub("minecraft:", ""):gsub("_", " ")
                        term.setCursorPos(2, y); term.write(string.format("1 %s = $%d", name, data.current))
                        y = y + 1
                    end
                    term.setCursorPos(2, y+1); term.write("Press any key to return...")
                    os.pullEvent("key")
                end
            elseif selected == 2 then deposit()
            elseif selected == 3 then withdraw()
            elseif selected == 4 then break end
        elseif key == keys.tab or key == keys.q then break end
    end

    drive.ejectDisk()
    rednet.close("back")
    clear(); print("Thank you for banking with Drunken Beard Bank!")
    sleep(2) -- Pause before the program reboots
end

--==============================================================================
-- Main Program Loop
--==============================================================================

while true do
    local ok, err = pcall(runSession)
    if not ok then
        -- If an error occurred, log it and reboot
        local file = fs.open("atm_crash.log", "a")
        if file then
            file.writeLine(os.date() .. " - FATAL ERROR: " .. tostring(err))
            file.close()
        end
        
        clear()
        term.setTextColor(colors.red)
        print("A fatal error occurred. The ATM will now reboot.")
        print(err)
        sleep(5)
        os.reboot()
    end
    -- If the session ended normally (user exited), the loop will just restart
end
