--[[
    Drunken Beard Bank - ATM Terminal (v4.6 - Scope and Data Fix)
    by Gemini Gem & MuhendizBey

    Purpose:
    This version fixes a critical runtime error caused by a variable scope
    issue, where the login function could not access the data read from
    the bank card.

    Key Changes:
    - The `login` function now accepts a `card_data` table as a parameter.
    - The `runSession` function now passes the locally read `card_data`
      directly to the `login` function.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local balance = 0
local currencyRates = {}

local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- UI & Theme
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then return colors[colorName] end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    title = safeColor("lightBlue", colors.lightBlue),
    prompt = safeColor("cyan", colors.cyan),
    highlightBg = safeColor("blue", colors.blue),
    highlightText = safeColor("white", colors.white),
    error = safeColor("red", colors.red),
}

local function getSafeSize() local w, h = term.getSize(); while not w or not h do sleep(0.05); w, h = term.getSize() end; return w, h end
local function wordWrap(text, width)
    local finalLines = {}
    for line in string.gmatch(text, "[^\n]+") do
        if #line <= width then
            table.insert(finalLines, line)
        else
            local currentWrappedLine = ""
            for word in string.gmatch(line, "[^%s]+") do
                if #currentWrappedLine + #word + 1 > width then
                    table.insert(finalLines, currentWrappedLine)
                    currentWrappedLine = word
                else
                    currentWrappedLine = currentWrappedLine == "" and word or (currentWrappedLine .. " " .. word)
                end
            end
            table.insert(finalLines, currentWrappedLine)
        end
    end
    return finalLines
end
local function clear() term.setBackgroundColor(theme.bg); term.clear(); term.setCursorPos(1, 1) end
local function drawWindow(title)
    clear()
    local w, h = getSafeSize()
    term.setBackgroundColor(theme.windowBg); for y = 1, h do term.setCursorPos(1, y); term.write(string.rep(" ", w)) end
    term.setBackgroundColor(theme.title); term.setCursorPos(1, 1); term.write(string.rep(" ", w)); term.setTextColor(colors.white)
    local titleText = " " .. title .. " "; term.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1); term.write(titleText)
    term.setBackgroundColor(theme.windowBg); term.setTextColor(theme.text)
end
local function drawMenu(options, selectedIndex, startX, startY)
    for i, option in ipairs(options) do
        term.setCursorPos(startX, startY + i - 1)
        if i == selectedIndex then
            term.setBackgroundColor(theme.highlightBg); term.setTextColor(theme.highlightText)
            term.write("> " .. option)
        else
            term.setBackgroundColor(theme.windowBg); term.setTextColor(theme.text)
            term.write("  " .. option)
        end
    end
    term.setBackgroundColor(theme.windowBg)
end
local function showMessage(title, message, isError)
    drawWindow(title)
    local w, h = getSafeSize()
    if isError then term.setTextColor(theme.error) else term.setTextColor(theme.text) end
    local lines = wordWrap(message, w - 4)
    for i, line in ipairs(lines) do term.setCursorPos(3, 4 + i - 1); term.write(line) end
    term.setCursorPos(3, 4 + #lines + 1); term.setTextColor(theme.prompt); term.write("Press any key to continue..."); os.pullEvent("key"); term.setTextColor(theme.text)
end
local function readInput(prompt, y, hideText)
    local x = 2; term.setTextColor(theme.prompt); term.setCursorPos(x, y); term.write(prompt); term.setTextColor(theme.text)
    term.setCursorPos(x + #prompt, y); term.setCursorBlink(true)
    local input = hideText and read("*") or read()
    term.setCursorBlink(false); return input
end

--==============================================================================
-- Banking Functions
--==============================================================================

local function login(card_data) -- THE FIX: Function now accepts card_data
    term.clear(); term.setCursorPos(1,1)
    print("Please enter your Drunken OS password.")
    write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)

    if not pass or pass == "" then return false end

    local pass_hash = crypto.hex(pass)

    if pass_hash == card_data.pass_hash then -- THE FIX: Now correctly accesses the passed-in table
        print("Password verified locally. Contacting bank server...")
        
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = pass_hash }, BANK_PROTOCOL)
        
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            print("Login successful!")
            sleep(1)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.")
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.")
        return false
    end
end

local function deposit()
    drawWindow("Deposit")
    term.setCursorPos(2, 4); term.write("Please place all items for deposit into the barrel.")
    term.setCursorPos(2, 5); term.write("Press ENTER when ready.")
    os.pullEvent("key")

    drawWindow("Processing..."); term.setCursorPos(2, 4); term.write("Contacting vault clerk...")
    rednet.send(turtleClerkId, { type = "request_deposit" }, TURTLE_CLERK_PROTOCOL)
    
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 10)
    if not response or not response.items then
        showMessage("Error", "No response from vault clerk.", true)
        return
    end

    local depositItems = response.items
    if #depositItems > 0 then
        term.setCursorPos(2, 6); term.write("Clerk found items. Confirming with bank...")
        rednet.send(bankServerId, { type = "deposit", user = username, items = depositItems }, BANK_PROTOCOL)
        local _, server_response = rednet.receive(BANK_PROTOCOL, 5)

        if server_response and server_response.success then
            balance = server_response.newBalance
            rednet.send(turtleClerkId, { type = "confirm_deposit" }, TURTLE_CLERK_PROTOCOL)
            showMessage("Success", "Deposited items for a total of $" .. server_response.deposited_value)
        else
            rednet.send(turtleClerkId, { type = "cancel_deposit" }, TURTLE_CLERK_PROTOCOL)
            showMessage("Error", "Deposit failed on server. Items returned.", true)
        end
    else
        rednet.send(turtleClerkId, { type = "cancel_deposit" }, TURTLE_CLERK_PROTOCOL)
        showMessage("Deposit Cancelled", "No valid currency found in the deposit barrel.")
    end
end

local function withdraw()
    local availableCurrencies = {}
    for name, data in pairs(currencyRates) do
        table.insert(availableCurrencies, { name = name, rate = data.current })
    end
    table.sort(availableCurrencies, function(a, b) return a.name < b.name end)
    
    if #availableCurrencies == 0 then
        showMessage("Withdrawal", "There are no currencies available for withdrawal.")
        return
    end

    local selected = 1
    while true do
        drawWindow("Select Currency to Withdraw")
        term.setCursorPos(2, 4); term.write("Your balance: $" .. balance)
        local menuOptions = {}
        for _, c in ipairs(availableCurrencies) do
            table.insert(menuOptions, string.format("%s ($%d)", c.name, c.rate))
        end
        table.insert(menuOptions, "Cancel")
        drawMenu(menuOptions, selected, 2, 6)

        local event, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #menuOptions or selected - 1
        elseif key == keys.down then selected = (selected == #menuOptions) and 1 or selected + 1
        elseif key == keys.q or key == keys.tab then break
        elseif key == keys.enter then
            if selected > #availableCurrencies then break end -- Cancel selected

            local chosenCurrency = availableCurrencies[selected]
            local amountStr = readInput("How many " .. chosenCurrency.name .. " to withdraw?: ", 6 + #menuOptions)
            local amount = tonumber(amountStr)
            if not amount or amount <= 0 then
                showMessage("Error", "Invalid amount.", true)
            else
                drawWindow("Processing..."); term.setCursorPos(2, 4); term.write("Contacting bank...")
                rednet.send(bankServerId, {
                    type = "withdraw_item",
                    user = username,
                    item_name = chosenCurrency.name,
                    count = amount
                }, BANK_PROTOCOL)
                local _, response = rednet.receive(BANK_PROTOCOL, 10)

                if response and response.success then
                    balance = response.newBalance
                    term.setCursorPos(2, 6); term.write("Transaction approved. Requesting dispense...")
                    rednet.send(turtleClerkId, { type = "request_dispense", item_name = chosenCurrency.name, count = amount }, TURTLE_CLERK_PROTOCOL)
                    
                    local _, turtle_response = rednet.receive(TURTLE_CLERK_PROTOCOL, 15)
                    if turtle_response and turtle_response.success then
                        showMessage("Success", "Withdrew " .. amount .. " " .. chosenCurrency.name .. ". Please collect items.")
                    else
                        showMessage("Error", turtle_response and turtle_response.reason or "Dispense failed.", true)
                    end
                else
                    showMessage("Error", response and response.reason or "Withdrawal failed.", true)
                end
            end
            break -- Return to main menu after transaction attempt
        end
    end
end

--==============================================================================
-- Main Program Logic
--==============================================================================

local function runSession()
    term.clear(); term.setCursorPos(1,1)
    print("Drunken Beard Bank")
    print("Please insert your bank card...")

    local drive = peripheral.find("drive")
    if not drive then
        showMessage("ATM Error", "No Disk Drive is attached to this terminal.")
        return
    end
    
    local event, side = os.pullEvent("disk")
    if peripheral.getName(drive) ~= side then return end -- Not our drive

    local disk_label = disk.getLabel(side)
    if not disk_label or not disk_label:match("^DrunkenBeard_Card_.+") then
        showMessage("Card Error", "This is not a valid Drunken Beard Bank card.")
        disk.eject(side)
        return
    end
    
    username = disk_label:match("^DrunkenBeard_Card_(.+)")
    local handle = fs.open(disk.getMountPath(side) .. "/.card_data", "r")
    if not handle then
        showMessage("Card Error", "Card is missing its data file.")
        disk.eject(side)
        return
    end

    local card_contents = handle.readAll()
    handle.close()
    local ok, card_data_local = pcall(textutils.unserialize, card_contents)

    if not ok or not card_data_local then
        showMessage("Card Error", "Card data is corrupt.")
        disk.eject(side)
        return
    end

    local loggedIn = login(card_data_local) -- THE FIX: Pass the local card data to the login function

    if loggedIn then
        mainMenu()
    end

    disk.eject(side)
    print("\nCard ejected. Thank you!")
    sleep(2)
end

--==============================================================================
-- Main Program Loop
--==============================================================================

while true do
    local ok, err = pcall(function()
        local modem = peripheral.find("modem")
        if not modem then error("No modem attached.", 0) end
        rednet.open(peripheral.getName(modem))

        bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
        if not bankServerId then error("Could not find bank server.", 0) end
        
        runSession()
        rednet.close()
    end)
    
    if not ok then
        showMessage("Fatal Error", tostring(err))
        sleep(5)
    end
end
