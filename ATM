--[[
    Drunken Beard Bank - ATM Terminal (v4.11 - Definitive Stable Fix)
    by Gemini Gem & MuhendizBey

    Purpose:
    This is the definitive, stable version of the ATM script, built upon the
    user-provided working baseline (v4.3). It incorporates the single necessary
    fix for the login handshake and the critical fix for the card data scope
    issue, while preserving all original, working logic and UI.

    Key Changes:
    - Fixed the scope issue by correctly assigning the read card data to the
      main 'card_data' variable in the `runSession` function.
    - The login function now correctly sends the password hash to the Bank Server.
    - All other logic, UI, and functionality is identical to the trusted v4.3.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local card_data = nil -- This will be populated by runSession
local balance = 0
local currencyRates = {}

local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- UI & Theme (Full Implementation from v4.3)
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(c) if hasColor then return c else return colors.white end end

local function clear() term.setBackgroundColor(colors.black); term.clear() end

local function showMessage(title, message)
    local w, h = term.getSize()
    local bg = hasColor and colors.red or colors.gray
    local text = hasColor and colors.white or colors.black
    
    term.setBackgroundColor(bg)
    term.setTextColor(text)
    term.clear()
    term.setCursorPos(1,1)
    
    local titleText = " " .. title .. " "
    term.setCursorPos(math.floor((w - #titleText) / 2), 2)
    print(titleText)

    local lines = {}
    for line in message:gmatch("[^\n]+") do
        while #line > w - 4 do
            table.insert(lines, line:sub(1, w - 4))
            line = line:sub(w - 3)
        end
        table.insert(lines, line)
    end

    for i, line in ipairs(lines) do
        term.setCursorPos(3, 4 + i)
        print(line)
    end

    term.setCursorPos(3, 5 + #lines)
    print("Press any key to continue...")
    os.pullEvent("key")
end

local function drawMenu(title, options, help)
    local w, h = term.getSize()
    local selected = 1
    while true do
        term.setBackgroundColor(colors.black)
        term.clear()
        term.setCursorPos(1,1)
        term.setTextColor(colors.yellow)
        print(title)
        term.setCursorPos(1,2)
        print(string.rep("-", #title))
        
        for i, opt in ipairs(options) do
            term.setCursorPos(3, 3 + i)
            if i == selected then
                term.setTextColor(colors.black)
                term.setBackgroundColor(colors.white)
            else
                term.setTextColor(colors.white)
                term.setBackgroundColor(colors.black)
            end
            term.write(opt)
        end

        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.gray)
        term.setCursorPos(1, h)
        term.write(help or "Use UP/DOWN and ENTER to select.")

        local event, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then return selected
        elseif key == keys.tab or key == keys.q then return nil
        end
    end
end

--==============================================================================
-- Core Application Logic (Full Implementation from v4.3, with fixes)
--==============================================================================

local function login()
    clear()
    term.setCursorPos(1,1)
    print("Please enter your Drunken OS password.")
    write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)

    if not pass or pass == "" then return false end

    local pass_hash = crypto.hex(pass)

    if pass_hash == card_data.pass_hash then
        print("Password verified. Contacting bank server...")
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = pass_hash }, BANK_PROTOCOL)
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            print("Login successful!")
            sleep(1)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.")
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.")
        return false
    end
end

local function deposit()
    clear()
    term.setCursorPos(1,1)
    print("Requesting deposit...")
    rednet.send(turtleClerkId, {type = "request_deposit"}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Deposit complete. Your new balance is $" .. balance)
    else
        showMessage("Deposit Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

local function withdraw()
    local options = {}
    local item_names = {}
    for name, data in pairs(currencyRates) do
        local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
        table.insert(options, string.format("%s ($%d)", clean_name, data.current))
        table.insert(item_names, name)
    end
    table.insert(options, "Cancel")
    
    local choice = drawMenu("Select Item to Withdraw", options, "Your balance: $" .. balance)
    if choice == nil or choice > #item_names then return end
    
    local item_name = item_names[choice]
    local rate = currencyRates[item_name].current

    clear()
    term.setCursorPos(1,1)
    print("How many " .. item_name:gsub("minecraft:", ""):gsub("_", " ") .. " would you like to withdraw?")
    write("> ")
    term.setCursorBlink(true)
    local amount_str = read()
    term.setCursorBlink(false)
    
    local amount = tonumber(amount_str)
    if not amount or amount <= 0 or (amount * rate > balance) then
        showMessage("Error", "Invalid amount or insufficient funds.")
        return
    end

    print("Requesting withdrawal of " .. amount .. " " .. item_name .. "...")
    rednet.send(turtleClerkId, {type = "request_dispense", item_name = item_name, count = amount}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Please collect your items. New balance: $" .. balance)
    else
        showMessage("Withdrawal Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

local function mainMenu()
    local drive = peripheral.find("drive")
    while true do
        local options = {
            "Check Balance / Rates",
            "Deposit Items",
            "Withdraw Items",
            "Exit"
        }
        local choice = drawMenu("ATM Main Menu", options, "Welcome, " .. username .. " | Balance: $" .. balance)

        if not choice or choice == 4 then break end
        
        if choice == 1 then
            clear(); term.setCursorPos(1,1); print("Current Exchange Rates:")
            local y = 3
            for name, data in pairs(currencyRates) do
                local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
                term.setCursorPos(2, y); print(string.format("1 %s = $%d", clean_name, data.current))
                y = y + 1
            end
            term.setCursorPos(2, y+1); print("Press any key to return...")
            os.pullEvent("key")
        elseif choice == 2 then deposit()
        elseif choice == 3 then withdraw()
        end
    end

    drive.ejectDisk()
    rednet.close("back")
    clear(); print("Thank you for banking with Drunken Beard Bank!")
    sleep(2)
end

local function runSession()
    clear()
    print("Drunken Beard Bank")
    print("Please insert your bank card...")

    local drive = peripheral.find("drive")
    if not drive then error("No Disk Drive is attached to this terminal.", 0) end
    
    local event, p1 = os.pullEvent("disk")

    local disk_label = disk.getLabel(p1)
    if not disk_label or not disk_label:match("^DrunkenBeard_Card_.+") then
        showMessage("Card Error", "This is not a valid Drunken Beard Bank card.")
        disk.eject(p1)
        return
    end
    
    username = disk_label:match("^DrunkenBeard_Card_(.+)")
    local handle = fs.open(disk.getMountPath(p1) .. "/.card_data", "r")
    if not handle then
        showMessage("Card Error", "Card is missing its data file.")
        disk.eject(p1)
        return
    end

    local card_contents = handle.readAll()
    handle.close()
    local ok, data = pcall(textutils.unserialize, card_contents)

    if not ok or not data then
        showMessage("Card Error", "Card data is corrupt.")
        disk.eject(p1)
        return
    end
    
    -- THE FIX: Assign the data we just read to the main variable.
    card_data = data

    if login() then
        mainMenu()
    else
        -- If login fails, eject the card immediately.
        disk.eject(p1)
        print("\nCard ejected.")
        sleep(2)
    end
end

--==============================================================================
-- Main Program Loop
--==============================================================================

while true do
    local ok, err = pcall(function()
        local modem = peripheral.find("modem")
        if not modem then error("No modem attached.", 0) end
        rednet.open(peripheral.getName(modem))

        bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
        if not bankServerId then error("Could not find bank server.", 0) end
        
        -- THE FIX: Use a broadcast to find the turtle with its dynamic hostname.
        print("Locating Vault Clerk Turtle...")
        rednet.broadcast({type="ping"}, TURTLE_CLERK_PROTOCOL)
        local id, _, _ = rednet.receive(TURTLE_CLERK_PROTOCOL, 2)
        if not id then error("Could not find Vault Clerk turtle.", 0) end
        turtleClerkId = id
        print("Vault Clerk located at ID " .. turtleClerkId)
        sleep(1)
        
        runSession()
        rednet.close()
    end)
    
    if not ok then
        showMessage("Fatal Error", tostring(err))
        sleep(5)
    end
end
