--[[
    SHA1 & HMAC-SHA1 Cryptography Library (v1.0)
    by Gemini Gem

    Purpose:
    Provides a standard, reusable library for SHA1 hashing and HMAC-SHA1
    message signing. This module is intended to be used by other programs
    in the Drunken_OS suite to ensure consistent and secure operations.

    Usage:
    -- Place this file in a "/lib/" directory.
    -- Then, in your main script:
    local crypto = require("lib.sha1_hmac")
    local hashed_password = crypto.hex("my_password")
    local signature = crypto.hmac_hex("secret_key", "message_to_sign")
]]

-- The main table we will return at the end.
local sha1_lib = {}

-- We wrap the library logic in a 'do...end' block to keep
-- intermediate helper functions and variables local to this file.
do
    -- Use the standard bit32 library, which is available in CC: Restitched.
    local lshift, rshift, bor, band, bxor = bit32.lshift, bit32.rshift, bit32.bor, bit32.band, bit32.bxor

    -- Helper function to perform a circular left shift (rotate).
    local function rol(n, c)
        return bor(lshift(n, c), rshift(n, 32 - c))
    end

    -- Helper function to convert a string to a table of its byte values.
    local function str_to_bin(str)
        local t = {}
        for i = 1, #str do
            t[i] = string.byte(str, i)
        end
        return t
    end

    -- Helper function to convert a table of byte values back to a string.
    local function bin_to_str(bin)
        return string.char(table.unpack(bin))
    end

    -- Helper function to convert a table of byte values to a hex string.
    local function bin_to_hex(bin)
        local hex = ""
        for i = 1, #bin do
            hex = hex .. string.format("%02x", bin[i])
        end
        return hex
    end

    --[[
        The core SHA1 algorithm implementation. This is the heavy lifter.
        @param {string} s The string to hash.
        @return {table} A table of byte values representing the hash.
    ]]
    function sha1_lib.bin(s)
      local H0, H1, H2, H3, H4 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
      local str = str_to_bin(s); local len = #str; str[len + 1] = 0x80
      for i = len + 2, (len + 64) - ((len + 8) % 64) do str[i] = 0 end
      local bit_len = len * 8
      for i = 0, 7 do str[#str + 1] = band(rshift(bit_len, (7 - i) * 8), 0xff) end
      for i = 1, #str, 64 do
        local W = {}; for j = 0, 15 do W[j] = bor(lshift(str[i+j*4], 24), lshift(str[i+j*4+1], 16), lshift(str[i+j*4+2], 8), str[i+j*4+3]) end
        for j = 16, 79 do W[j] = rol(bxor(W[j-3], W[j-8], W[j-14], W[j-16]), 1) end
        local a,b,c,d,e = H0,H1,H2,H3,H4
        for j = 0, 79 do
          local f, k
          if j < 20 then f = bxor(d, band(b, bxor(c, d))); k = 0x5A827999
          elseif j < 40 then f = bxor(b, c, d); k = 0x6ED9EBA1
          elseif j < 60 then f = bor(band(b, c), band(b, d), band(c, d)); k = 0x8F1BBCDC
          else f = bxor(b, c, d); k = 0xCA62C1D6 end
          local temp = rol(a, 5) + f + e + W[j] + k; e=d; d=c; c=rol(b, 30); b=a; a=temp
        end
        H0=(H0+a); H1=(H1+b); H2=(H2+c); H3=(H3+d); H4=(H4+e)
      end
      local result = {}; for i=0,3 do result[i+1]=band(rshift(H0,(3-i)*8),0xff) end; for i=0,3 do result[i+5]=band(rshift(H1,(3-i)*8),0xff) end; for i=0,3 do result[i+9]=band(rshift(H2,(3-i)*8),0xff) end; for i=0,3 do result[i+13]=band(rshift(H3,(3-i)*8),0xff) end; for i=0,3 do result[i+17]=band(rshift(H4,(3-i)*8),0xff) end
      return result
    end

    --[[
        Hashes a string using the SHA1 algorithm and returns it as hex.
        @param {string} s The string to hash.
        @return {string} The hexadecimal representation of the hash.
    ]]
    function sha1_lib.hex(s)
        return bin_to_hex(sha1_lib.bin(s))
    end

    --[[
        Signs a message with a key using the HMAC-SHA1 algorithm.
        @param {string} key The secret key for signing.
        @param {string} message The message to sign.
        @return {string} The hexadecimal representation of the signature.
    ]]
    function sha1_lib.hmac_hex(key, message)
        local blocksize = 64
        if #key > blocksize then
            key = bin_to_str(sha1_lib.bin(key))
        end

        local key_padding = {}
        for i = 1, blocksize do
            key_padding[i] = string.byte(key, i) or 0
        end

        local o_key_pad = ""
        local i_key_pad = ""
        for i = 1, blocksize do
            o_key_pad = o_key_pad .. string.char(bxor(key_padding[i], 0x5c))
            i_key_pad = i_key_pad .. string.char(bxor(key_padding[i], 0x36))
        end

        local inner_hash = bin_to_str(sha1_lib.bin(i_key_pad .. message))
        local final_hash = sha1_lib.bin(o_key_pad .. inner_hash)
        return bin_to_hex(final_hash)
    end
end

-- This exposes the 'sha1_lib' table (containing .hex and .hmac_hex) to any
-- script that 'requires' this file.
return sha1_lib
