--[[
    SimpleMail & Chat Client (v11.7 - Direct Library Download)
    by Gemini Gem & MuhendizBey

    Purpose:
    This version updates the client to use the new, more robust direct-download
    protocol for installing required libraries.

    Key Changes:
    - The `installDependencies` function now sends a "get_lib_code" request
      to the server instead of the old "get_lib".
    - This ensures it receives the raw library source code, fixing the reboot loop
      and making the installation process fully self-contained and reliable.
]]

--==============================================================================
-- Environment & Path Setup
--==============================================================================

-- Get the directory where this program is running.
local programDir = fs.getDir(shell.getRunningProgram())

-- Add the program's local library folder to the list of places Lua looks for modules.
package.path = fs.combine(programDir, "lib/?.lua;") .. package.path

--==============================================================================
-- Configuration & State
--==============================================================================

local currentVersion = 11.7
local programName = "mail"
local SESSION_FILE = ".session"
local REQUIRED_LIBS = { "sha1_hmac", "drunken_os_apps" }

-- This table holds the program's state, which is passed to the app library.
local state = {
    mailServerId = nil,
    chatServerId = nil,
    gameServerId = nil,
    username = nil,
    nickname = nil,
    session_token = nil,
    isAdmin = false,
    programDir = programDir,
    -- Forward-declare functions so the app library can call them
    showMessage = nil,
    drawMenu = nil,
    drawWindow = nil,
    getSafeSize = nil,
    wordWrap = nil
}

--==============================================================================
-- UI & Theme
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then
        return colors[colorName]
    end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    border = safeColor("lightGray", colors.white),
    title = safeColor("green", colors.lime),
    prompt = safeColor("cyan", colors.cyan),
    highlightBg = safeColor("blue", colors.blue),
    highlightText = safeColor("white", colors.white),
    statusBarBg = safeColor("gray", colors.lightGray),
    statusBarText = safeColor("white", colors.white),
}

--==============================================================================
-- Core Utility & UI Functions
--==============================================================================

local function getSafeSize()
    local w, h = term.getSize()
    while not w or not h do
        sleep(0.05)
        w, h = term.getSize()
    end
    return w, h
end

local function wordWrap(text, width)
    local lines = {}
    for line in text:gmatch("[^\r\n]+") do
        while #line > width do
            local space = line:sub(1, width + 1):match(".+ ")
            local len = space and #space or width
            table.insert(lines, line:sub(1, len - 1))
            line = line:sub(len):match("^%s*(.*)")
        end
        table.insert(lines, line)
    end
    return lines
end

local function clear()
    term.setBackgroundColor(theme.bg)
    term.clear()
    term.setCursorPos(1, 1)
end

local function drawWindow(title)
    clear()
    local w, h = getSafeSize()
    term.setBackgroundColor(theme.windowBg)
    for y = 1, h - 1 do
        term.setCursorPos(1, y)
        term.write(string.rep(" ", w))
    end

    term.setBackgroundColor(theme.title)
    term.setCursorPos(1, 1)
    term.write(string.rep(" ", w))
    term.setTextColor(colors.white)
    local titleText = " " .. title .. " "
    term.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1)
    term.write(titleText)
    
    term.setBackgroundColor(theme.statusBarBg)
    term.setTextColor(theme.statusBarText)
    term.setCursorPos(1, h)
    term.write(string.rep(" ", w))
    local userText = "User: " .. (state.nickname or "Guest") .. (state.isAdmin and " (Admin)" or "")
    local versionText = "v" .. currentVersion
    
    if w < 35 then
        local statusText = userText .. " | " .. versionText
        term.setCursorPos(math.floor((w - #statusText) / 2) + 1, h)
        term.write(statusText)
    else
        local helpText = "See 'Help' Menu for Controls"
        term.setCursorPos(2, h)
        term.write(userText)
        term.setCursorPos(w - #versionText, h)
        term.write(versionText)
        term.setCursorPos(math.floor((w - #helpText) / 2) + 1, h)
        term.write(helpText)
    end

    term.setBackgroundColor(theme.windowBg)
    term.setTextColor(theme.text)
end

local function drawMenu(options, selectedIndex, startX, startY)
    for i, option in ipairs(options) do
        local text = option
        if (option == "Mail" or option == "View Inbox") and state.unreadCount > 0 then
            text = text .. " [" .. state.unreadCount .. "]"
        end
        term.setCursorPos(startX, startY + i - 1)
        if i == selectedIndex then
            term.setBackgroundColor(theme.highlightBg)
            term.setTextColor(theme.highlightText)
            term.write("> " .. text .. string.rep(" ", 25 - #text))
        else
            term.setBackgroundColor(theme.windowBg)
            term.setTextColor(theme.text)
            term.write("  " .. text .. string.rep(" ", 25 - #text))
        end
    end
    term.setBackgroundColor(theme.windowBg)
end

local function showMessage(title, message)
    drawWindow(title)
    local w, h = getSafeSize()
    local lines = wordWrap(message, w - 4)
    for i, line in ipairs(lines) do
        term.setCursorPos(3, 4 + i - 1)
        term.write(line)
    end
    term.setCursorPos(3, 4 + #lines + 1)
    term.setTextColor(theme.prompt)
    term.write("Press any key to continue...")
    os.pullEvent("key")
    term.setTextColor(theme.text)
end

local function readInput(prompt, y, hideText)
    local x = 2
    term.setTextColor(theme.prompt)
    term.setCursorPos(x, y)
    term.write(prompt)
    term.setTextColor(theme.text)
    term.setCursorPos(x + #prompt, y)
    term.setCursorBlink(true)
    local input = hideText and read("*") or read()
    term.setCursorBlink(false)
    return input
end

-- Create the context table that will be passed to library functions
local context = {
    getSafeSize = getSafeSize,
    wordWrap = wordWrap,
    clear = clear,
    drawWindow = drawWindow,
    drawMenu = drawMenu,
    showMessage = showMessage,
    readInput = readInput,
    theme = theme,
    programDir = programDir, -- Pass the program's directory to the library
    parent = state -- a reference to the main state table
}

--==============================================================================
-- Installation & Update Functions
--==============================================================================

local function findServers()
    state.mailServerId = rednet.lookup("SimpleMail", "mail.server")
    if not state.mailServerId then return false, "Cannot find mail.server" end
    
    state.chatServerId = rednet.lookup("SimpleChat", "chat.server")
    if not state.chatServerId then return false, "Cannot find chat.server" end

    state.gameServerId = rednet.lookup("ArcadeGames", "arcade.server")
    if not state.gameServerId then return false, "Cannot find arcade.server" end
    
    return true
end

local function installDependencies()
    local needsReboot = false
    for _, libName in ipairs(REQUIRED_LIBS) do
        local ok = pcall(require, "lib." .. libName)
        if not ok then
            needsReboot = true -- A reboot will be required if we install anything.
            term.clear(); term.setCursorPos(1,1)
            print("Missing required library: " .. libName)
            print("Attempting to download from server...")

            local server = rednet.lookup("SimpleMail", "mail.server")
            if not server then
                print("Error: Cannot find mail.server to download libraries.")
                print("Please check server and network connection.")
                return false -- Halt execution
            end

            -- Use the new, direct code transfer protocol.
            rednet.send(server, { type = "get_lib_code", lib = libName }, "SimpleMail")
            local _, response = rednet.receive("SimpleMail", 10) -- Increased timeout for reliability
            
            if response and response.success and response.code then
                print("Download successful. Installing...")
                local libPath = fs.combine(programDir, "lib/" .. libName .. ".lua")
                
                -- Ensure the /lib/ directory exists
                if not fs.isDir(fs.combine(programDir, "lib")) then
                    fs.makeDir(fs.combine(programDir, "lib"))
                end

                local file, err = fs.open(libPath, "w")
                if not file then
                    print("Error: Could not open file for writing at:")
                    print(libPath)
                    print("Reason: " .. tostring(err))
                    return false -- Halt execution
                end
                
                file.write(response.code)
                file.close()
                print("Library '" .. libName .. "' installed.")
                sleep(1) -- Give fs time to process
            else
                print("Error: Could not download library.")
                print("Reason: " .. (response and response.reason or "Timeout"))
                return false -- Halt execution
            end
        end
    end
    
    if needsReboot then
        print("All libraries installed. Rebooting...")
        sleep(2)
        os.reboot()
        -- The program will not reach here, but we return true for logical consistency.
        return true 
    end
    
    -- If we get here, no installation was needed.
    return true -- Signal success
end

local function autoUpdateCheck()
    drawWindow("Updater")
    term.setCursorPos(2, 4); term.write("Checking for client updates...")
    rednet.send(state.mailServerId, {type = "get_version", program = programName}, "SimpleMail")
    local _, response = rednet.receive("SimpleMail", 3)
    
    if response and response.version and response.version > currentVersion then
        term.setCursorPos(2, 6); term.write("Update found! v"..response.version.." is available.")
        term.setCursorPos(2, 7); term.write("Downloading...")
        rednet.send(state.mailServerId, {type = "get_update", program = programName}, "SimpleMail")
        local _, update = rednet.receive("SimpleMail", 10)
        
        if update and update.code then
            local savePath = shell.getRunningProgram()
            local file = fs.open(savePath, "w")
            if not file then
                showMessage("Update Error", "Could not open file for writing.")
                return false
            end
            file.write(update.code)
            file.close()
            
            term.setCursorPos(2, 9); term.write("Update complete! Restarting...")
            sleep(2)
            shell.run(savePath)
            return true
        else
            showMessage("Error", "Update download failed.")
        end
    end
    return false
end

function updateGames()
    drawWindow("Game Updater")
    local y = 4
    term.setCursorPos(2, y); term.write("Fetching game list from server...")
    y = y + 1

    local gamesDir = fs.combine(programDir, "games")
    if not fs.exists(gamesDir) then
        term.setCursorPos(2, y); term.write("- Creating games directory...")
        y = y + 1
        fs.makeDir(gamesDir)
    end
    
    rednet.send(state.mailServerId, { type = "get_all_game_versions" }, "SimpleMail")
    local _, response = rednet.receive("SimpleMail", 10)

    if not response or not response.versions then
        term.setCursorPos(2, y); term.write("- Could not fetch server game versions.")
        sleep(2)
        return
    end

    for filename, serverVersion in pairs(response.versions) do
        local localPath = fs.combine(gamesDir, filename)
        term.setCursorPos(2, y)
        term.clearLine()
        term.write("- Checking " .. filename .. "...")
        
        local localVersion = 0
        if fs.exists(localPath) then
            local file = fs.open(localPath, "r")
            if file then
                local content = file.readAll()
                file.close()
                local foundVersion = string.match(content, "%-%-%s*Version:%s*([%d%.]+)")
                if foundVersion then
                    localVersion = tonumber(foundVersion)
                end
            end
        end
        
        if serverVersion > localVersion then
            term.setCursorPos(4, y + 1); term.write("-> New version found! Downloading...")
            rednet.send(state.mailServerId, {type = "get_game_update", program = filename}, "SimpleMail")
            local _, update = rednet.receive("SimpleMail", 10)
            
            if update and update.code then
                local file = fs.open(localPath, "w")
                if file then
                    file.write(update.code)
                    file.close()
                    term.setCursorPos(4, y + 2); term.write("-> Update successful!")
                else
                    term.setCursorPos(4, y + 2); term.write("-> Error: Could not save file.")
                end
            else
                term.setCursorPos(4, y + 2); term.write("-> Error: Download failed.")
            end
            y = y + 3
        else
            y = y + 1
        end
    end
    term.setCursorPos(2, y + 1); term.write("Update check complete.")
    sleep(2)
end

--==============================================================================
-- Login & Main Menu Logic
--==============================================================================

local function completeAuthentication(user)
    drawWindow("Authentication Required")
    local w, h = getSafeSize()
    local message = "A token has been sent to the Auth Server admin. Please ask them for your token and enter it below."
    local lines = wordWrap(message, w - 4)
    for i, line in ipairs(lines) do
        term.setCursorPos(3, 4 + i - 1)
        term.write(line)
    end
    
    local token_raw = readInput("Auth Token: ", 4 + #lines + 2, false)
    if not token_raw or token_raw == "" then
        showMessage("Cancelled", "Authentication cancelled.")
        return false
    end

    local token_clean = token_raw:gsub("%s+", "")
    drawWindow("Verifying Token...")
    rednet.send(state.mailServerId, { type = "submit_auth_token", user = user, token = token_clean }, "SimpleMail")
    local _, response = rednet.receive("SimpleMail", 10)

    if response and response.success then
        state.username = user
        state.nickname = response.nickname
        state.unreadCount = response.unreadCount or 0
        state.isAdmin = response.isAdmin or false
        if response.session_token then
            local file = fs.open(SESSION_FILE, "w")
            if file then
                file.write(response.session_token)
                file.close()
            end
        end
        showMessage("Success", "Authentication successful!")
        return true
    else
        showMessage("Authentication Failed", response.reason or "No response from server.")
        return false
    end
end

function loginOrRegister()
    local options = {"Login", "Register", "Exit"}
    local selected = 1
    while not state.username do
        drawWindow("Welcome")
        drawMenu(options, selected, 2, 5)
        local event, key = os.pullEvent("key")
        if key == keys.up then
            selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then
            selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then
            if selected == 1 then -- Login
                drawWindow("Login")
                local user = readInput("Username: ", 5, false)
                if user and user ~= "" then
                    local pass = readInput("Password: ", 7, true)
                    if pass and pass ~= "" then
                        local session_token = nil
                        if fs.exists(SESSION_FILE) then
                            local file = fs.open(SESSION_FILE, "r")
                            if file then
                                session_token = file.readAll()
                                file.close()
                            end
                        end
                        
                        rednet.send(state.mailServerId, { type = "login", user = user, pass = pass, session_token = session_token }, "SimpleMail")
                        local _, response = rednet.receive("SimpleMail", 10)

                        if response and response.success then
                            if response.needs_auth then
                                if not completeAuthentication(user) then
                                    state.username = nil
                                end
                            else
                                state.username = user
                                state.nickname = response.nickname
                                state.unreadCount = response.unreadCount or 0
                                state.isAdmin = response.isAdmin or false
                            end
                        else
                            showMessage("Login Failed", response.reason or "No response.")
                        end
                    end
                end
            elseif selected == 2 then -- Register
                drawWindow("Register")
                local user = readInput("Choose Username: ", 5, false)
                if user and user ~= "" then
                    local nick = readInput("Choose Nickname: ", 7, false)
                    if nick and nick ~= "" then
                        local pass = readInput("Choose Password: ", 9, true)
                        if pass and pass ~= "" then
                            rednet.send(state.mailServerId, { type = "register", user = user, pass = pass, nickname = nick }, "SimpleMail")
                            local _, response = rednet.receive("SimpleMail", 5)
                            if response and response.success and response.needs_auth then
                                if not completeAuthentication(user) then
                                    state.username = nil
                                end
                            else
                                showMessage("Registration Failed", response.reason or "No response.")
                            end
                        end
                    end
                end
            elseif selected == 3 then
                return false
            end
        elseif key == keys.tab then
            return false
        end
    end
    return true
end

function mainMenu()
    local options = {"Mail", "Manage Lists", "General Chat", "Play Games", "Send Feedback"}
    if state.isAdmin and state.adminServerId then
        table.insert(options, "Admin Console")
    end
    table.insert(options, "System")
    table.insert(options, "Help")
    table.insert(options, "Exit")

    local selected = 1
    local pollTimer = os.startTimer(10)
    local needsRedraw = true
    
    local ok, err = pcall(function()
        rednet.unhost("SimpleMail")
        rednet.host("SimpleMail", "client." .. state.username)
    end)
    if not ok then
        showMessage("Login Error", "This user is already logged in elsewhere.")
        state.username = nil
        return
    end

    while true do
        if needsRedraw then
            drawWindow("Main Menu")
            drawMenu(options, selected, 2, 3)
            needsRedraw = false
        end

        local event, p1, p2, p3 = os.pullEvent("key", "timer", "rednet_message", "terminate")
        if event == "key" then
            if p1 == keys.up then
                selected = (selected == 1) and #options or selected - 1
            elseif p1 == keys.down then
                selected = (selected == #options) and 1 or selected + 1
            elseif p1 == keys.enter then
                local action = options[selected]
                if action == "Mail" then state.apps.mailMenu(context)
                elseif action == "Manage Lists" then state.apps.manageLists(context)
                elseif action == "General Chat" then state.apps.startChat(context)
                elseif action == "Play Games" then state.apps.enterArcade(context)
                elseif action == "Send Feedback" then state.apps.sendFeedback(context)
                elseif action == "Admin Console" then state.apps.adminConsole(context)
                elseif action == "System" then state.apps.systemMenu(context)
                elseif action == "Help" then state.apps.showHelpScreen(context)
                elseif action == "Exit" then return end
                needsRedraw = true
            elseif p1 == keys.tab or p1 == keys.q then
                return
            end
            needsRedraw = true
        elseif event == "timer" and p1 == pollTimer then
            rednet.send(state.mailServerId, {type = "get_unread_count", user = state.username}, "SimpleMail")
            pollTimer = os.startTimer(10)
        elseif event == "rednet_message" and p3 == "SimpleMail" then
            if p2.type == "broadcast" then
                showMessage("Broadcast", p2.text)
                needsRedraw = true
            elseif p2.type == "unread_count_response" and p2.count ~= state.unreadCount then
                state.unreadCount = p2.count
                needsRedraw = true
            end
        elseif event == "terminate" then
            return
        end
    end
end

--==============================================================================
-- Program Entry Point
--==============================================================================

local function showSplashScreen()
    clear()
    term.setTextColor(colors.orange)
    local w,h = getSafeSize()
    local art = {
        "         . .        ",
        "       .. . *.      ",
        "- -_ _-__-0oOo      ",
        " _-_ -__ -||||)     ",
        "    ______||||______",
        "~~~~~~~~~~`\"\"'~   "
    }
    local title = "Drunken Beard OS"
    local startY = math.floor(h / 2) - math.floor(#art / 2) - 2
    for i, line in ipairs(art) do
        term.setCursorPos(math.floor(w / 2 - #line / 2), startY + i)
        term.write(line)
    end
    term.setCursorPos(math.floor(w / 2 - #title / 2), startY + #art + 2)
    term.write(title)
    sleep(1.5)
end

local function main()
    showSplashScreen()
    while true do
        rednet.open("back")
        local connected, reason = findServers()
        if not connected then
            showMessage("Connection Error", reason or "Could not find servers. Retrying...", true)
            sleep(5)
        else
            if autoUpdateCheck() then return end
            
            -- The installDependencies function now returns true on success,
            -- and false on a critical failure that requires stopping.
            if not installDependencies() then
                -- A critical error occurred during installation, so we stop.
                print("Halting due to installation error.")
                return 
            end
            
            -- If we reach here, it means either no reboot was needed, or the
            -- os.reboot() call is pending. The old logic was flawed.
            -- After a successful install and reboot, the script will restart
            -- and this block will be passed correctly.
            
            state.username = nil
            state.isAdmin = false
            if not loginOrRegister() then
                clear(); print("Goodbye!"); break
            end
            
            rednet.send(state.mailServerId, {type = "get_motd"}, "SimpleMail")
            local _, response = rednet.receive("SimpleMail", 3)
            if response and response.motd and response.motd ~= "" then
                showMessage("Message of the Day", response.motd)
            end
            
            mainMenu()
            
            rednet.close("back")
            if not state.username then
                clear(); print("Goodbye!"); break
            end
        end
    end
end

main()

