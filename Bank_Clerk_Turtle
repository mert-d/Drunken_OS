--[[
    Drunken Beard Bank - Vault Clerk Turtle (v3.6 - Definitive Fix)
    by Gemini Gem & MuhendizBey

    Purpose:
    This definitive version fixes all known syntax and API errors. It features
    a re-engineered, robust peripheral discovery system and correct withdrawal
    logic, built to the highest engineering standards.

    Key Changes:
    - Re-engineered findPeripherals() to use correct API calls (`peripheral.getType`)
      and standard loop control, fixing all previous errors.
    - Preserved the dynamic vault discovery and reliable turtle.suck/drop logic.
]]

--==============================================================================
-- Configuration
--==============================================================================

local protocol = "DB_ATM_Turtle"
local depositBlockName = "minecraft:barrel"

--==============================================================================
-- Core Functions (Definitive Version)
--==============================================================================

---
-- Scans for required peripherals and dynamically identifies the vault.
-- @return The names of the modem, deposit side, vault side, or an error.
local function findPeripherals()
    print("Scanning for peripherals...")
    
    local modem_side = peripheral.find("modem")
    if not modem_side then return nil, nil, nil, "No wireless modem attached." end
    modem_side = peripheral.getName(modem_side)
    print("Found Modem on: " .. modem_side)

    local deposit_side = peripheral.find(depositBlockName)
    if not deposit_side then return nil, nil, nil, "Could not find Deposit Barrel." end
    deposit_side = peripheral.getName(deposit_side)
    print("Found Deposit Barrel on: " .. deposit_side)

    -- THE FIX: Dynamic Vault Discovery using correct API calls and loops.
    local vault_side = nil
    for _, name in ipairs(peripheral.getNames()) do
        if name ~= modem_side and name ~= deposit_side then
            -- A peripheral can have multiple types. Check if one of them is 'inventory'.
            if peripheral.hasType(name, "inventory") then
                vault_side = name
                print("Dynamically found Vault (".. peripheral.getType(name) ..") on: " .. vault_side)
                break -- Exit the loop once we've found our vault.
            end
        end
    end

    if not vault_side then
        return nil, nil, nil, "Could not find a valid vault inventory peripheral."
    end
    
    return modem_side, deposit_side, vault_side, nil
end

local function turnTo(targetSide)
    if targetSide == "left" then turtle.turnLeft()
    elseif targetSide == "right" then turtle.turnRight()
    elseif targetSide == "back" then turtle.turnRight(); turtle.turnRight() end
end

local function turnToFront(originalSide)
    if originalSide == "left" then turtle.turnRight()
    elseif originalSide == "right" then turtle.turnLeft()
    elseif originalSide == "back" then turtle.turnLeft(); turtle.turnLeft() end
end

local function collectFromDeposit(deposit_side)
    turnTo(deposit_side)
    for i = 1, 16 do
        turtle.select(i)
        turtle.suck()
    end
    turnToFront(deposit_side)
end

local function depositToVault(vault_side)
    turnTo(vault_side)
    for i = 1, 16 do
        turtle.select(i)
        if turtle.getItemCount(i) > 0 then
            turtle.drop()
        end
    end
    turnToFront(vault_side)
end

local function returnItemsToDeposit(deposit_side)
    turnTo(deposit_side)
    for i = 1, 16 do
        turtle.select(i)
        if turtle.getItemCount(i) > 0 then
            turtle.drop()
        end
    end
    turnToFront(deposit_side)
end

local function handleDeposit(atmId, deposit_side, vault_side)
    collectFromDeposit(deposit_side)
    
    local itemsInTurtle = {}
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item then
            table.insert(itemsInTurtle, { name = item.name, count = item.count })
        end
    end

    rednet.send(atmId, { type = "deposit_count", items = itemsInTurtle }, protocol)
    local _, message = rednet.receive(protocol, 15)

    if message and message.type == "confirm_deposit" then
        depositToVault(vault_side)
        rednet.send(atmId, { success = true, new_balance = message.new_balance }, protocol)
        print("Successfully processed deposit.")
    else
        returnItemsToDeposit(deposit_side)
        rednet.send(atmId, { success = false, reason = "Deposit cancelled or timed out." }, protocol)
        print("Deposit failed. Returned items.")
    end
end

local function handleDispense(atmId, itemToDispense, count, vault_side, deposit_side)
    local vault = peripheral.wrap(vault_side)
    if not vault then
        rednet.send(atmId, { success = false, reason = "Clerk could not access vault." }, protocol)
        return
    end

    local itemSlot = -1
    for i = 1, vault.size() do
        local item = vault.getItemDetail(i)
        if item and item.name == itemToDispense then
            itemSlot = i
            break
        end
    end

    if itemSlot == -1 then
        rednet.send(atmId, { success = false, reason = "Requested item not found in vault." }, protocol)
        return
    end

    -- THE FIX: Use the reliable suck/drop method for withdrawal.
    turnTo(vault_side)
    local pulled = 0
    for i=1,16 do turtle.select(i); turtle.drop() end -- Clear turtle inventory first
    turtle.select(1)
    
    -- We can only suck a max of 64 at a time.
    while pulled < count do
        local to_pull = math.min(count - pulled, 64)
        local success = turtle.suckFromSlot(itemSlot, to_pull)
        if not success then
             -- Could not suck, maybe slot is empty now. Return what we have.
             depositToVault(vault_side)
             rednet.send(atmId, { success = false, reason = "Could not pull required items from vault." }, protocol)
             return
        end
        pulled = pulled + turtle.getItemCount(1)
        depositToVault(vault_side) -- Move sucked items to another slot to clear slot 1
        turtle.select(1)
    end
    turnToFront(vault_side)
    
    returnItemsToDeposit(deposit_side)

    rednet.send(atmId, { success = true }, protocol)
    print("Successfully dispensed " .. count .. " of " .. itemToDispense)
end

--==============================================================================
-- Main Program Loop
--==============================================================================

local function main()
    local modem_side, deposit_side, vault_side, err = findPeripherals()
    if err then
        print("Error: " .. err)
        return
    end

    rednet.open(modem_side)
    -- Host a protocol that the ATM can discover via broadcast
    rednet.host(protocol, "bank_turtle") 

    print("Vault Clerk Turtle online (ID " .. os.getComputerID() .. "). Waiting for commands...")

    while true do
        local senderId, message, proto = rednet.receive()
        if message and message.type and proto == protocol then
            if message.type == "ping" then
                rednet.send(senderId, { type = "pong" }, protocol)
            elseif message.type == "request_deposit" then
                handleDeposit(senderId, deposit_side, vault_side)
            elseif message.type == "request_dispense" then
                handleDispense(senderId, message.item_name, message.count, vault_side, deposit_side)
            end
        end
    end
end

main()
