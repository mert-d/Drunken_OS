--[[
    Drunken Beard Bank - Vault Clerk Turtle (v3.3 - Definitive Edition)
    by Gemini Gem & MuhendizBey

    Purpose:
    This definitive version re-engineers the turtle with a dynamic peripheral
    discovery system and a robust, direct-transfer withdrawal method as per
    user specification. It is no longer hardcoded to specific block types.

    Key Changes:
    - findPeripherals() now dynamically finds any adjacent block with an
      "inventory" type to use as the vault, instead of a hardcoded name.
    - handleDispense() now commands the vault to push items DIRECTLY to the
      deposit barrel, a much more efficient and reliable method that fixes
      all previous API errors.
]]

--==============================================================================
-- Configuration
--==============================================================================

local protocol = "DB_ATM_Turtle"
-- NOTE: We only need to hardcode the deposit barrel, as the vault is now dynamic.
local depositBlockName = "minecraft:barrel"

--==============================================================================
-- Core Functions (Re-Engineered)
--==============================================================================

---
-- Scans for required peripherals and dynamically identifies the vault.
-- @return The names of the modem, deposit side, vault side, or an error.
local function findPeripherals()
    print("Scanning for peripherals...")
    
    local modem_side = peripheral.find("modem")
    if not modem_side then return nil, nil, nil, "No wireless modem attached." end
    modem_side = peripheral.getName(modem_side)
    print("Found Modem on: " .. modem_side)

    local deposit_side = peripheral.find(depositBlockName)
    if not deposit_side then return nil, nil, nil, "Could not find Deposit Barrel." end
    deposit_side = peripheral.getName(deposit_side)
    print("Found Deposit Barrel on: " .. deposit_side)

    -- THE FIX: Dynamic Vault Discovery
    local vault_side = nil
    for _, name in ipairs(peripheral.getNames()) do
        -- Skip the peripherals we already know
        if name ~= modem_side and name ~= deposit_side then
            local types = { peripheral.getTypes(name) }
            for _, p_type in ipairs(types) do
                if p_type == "inventory" then
                    vault_side = name
                    print("Dynamically found Vault (".. peripheral.getType(name) ..") on: " .. vault_side)
                    goto found_vault -- A rare but useful case for goto
                end
            end
        end
    end
    ::found_vault::

    if not vault_side then
        return nil, nil, nil, "Could not find a valid vault inventory."
    end

    return modem_side, deposit_side, vault_side, nil
end

-- ... (turnTo, turnToFront, and deposit-related functions are unchanged) ...

---
-- Handles a withdrawal request by commanding the vault to push directly
-- to the deposit barrel.
-- @param atmId The rednet ID of the requesting ATM.
-- @param itemToDispense The name of the item to withdraw.
-- @param count The number of items to withdraw.
-- @param vault_side The name of the vault peripheral side.
-- @param deposit_side The name of the deposit peripheral side.
local function handleDispense(atmId, itemToDispense, count, vault_side, deposit_side)
    local vault = peripheral.wrap(vault_side)
    if not vault then
        rednet.send(atmId, { success = false, reason = "Clerk could not access vault." }, protocol)
        return
    end

    -- 1. Find a slot in the vault that contains the requested item.
    local itemSlot = -1
    local itemsInSlot = 0
    for i = 1, vault.size() do
        local item = vault.getItemDetail(i)
        if item and item.name == itemToDispense then
            itemSlot = i
            itemsInSlot = item.count
            break
        end
    end

    if itemSlot == -1 then
        rednet.send(atmId, { success = false, reason = "Requested item not found in vault." }, protocol)
        return
    end
    
    if itemsInSlot < count then
        rednet.send(atmId, { success = false, reason = "Insufficient stock in vault." }, protocol)
        return
    end

    -- 2. THE FIX: Command the vault to push items DIRECTLY to the deposit barrel.
    print("Commanding vault to transfer " .. count .. " " .. itemToDispense .. "...")
    local success, reason = vault.pushItems(deposit_side, itemSlot, count)
    
    if not success then
        print("Error during vault transfer: " .. tostring(reason))
        rednet.send(atmId, { success = false, reason = "Vault transfer failed." }, protocol)
        return
    end
    
    -- 3. Confirm completion to the ATM.
    rednet.send(atmId, { success = true }, protocol)
    print("Successfully dispensed " .. count .. " of " .. itemToDispense)
end


--==============================================================================
-- Main Program Loop
--==============================================================================

local function main()
    local modem_side, deposit_side, vault_side, err = findPeripherals()
    if err then
        print("Error: " .. err)
        return
    end

    rednet.open(modem_side)
    -- Host a unique protocol name to allow multiple clerks to exist
    local host_protocol = protocol .. "_" .. os.getComputerID()
    rednet.host(host_protocol, "bank_turtle")
    print("Vault Clerk Turtle online (ID " .. os.getComputerID() .. "). Waiting for commands...")

    while true do
        local senderId, message, proto = rednet.receive() -- Listen on all protocols
        if message and message.type and proto == protocol then
            if message.type == "ping" then
                -- Respond to ATM discovery pings
                rednet.send(senderId, { type = "pong" }, protocol)
            elseif message.type == "request_deposit" then
                print("Received deposit request from ATM " .. senderId)
                handleDeposit(senderId, deposit_side, vault_side)
            elseif message.type == "request_dispense" then
                print("Received dispense request for " .. message.count .. " " .. message.item_name)
                handleDispense(senderId, message.item_name, message.count, vault_side, deposit_side)
            end
        end
    end
end

main()
