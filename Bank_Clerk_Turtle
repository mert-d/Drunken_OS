--[[
    Drunken Beard Bank - Vault Clerk Turtle (v7.0 - Multi-Stack Withdrawal)
    by Gemini Gem & MuhendizBey

    Purpose:
    This is the definitive, feature-complete version of the clerk turtle. It
    features universal 6-sided interaction logic and is capable of fulfilling
    a single withdrawal request by intelligently gathering items from multiple
    stacks within the vault.

    Changelog:
    v7.0:
    - Complete redesign of 'handleDispense' to support multi-stack withdrawals.
    - The turtle now scans the entire vault to find all available stock of a
      requested item before attempting to pull.
    - Removed the "slot 1" restriction from the previous workaround.
    v6.1:
    - Fixed a crash by correctly handling the boolean return value of the
      modern turtle API.
]]

--==============================================================================
-- Configuration
--==============================================================================

local protocol = "DB_ATM_Turtle"
local depositBlockName = "minecraft:barrel"

-- A table to map a side to its opposite.
local opposite_sides = {
    top = "bottom", bottom = "top",
    left = "right", right = "left",
    front = "back", back = "front"
}

--==============================================================================
-- Core Functions
--==============================================================================

local function logActivity(msg, isError)
    local prefix = os.date("[%H:%M:%S] ")
    if isError then
        print(prefix .. "ERROR: " .. msg)
    else
        print(prefix .. msg)
    end
end

local function findPeripherals()
    logActivity("Scanning for peripherals...")
    
    local modem_side = peripheral.find("modem")
    if not modem_side then return nil, nil, nil, "No wireless modem attached." end
    modem_side = peripheral.getName(modem_side)

    local deposit_side = peripheral.find(depositBlockName)
    if not deposit_side then return nil, nil, nil, "Could not find Deposit Barrel." end
    deposit_side = peripheral.getName(deposit_side)

    local vault_side = nil
    for _, name in ipairs(peripheral.getNames()) do
        if name ~= modem_side and name ~= deposit_side then
            if peripheral.hasType(name, "inventory") then
                vault_side = name
                break
            end
        end
    end

    if not vault_side then
        return nil, nil, nil, "Could not find a valid vault inventory peripheral."
    end
    
    return modem_side, deposit_side, vault_side, nil
end

-- (Movement and basic inventory functions are unchanged)
local function turnTo(targetSide)
    if targetSide == "left" then turtle.turnLeft()
    elseif targetSide == "right" then turtle.turnRight()
    elseif targetSide == "back" then turtle.turnRight(); turtle.turnRight() end
end

local function turnToFront(originalSide)
    if originalSide == "left" then turtle.turnRight()
    elseif originalSide == "right" then turtle.turnLeft()
    elseif originalSide == "back" then turtle.turnLeft(); turtle.turnLeft() end
end

local function collectFromDeposit(deposit_side)
    turnTo(deposit_side)
    for i = 1, 16 do turtle.select(i); turtle.suck() end
    turnToFront(deposit_side)
end

local function depositToVault(vault_side)
    turnTo(vault_side)
    for i = 1, 16 do
        turtle.select(i)
        if turtle.getItemCount(i) > 0 then turtle.drop() end
    end
    turnToFront(vault_side)
end

local function returnItemsToDeposit(deposit_side)
    turnTo(deposit_side)
    for i = 1, 16 do
        turtle.select(i)
        if turtle.getItemCount(i) > 0 then turtle.drop() end
    end
    turnToFront(deposit_side)
end

-- (handleDeposit is unchanged)
local function handleDeposit(atmId, deposit_side, vault_side)
    collectFromDeposit(deposit_side)
    local itemsInTurtle = {}
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item then table.insert(itemsInTurtle, { name = item.name, count = item.count }) end
    end
    rednet.send(atmId, { type = "deposit_count", items = itemsInTurtle }, protocol)
    local _, message = rednet.receive(protocol, 15)
    if message and message.type == "confirm_deposit" then
        depositToVault(vault_side)
        rednet.send(atmId, { success = true, new_balance = message.new_balance }, protocol)
        logActivity("Successfully processed deposit.")
    else
        returnItemsToDeposit(deposit_side)
        rednet.send(atmId, { success = false, reason = "Deposit cancelled or timed out by ATM." }, protocol)
        logActivity("Deposit failed. Returned items to barrel.")
    end
end

local function depositToVault(vault_side)
    if vault_side == "top" then
        for i = 1, 16 do
            turtle.select(i)
            if turtle.getItemCount(i) > 0 then turtle.dropUp() end
        end
    elseif vault_side == "bottom" then
        for i = 1, 16 do
            turtle.select(i)
            if turtle.getItemCount(i) > 0 then turtle.dropDown() end
        end
    else -- Horizontal
        turnTo(vault_side)
        for i = 1, 16 do
            turtle.select(i)
            if turtle.getItemCount(i) > 0 then turtle.drop() end
        end
        turnToFront(vault_side)
    end
end

local function handleDispense(atmId, itemToDispense, count, vault_side, deposit_side)
    logActivity("Initiating Multi-Stack withdrawal for "..count.." "..itemToDispense)
    local vault = peripheral.wrap(vault_side)

    -- === Phase 1: Stock Verification ===
    logActivity("Scanning vault for available stock...")
    local available_stock = 0
    local source_slots = {}
    for slot, item in pairs(vault.list()) do
        if item.name == itemToDispense then
            available_stock = available_stock + item.count
            table.insert(source_slots, {slot=slot, count=item.count})
        end
    end
    logActivity("Found " .. available_stock .. " available in " .. #source_slots .. " stack(s).")

    if available_stock < count then
        logActivity("Insufficient stock in vault.", true)
        rednet.send(atmId, { success = false, reason = "Insufficient stock in vault." }, protocol)
        return
    end

    -- === Phase 2: Preparation ===
    depositToVault(vault_side) -- Empty turtle
    for i = 1, 16 do -- Pre-flight check
        if turtle.getItemCount(i) > 0 then
            logActivity("Pre-flight check failed: Turtle inventory not empty.", true)
            rednet.send(atmId, { success = false, reason = "Clerk inventory malfunction." }, protocol)
            return
        end
    end
    logActivity("Pre-flight check passed: Turtle inventory is empty.")

    -- === Phase 3: Item Collection Loop ===
    local remaining = count
    for _, source in ipairs(source_slots) do
        local amountToPull = math.min(remaining, source.count)
        
        local success = false
        if vault_side == "top" then success = turtle.pullUp(source.slot, amountToPull)
        elseif vault_side == "bottom" then success = turtle.pullDown(source.slot, amountToPull)
        else
            turnTo(vault_side)
            -- NOTE: turtle.pull() does not exist. We must use the peripheral call for this.
            -- This is the one case where the peripheral API is needed.
            local pullTarget = opposite_sides[vault_side]
            local pulled, reason = peripheral.call(vault_side, "pullItems", pullTarget, source.slot, amountToPull)
            success = pulled and pulled > 0
        end

        if not success then
            logActivity("Failed to pull items from slot " .. source.slot, true)
            depositToVault(vault_side) -- Return anything we collected
            rednet.send(atmId, { success = false, reason = "A vault hardware error occurred." }, protocol)
            return
        end
        
        remaining = remaining - amountToPull
        if remaining <= 0 then break end
    end

    -- === Phase 4: Final Verification and Dispense ===
    local pulledAmount = 0
    for i=1,16 do pulledAmount = pulledAmount + turtle.getItemCount(i) end

    if pulledAmount < count then
        logActivity("Verification failed. Did not collect enough items.", true)
        depositToVault(vault_side) -- Return everything
        rednet.send(atmId, { success = false, reason = "Item collection failed." }, protocol)
        return
    end

    returnItemsToDeposit(deposit_side)
    rednet.send(atmId, { success = true }, protocol)
    logActivity("Successfully dispensed " .. count .. " of " .. itemToDispense)
end

--==============================================================================
-- Main Program Loop
--==============================================================================

local function main()
    term.clear(); term.setCursorPos(1,1)
    local modem_side, deposit_side, vault_side, err = findPeripherals()
    if err then
        print("Fatal Error: " .. err); return
    end

    -- THE FIX: Add a diagnostic report on startup.
    print("--- Configuration Report ---")
    print("Modem found on: " .. modem_side)
    print("Deposit Barrel found on: " .. deposit_side)
    print("Vault Inventory found on: " .. vault_side)
    local pull_target = opposite_sides[vault_side]
    if pull_target then
        print("Withdrawal Target Name: '" .. pull_target .. "'")
        print("This means the vault expects to push items to its '"..pull_target.."' side.")
    else
        print("ERROR: Could not determine withdrawal target!")
    end
    print("----------------------------")
    print("System starting in 5 seconds...")
    sleep(5)

    rednet.open(modem_side)
    rednet.host(protocol, "bank_turtle") 
    logActivity("Vault Clerk Turtle online (ID " .. os.getComputerID() .. "). Waiting for commands...")

    while true do
        local senderId, message, proto = rednet.receive()
        if message and message.type and proto == protocol then
            if message.type == "request_deposit" then
                handleDeposit(senderId, deposit_side, vault_side)
            elseif message.type == "request_dispense" then
                handleDispense(senderId, message.item_name, message.count, vault_side, deposit_side)
            end
        end
    end
end

main()
