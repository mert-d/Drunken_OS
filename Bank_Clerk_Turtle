--[[
    Drunken Beard Bank - Vault Clerk Turtle (v4.1 - Definitive Peripheral Fix)
    by Gemini Gem & MuhendizBey

    Purpose:
    This definitive version of the clerk turtle is fully compliant with the
    server's transactional architecture. Its sole responsibility is the physical
    movement of items between the deposit barrel and the vault, based on trusted
    commands from the ATM.

    Changelog:
    v4.1:
    - Fixed a critical bug in 'handleDispense' where a hardcoded target name
      ("turtle") was used for peripheral.pullItems.
    - The target name is now dynamically and reliably determined by calculating
      the opposite side of the vault peripheral, making the turtle's orientation
      flexible.
    v4.0:
    - Re-engineered 'handleDispense' to be a "dumb" agent; it no longer checks
      for stock, as authorization is now handled by the server.
    - Upgraded dispense logic to intelligently pull a requested amount from
      multiple stacks within the vault.
    - Added better error handling and logging.
    v3.7:
    - Initial stable version with bug fixes for peripheral APIs.
]]

--==============================================================================
-- Configuration
--==============================================================================

local protocol = "DB_ATM_Turtle"
local depositBlockName = "minecraft:barrel"

--==============================================================================
-- Core Functions (Definitive Version)
--==============================================================================

local function logActivity(msg, isError)
    if isError then
        print("ERROR: " .. msg)
    else
        print(msg)
    end
end

local function findPeripherals()
    print("Scanning for peripherals...")
    
    local modem_side = peripheral.find("modem")
    if not modem_side then return nil, nil, nil, "No wireless modem attached." end
    modem_side = peripheral.getName(modem_side)
    print("Found Modem on: " .. modem_side)

    local deposit_side = peripheral.find(depositBlockName)
    if not deposit_side then return nil, nil, nil, "Could not find Deposit Barrel." end
    deposit_side = peripheral.getName(deposit_side)
    print("Found Deposit Barrel on: " .. deposit_side)

    local vault_side = nil
    for _, name in ipairs(peripheral.getNames()) do
        if name ~= modem_side and name ~= deposit_side then
            if peripheral.hasType(name, "inventory") then
                vault_side = name
                print("Dynamically found Vault (".. peripheral.getType(name) ..") on: " .. vault_side)
                break
            end
        end
    end

    if not vault_side then
        return nil, nil, nil, "Could not find a valid vault inventory peripheral."
    end
    
    return modem_side, deposit_side, vault_side, nil
end

local function turnTo(targetSide)
    if targetSide == "left" then turtle.turnLeft()
    elseif targetSide == "right" then turtle.turnRight()
    elseif targetSide == "back" then turtle.turnRight(); turtle.turnRight() end
end

local function turnToFront(originalSide)
    if originalSide == "left" then turtle.turnRight()
    elseif originalSide == "right" then turtle.turnLeft()
    elseif originalSide == "back" then turtle.turnLeft(); turtle.turnLeft() end
end

local function collectFromDeposit(deposit_side)
    turnTo(deposit_side)
    for i = 1, 16 do turtle.select(i); turtle.suck() end
    turnToFront(deposit_side)
end

local function depositToVault(vault_side)
    turnTo(vault_side)
    for i = 1, 16 do
        turtle.select(i)
        if turtle.getItemCount(i) > 0 then turtle.drop() end
    end
    turnToFront(vault_side)
end

local function returnItemsToDeposit(deposit_side)
    turnTo(deposit_side)
    for i = 1, 16 do
        turtle.select(i)
        if turtle.getItemCount(i) > 0 then turtle.drop() end
    end
    turnToFront(deposit_side)
end

local function handleDeposit(atmId, deposit_side, vault_side)
    collectFromDeposit(deposit_side)
    
    local itemsInTurtle = {}
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item then
            table.insert(itemsInTurtle, { name = item.name, count = item.count })
        end
    end

    rednet.send(atmId, { type = "deposit_count", items = itemsInTurtle }, protocol)
    local _, message = rednet.receive(protocol, 15)

    if message and message.type == "confirm_deposit" then
        depositToVault(vault_side)
        rednet.send(atmId, { success = true, new_balance = message.new_balance }, protocol)
        logActivity("Successfully processed deposit.")
    else
        returnItemsToDeposit(deposit_side)
        rednet.send(atmId, { success = false, reason = "Deposit cancelled or timed out by ATM." }, protocol)
        logActivity("Deposit failed. Returned items to barrel.")
    end
end

local function handleDispense(atmId, itemToDispense, count, vault_side, deposit_side)
    local vault = peripheral.wrap(vault_side)
    if not vault then
        rednet.send(atmId, { success = false, reason = "Clerk could not access vault." }, protocol)
        return
    end

    -- Clear the turtle's inventory to make space.
    depositToVault(vault_side)

    -- THE FIX: Determine the correct peripheral name for the turtle's inventory
    -- from the vault's perspective. It's always the opposite side.
    local opposite_sides = { top="bottom", bottom="top", left="right", right="left", front="back", back="front" }
    local pullTarget = opposite_sides[vault_side]
    
    if not pullTarget then
        logActivity("Cannot determine pull target for vault on side: " .. tostring(vault_side), true)
        rednet.send(atmId, { success = false, reason = "Clerk has invalid vault configuration." }, protocol)
        return
    end

    local remaining = count
    local slots = vault.list()
    
    for slot, item in pairs(slots) do
        if item.name == itemToDispense then
            local amountToPull = math.min(remaining, item.count)
            local pulled, reason = vault.pullItems(pullTarget, slot, amountToPull)
            
            if not pulled or pulled < amountToPull then
                logActivity("Failed to pull " .. amountToPull .. " of " .. itemToDispense .. ": " .. tostring(reason), true)
                depositToVault(vault_side) -- Return any partially collected items.
                rednet.send(atmId, { success = false, reason = "A vault hardware error occurred." }, protocol)
                return
            end
            
            remaining = remaining - pulled
            if remaining <= 0 then break end
        end
    end

    if remaining > 0 then
        logActivity("Could not find enough " .. itemToDispense .. " in the vault.", true)
        depositToVault(vault_side) -- Return what we did manage to pull.
        rednet.send(atmId, { success = false, reason = "Vault stock count was incorrect." }, protocol)
        return
    end

    returnItemsToDeposit(deposit_side)
    rednet.send(atmId, { success = true }, protocol)
    logActivity("Successfully dispensed " .. count .. " of " .. itemToDispense)
end

--==============================================================================
-- Main Program Loop
--==============================================================================

local function main()
    local modem_side, deposit_side, vault_side, err = findPeripherals()
    if err then
        print("Fatal Error: " .. err); return
    end

    rednet.open(modem_side)
    rednet.host(protocol, "bank_turtle") 
    print("Vault Clerk Turtle online (ID " .. os.getComputerID() .. "). Waiting for commands...")

    while true do
        local senderId, message, proto = rednet.receive()
        if message and message.type and proto == protocol then
            if message.type == "ping" then
                rednet.send(senderId, { type = "pong" }, protocol)
            elseif message.type == "request_deposit" then
                handleDeposit(senderId, deposit_side, vault_side)
            elseif message.type == "request_dispense" then
                handleDispense(senderId, message.item_name, message.count, vault_side, deposit_side)
            end
        end
    end
end

main()
