--[[
    Drunken Beard Bank - Vault Clerk Turtle (v5.1 - Pre-flight Check)
    by Gemini Gem & MuhendizBey

    Purpose:
    This version adds a rigorous pre-flight check to the withdrawal process,
    ensuring the turtle's inventory is completely empty before attempting to
    pull new items from the vault. This helps diagnose inventory-full errors.

    Changelog:
    v5.1:
    - Added a pre-flight check to 'handleDispense' that verifies the turtle's
      inventory is empty before proceeding with a withdrawal.
    v5.0:
    - Complete redesign of 'handleDispense' to use 'turtle.suck()' as a
      workaround for a persistent peripheral bug.
]]

--==============================================================================
-- Configuration
--==============================================================================

local protocol = "DB_ATM_Turtle"
local depositBlockName = "minecraft:barrel"

-- A table to map a side to its opposite.
local opposite_sides = {
    top = "bottom", bottom = "top",
    left = "right", right = "left",
    front = "back", back = "front"
}

--==============================================================================
-- Core Functions
--==============================================================================

local function logActivity(msg, isError)
    local prefix = os.date("[%H:%M:%S] ")
    if isError then
        print(prefix .. "ERROR: " .. msg)
    else
        print(prefix .. msg)
    end
end

local function findPeripherals()
    logActivity("Scanning for peripherals...")
    
    local modem_side = peripheral.find("modem")
    if not modem_side then return nil, nil, nil, "No wireless modem attached." end
    modem_side = peripheral.getName(modem_side)

    local deposit_side = peripheral.find(depositBlockName)
    if not deposit_side then return nil, nil, nil, "Could not find Deposit Barrel." end
    deposit_side = peripheral.getName(deposit_side)

    local vault_side = nil
    for _, name in ipairs(peripheral.getNames()) do
        if name ~= modem_side and name ~= deposit_side then
            if peripheral.hasType(name, "inventory") then
                vault_side = name
                break
            end
        end
    end

    if not vault_side then
        return nil, nil, nil, "Could not find a valid vault inventory peripheral."
    end
    
    return modem_side, deposit_side, vault_side, nil
end

-- (Movement and basic inventory functions are unchanged)
local function turnTo(targetSide)
    if targetSide == "left" then turtle.turnLeft()
    elseif targetSide == "right" then turtle.turnRight()
    elseif targetSide == "back" then turtle.turnRight(); turtle.turnRight() end
end

local function turnToFront(originalSide)
    if originalSide == "left" then turtle.turnRight()
    elseif originalSide == "right" then turtle.turnLeft()
    elseif originalSide == "back" then turtle.turnLeft(); turtle.turnLeft() end
end

local function collectFromDeposit(deposit_side)
    turnTo(deposit_side)
    for i = 1, 16 do turtle.select(i); turtle.suck() end
    turnToFront(deposit_side)
end

local function depositToVault(vault_side)
    turnTo(vault_side)
    for i = 1, 16 do
        turtle.select(i)
        if turtle.getItemCount(i) > 0 then turtle.drop() end
    end
    turnToFront(vault_side)
end

local function returnItemsToDeposit(deposit_side)
    turnTo(deposit_side)
    for i = 1, 16 do
        turtle.select(i)
        if turtle.getItemCount(i) > 0 then turtle.drop() end
    end
    turnToFront(deposit_side)
end

-- (handleDeposit is unchanged)
local function handleDeposit(atmId, deposit_side, vault_side)
    collectFromDeposit(deposit_side)
    local itemsInTurtle = {}
    for i = 1, 16 do
        local item = turtle.getItemDetail(i)
        if item then table.insert(itemsInTurtle, { name = item.name, count = item.count }) end
    end
    rednet.send(atmId, { type = "deposit_count", items = itemsInTurtle }, protocol)
    local _, message = rednet.receive(protocol, 15)
    if message and message.type == "confirm_deposit" then
        depositToVault(vault_side)
        rednet.send(atmId, { success = true, new_balance = message.new_balance }, protocol)
        logActivity("Successfully processed deposit.")
    else
        returnItemsToDeposit(deposit_side)
        rednet.send(atmId, { success = false, reason = "Deposit cancelled or timed out by ATM." }, protocol)
        logActivity("Deposit failed. Returned items to barrel.")
    end
end

local function handleDispense(atmId, itemToDispense, count, vault_side, deposit_side)
    logActivity("Initiating 'Targeted Suck' withdrawal.")

    -- 1. Empty the turtle's inventory.
    depositToVault(vault_side)

    -- 2. THE FIX: Pre-flight Check - Verify the turtle is actually empty.
    for i = 1, 16 do
        if turtle.getItemCount(i) > 0 then
            logActivity("Pre-flight check failed: Turtle inventory not empty at slot " .. i, true)
            rednet.send(atmId, { success = false, reason = "Clerk inventory malfunction." }, protocol)
            return
        end
    end
    logActivity("Pre-flight check passed: Turtle inventory is empty.")

    -- 3. Proceed with the withdrawal logic from v5.0
    turnTo(vault_side)

    local vault = peripheral.wrap(vault_side)
    local first_slot_item = vault.getItemDetail(1)

    if not first_slot_item or first_slot_item.name ~= itemToDispense then
        logActivity("Item in slot 1 does not match requested item.", true)
        logActivity("Expected '"..itemToDispense.."' but found '"..(first_slot_item and first_slot_item.name or "nothing").."'", true)
        rednet.send(atmId, { success = false, reason = "Incorrect item in vault slot 1." }, protocol)
        turnToFront(vault_side)
        return
    end

    if first_slot_item.count < count then
        logActivity("Item in slot 1 has insufficient stock.", true)
        logActivity("Requested " .. count .. " but found " .. first_slot_item.count, true)
        rednet.send(atmId, { success = false, reason = "Insufficient stock in vault slot 1." }, protocol)
        turnToFront(vault_side)
        return
    end

    local pulled = turtle.suck(count)
    turnToFront(vault_side)

    if not pulled or pulled < count then
        logActivity("Failed to suck the required number of items.", true)
        depositToVault(vault_side) -- Attempt to return whatever was pulled
        rednet.send(atmId, { success = false, reason = "A vault hardware error occurred." }, protocol)
        return
    end
    
    returnItemsToDeposit(deposit_side)
    rednet.send(atmId, { success = true }, protocol)
    logActivity("Successfully dispensed " .. count .. " of " .. itemToDispense)
end

--==============================================================================
-- Main Program Loop
--==============================================================================

local function main()
    term.clear(); term.setCursorPos(1,1)
    local modem_side, deposit_side, vault_side, err = findPeripherals()
    if err then
        print("Fatal Error: " .. err); return
    end

    -- THE FIX: Add a diagnostic report on startup.
    print("--- Configuration Report ---")
    print("Modem found on: " .. modem_side)
    print("Deposit Barrel found on: " .. deposit_side)
    print("Vault Inventory found on: " .. vault_side)
    local pull_target = opposite_sides[vault_side]
    if pull_target then
        print("Withdrawal Target Name: '" .. pull_target .. "'")
        print("This means the vault expects to push items to its '"..pull_target.."' side.")
    else
        print("ERROR: Could not determine withdrawal target!")
    end
    print("----------------------------")
    print("System starting in 5 seconds...")
    sleep(5)

    rednet.open(modem_side)
    rednet.host(protocol, "bank_turtle") 
    logActivity("Vault Clerk Turtle online (ID " .. os.getComputerID() .. "). Waiting for commands...")

    while true do
        local senderId, message, proto = rednet.receive()
        if message and message.type and proto == protocol then
            if message.type == "request_deposit" then
                handleDeposit(senderId, deposit_side, vault_side)
            elseif message.type == "request_dispense" then
                handleDispense(senderId, message.item_name, message.count, vault_side, deposit_side)
            end
        end
    end
end

main()
