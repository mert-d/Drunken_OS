--[[
    Drunken Beard Bank - ATM Terminal (v4.17 - Graphical UI Upgrade)
    by Gemini Gem & MuhendizBey

    Purpose:
    This version implements a full graphical user interface overhaul, inspired
    by the Drunken OS Bank Server's UI. It provides a more professional and
    visually appealing user experience.

    Key Changes:
    - Added a theme table to easily manage colors.
    - Created a new 'drawFrame' function to draw window borders and titles.
    - Re-engineered 'showMessage' and 'drawMenu' to operate within the new
      graphical framework.
    - All core banking and networking logic is preserved from v4.16.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local card_data = nil -- This will be populated by runSession
local balance = 0
local currencyRates = {}

local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- UI & Theme (Preserved from original baseline)
--==============================================================================

-- A theme table to make color changes simple and consistent.
local theme = {
    bg = colors.black,
    text = colors.white,
    border = colors.gray,
    titleBg = colors.gray,
    titleText = colors.white,
    highlightBg = colors.blue,
    highlightText = colors.white,
    errorBg = colors.red,
    errorText = colors.white,
}

-- A helper function to draw a graphical window frame and title.
local function drawFrame(title)
    local w, h = term.getSize()
    
    -- Draw the background
    term.setBackgroundColor(theme.bg)
    term.clear()

    -- Draw borders
    term.setBackgroundColor(theme.border)
    for y = 1, h do
        term.setCursorPos(1, y)
        term.write(" ")
        term.setCursorPos(w, y)
        term.write(" ")
    end
    for x = 1, w do
        term.setCursorPos(x, 1)
        term.write(" ")
        term.setCursorPos(x, h)
        term.write(" ")
    end

    -- Draw Title bar
    term.setBackgroundColor(theme.titleBg)
    term.setTextColor(theme.titleText)
    local titleText = " " .. (title or "Drunken Beard Bank") .. " "
    local titleStart = math.floor((w - #titleText) / 2)
    term.setCursorPos(titleStart, 1)
    term.write(titleText)

    -- Reset colors for content
    term.setBackgroundColor(theme.bg)
    term.setTextColor(theme.text)
end

-- A helper function to print centered text within the frame
local function printCentered(y, text)
    local w, h = term.getSize()
    local x = math.floor((w - #text) / 2)
    term.setCursorPos(x, y)
    term.write(text)
end

-- Reworked to use the new graphical frame
local function showMessage(title, message, isError)
    local w, h = term.getSize()
    
    local boxBg = isError and theme.errorBg or theme.titleBg
    local boxText = isError and theme.errorText or theme.titleText
    
    -- Draw a smaller box for the message
    local boxW, boxH = math.floor(w * 0.8), math.floor(h * 0.6)
    local boxX, boxY = math.floor((w - boxW) / 2), math.floor((h - boxH) / 2)

    term.setBackgroundColor(boxBg)
    for y = boxY, boxY + boxH - 1 do
        term.setCursorPos(boxX, y)
        term.write(string.rep(" ", boxW))
    end
    
    term.setTextColor(boxText)
    local titleText = " " .. title .. " "
    term.setCursorPos(math.floor(w - #titleText) / 2, boxY + 1)
    term.write(titleText)
    
    -- Word wrap message inside the box
    local lines = {}
    local maxLen = boxW - 4
    for line in message:gmatch("[^\n]+") do
        while #line > maxLen do
            table.insert(lines, line:sub(1, maxLen))
            line = line:sub(maxLen + 1)
        end
        table.insert(lines, line)
    end

    for i, line in ipairs(lines) do
        term.setCursorPos(boxX + 2, boxY + 3 + i)
        print(line)
    end

    local continueText = "Press any key to continue..."
    term.setCursorPos(math.floor((w - #continueText) / 2), boxY + boxH - 2)
    print(continueText)
    
    os.pullEvent("key")
end

local function drawMenu(title, options, help)
    local w, h = term.getSize()
    local selected = 1
    
    while true do
        drawFrame(title)
        
        for i, opt in ipairs(options) do
            term.setCursorPos(4, 4 + i)
            if i == selected then
                term.setBackgroundColor(theme.highlightBg)
                term.setTextColor(theme.highlightText)
            else
                term.setBackgroundColor(theme.bg)
                term.setTextColor(theme.text)
            end
            term.write(" " .. opt .. string.rep(" ", w - 6 - #opt) .. " ") -- Add padding
        end

        term.setBackgroundColor(theme.bg)
        term.setTextColor(colors.yellow)
        if help then
            printCentered(h - 2, help)
        end
        
        local _, key = os.pullEvent("key")
        if key == keys.up then
            selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then
            selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then
            term.setBackgroundColor(theme.bg)
            term.setTextColor(theme.text)
            return selected
        elseif key == keys.q or key == keys.tab then
            return nil
        end
    end
end

--==============================================================================
-- Core Application Logic (from baseline, with targeted fixes)
--==============================================================================

local function login()
    clear()
    term.setCursorPos(1,1)
    print("Please enter your Drunken OS password.")
    write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)

    if not pass or pass == "" then return false end

    local pass_hash = crypto.hex(pass)

    if pass_hash == card_data.pass_hash then
        print("Password verified. Contacting bank server...")
        
        -- FIX #1: Send the verified hash to the server.
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = pass_hash }, BANK_PROTOCOL)
        
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            print("Login successful!")
            sleep(1)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.")
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.")
        return false
    end
end

local function deposit()
    clear()
    term.setCursorPos(1,1)
    print("Requesting deposit...")
    rednet.send(turtleClerkId, {type = "request_deposit"}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Deposit complete. Your new balance is $" .. balance)
    else
        showMessage("Deposit Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

local function withdraw()
    local options = {}
    local item_names = {}
    for name, data in pairs(currencyRates) do
        local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
        table.insert(options, string.format("%s ($%d)", clean_name, data.current))
        table.insert(item_names, name)
    end
    table.insert(options, "Cancel")
    
    local choice = drawMenu("Select Item to Withdraw", options, "Your balance: $" .. balance)
    if choice == nil or choice > #item_names then return end
    
    local item_name = item_names[choice]
    local rate = currencyRates[item_name].current

    clear()
    term.setCursorPos(1,1)
    print("How many " .. item_name:gsub("minecraft:", ""):gsub("_", " ") .. " would you like to withdraw?")
    write("> ")
    term.setCursorBlink(true)
    local amount_str = read()
    term.setCursorBlink(false)
    
    local amount = tonumber(amount_str)
    if not amount or amount <= 0 or (amount * rate > balance) then
        showMessage("Error", "Invalid amount or insufficient funds.")
        return
    end

    print("Requesting withdrawal of " .. amount .. " " .. item_name .. "...")
    rednet.send(turtleClerkId, {type = "request_dispense", item_name = item_name, count = amount}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Please collect your items. New balance: $" .. balance)
    else
        showMessage("Withdrawal Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

local function mainMenu()
    local drive = peripheral.find("drive")
    while true do
        local options = { "Check Balance / Rates", "Deposit Items", "Withdraw Items", "Exit" }
        local choice = drawMenu("ATM Main Menu", options, "Welcome, " .. username .. " | Balance: $" .. balance)

        if not choice or choice == 4 then break end
        
        if choice == 1 then
            clear(); term.setCursorPos(1,1); print("Current Exchange Rates:")
            local y = 3
            for name, data in pairs(currencyRates) do
                local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
                term.setCursorPos(2, y); print(string.format("1 %s = $%d", clean_name, data.current))
                y = y + 1
            end
            term.setCursorPos(2, y+1); print("Press any key to return...")
            os.pullEvent("key")
        elseif choice == 2 then deposit()
        elseif choice == 3 then withdraw()
        end
    end

    drive.ejectDisk()
    rednet.close("back")
    clear(); print("Thank you for banking with Drunken Beard Bank!")
    sleep(2)
end

local function runSession()
    local modem = peripheral.find("modem")
    if not modem then error("No modem attached.", 0) end
    rednet.open(peripheral.getName(modem))

    bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
    if not bankServerId then error("Could not find bank server.", 0) end
    
    turtleClerkId = rednet.lookup(TURTLE_CLERK_PROTOCOL, "bank_turtle")
    if not turtleClerkId then error("Could not find Vault Clerk turtle.", 0) end

    clear()
    print("Drunken Beard Bank")
    print("Please insert your bank card...")

    local drive = peripheral.find("drive")
    if not drive then error("No Disk Drive is attached to this terminal.", 0) end
    
    local event, p1 = os.pullEvent("disk")

    local disk_label = disk.getLabel(p1)
    if not disk_label or not disk_label:match("^DrunkenBeard_Card_.+") then
        showMessage("Card Error", "This is not a valid Drunken Beard Bank card.")
        disk.eject(p1)
        return
    end
    
    username = disk_label:match("^DrunkenBeard_Card_(.+)")
    local handle = fs.open(disk.getMountPath(p1) .. "/.card_data", "r")
    if not handle then
        showMessage("Card Error", "Card is missing its data file.")
        disk.eject(p1)
        return
    end

    local card_contents = handle.readAll()
    handle.close()
    local ok, data = pcall(textutils.unserialize, card_contents)

    if not ok or not data then
        showMessage("Card Error", "Card data is corrupt.")
        disk.eject(p1)
        return
    end
    
    -- FIX #2: Assign the data we just read to the main variable.
    card_data = data

    if login() then
        mainMenu()
    else
        disk.eject(p1)
        print("\nCard ejected.")
        sleep(2)
    end
end

--==============================================================================
-- Main Program Loop
--==============================================================================

while true do
    local ok, err = pcall(runSession)
    if not ok then
        local file = fs.open("atm_crash.log", "a")
        if file then
            file.writeLine(os.date() .. " - FATAL ERROR: " .. tostring(err))
            file.close()
        end
        
        -- Use the new UI for the crash screen too
        drawFrame("FATAL ERROR")
        term.setBackgroundColor(colors.red)
        term.setTextColor(colors.white)
        term.setCursorPos(2, 4)
        print("A fatal error occurred. The ATM will reboot.")
        term.setCursorPos(2, 6)
        print(tostring(err))
        sleep(5)
        os.reboot()
    end
end

