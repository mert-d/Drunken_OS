--[[
    Drunken Beard Bank - ATM Terminal (v4.3 - Refactored Crypto)
    by Gemini Gem

    Purpose:
    This version refactors the cryptographic functions into the new, separate
    `lib/sha1_hmac.lua` library. This is the final step in modularizing the
    entire OS.

    Key Changes:
    - Removed the embedded SHA1 library block.
    - Added a `require()` call to the new `lib/sha1_hmac` library.
    - Updated password hashing calls to use the new crypto library.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

-- It is assumed the `sha1_hmac` library is available, as the user would
-- typically install it with the main Drunken_OS_Client first.
local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local balance = 0
local currencyRates = {}

-- Rednet protocols
local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- UI & Theme
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then return colors[colorName] end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    title = safeColor("lightBlue", colors.lightBlue),
    prompt = safeColor("cyan", colors.cyan),
    highlightBg = safeColor("blue", colors.blue),
    highlightText = safeColor("white", colors.white),
    error = safeColor("red", colors.red),
}

local function getSafeSize() local w, h = term.getSize(); while not w or not h do sleep(0.05); w, h = term.getSize() end; return w, h end
local function wordWrap(text, width)
    local finalLines = {}
    for line in string.gmatch(text, "[^\n]+") do
        if #line <= width then
            table.insert(finalLines, line)
        else
            local currentWrappedLine = ""
            for word in string.gmatch(line, "[^%s]+") do
                if #currentWrappedLine + #word + 1 > width then
                    table.insert(finalLines, currentWrappedLine)
                    currentWrappedLine = word
                else
                    currentWrappedLine = currentWrappedLine == "" and word or (currentWrappedLine .. " " .. word)
                end
            end
            table.insert(finalLines, currentWrappedLine)
        end
    end
    return finalLines
end
local function clear() term.setBackgroundColor(theme.bg); term.clear(); term.setCursorPos(1, 1) end
local function drawWindow(title)
    clear()
    local w, h = getSafeSize()
    term.setBackgroundColor(theme.windowBg); for y = 1, h do term.setCursorPos(1, y); term.write(string.rep(" ", w)) end
    term.setBackgroundColor(theme.title); term.setCursorPos(1, 1); term.write(string.rep(" ", w)); term.setTextColor(colors.white)
    local titleText = " " .. title .. " "; term.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1); term.write(titleText)
    term.setBackgroundColor(theme.windowBg); term.setTextColor(theme.text)
end
local function drawMenu(options, selectedIndex, startX, startY)
    for i, option in ipairs(options) do
        term.setCursorPos(startX, startY + i - 1)
        if i == selectedIndex then
            term.setBackgroundColor(theme.highlightBg); term.setTextColor(theme.highlightText)
            term.write("> " .. option)
        else
            term.setBackgroundColor(theme.windowBg); term.setTextColor(theme.text)
            term.write("  " .. option)
        end
    end
    term.setBackgroundColor(theme.windowBg)
end
local function showMessage(title, message, isError)
    drawWindow(title)
    local w, h = getSafeSize()
    if isError then term.setTextColor(theme.error) else term.setTextColor(theme.text) end
    local lines = wordWrap(message, w - 4)
    for i, line in ipairs(lines) do term.setCursorPos(3, 4 + i - 1); term.write(line) end
    term.setCursorPos(3, 4 + #lines + 1); term.setTextColor(theme.prompt); term.write("Press any key to continue..."); os.pullEvent("key"); term.setTextColor(theme.text)
end
local function readInput(prompt, y, hideText)
    local x = 2; term.setTextColor(theme.prompt); term.setCursorPos(x, y); term.write(prompt); term.setTextColor(theme.text)
    term.setCursorPos(x + #prompt, y); term.setCursorBlink(true)
    local input = hideText and read("*") or read()
    term.setCursorBlink(false); return input
end

--==============================================================================
-- Banking Functions
--==============================================================================

local function login()
    clear()
    term.setCursorPos(1,1)
    print("Please enter your Drunken OS password.")
    write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)

    if not pass or pass == "" then return false end

    local pass_hash = crypto.hex(pass)

    if pass_hash == card_data.pass_hash then
        print("Password verified. Contacting bank server...")
        
        -- THE ONLY CHANGE IS HERE. We now send the verified hash to the server.
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = pass_hash }, BANK_PROTOCOL)
        
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            print("Login successful!")
            sleep(1)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.")
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.")
        return false
    end
end

local function deposit()
    clear()
    term.setCursorPos(1,1)
    print("Requesting deposit...")
    rednet.send(turtleClerkId, {type = "request_deposit"}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Deposit complete. Your new balance is $" .. balance)
    else
        showMessage("Deposit Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

local function withdraw()
    local options = {}
    local item_names = {}
    for name, data in pairs(currencyRates) do
        local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
        table.insert(options, string.format("%s ($%d)", clean_name, data.current))
        table.insert(item_names, name)
    end
    table.insert(options, "Cancel")
    
    local choice = drawMenu("Select Item to Withdraw", options, "Your balance: $" .. balance)
    if choice == nil or choice > #item_names then return end
    
    local item_name = item_names[choice]
    local rate = currencyRates[item_name].current

    clear()
    term.setCursorPos(1,1)
    print("How many " .. item_name:gsub("minecraft:", ""):gsub("_", " ") .. " would you like to withdraw?")
    write("> ")
    term.setCursorBlink(true)
    local amount_str = read()
    term.setCursorBlink(false)
    
    local amount = tonumber(amount_str)
    if not amount or amount <= 0 or (amount * rate > balance) then
        showMessage("Error", "Invalid amount or insufficient funds.")
        return
    end

    print("Requesting withdrawal of " .. amount .. " " .. item_name .. "...")
    rednet.send(turtleClerkId, {type = "request_dispense", item_name = item_name, count = amount}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Please collect your items. New balance: $" .. balance)
    else
        showMessage("Withdrawal Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

--==============================================================================
-- Main Program Logic
--==============================================================================

local function runSession()
    local drive = peripheral.find("drive")
    if not drive then
        showMessage("ATM Error", "No disk drive attached.", true)
        return
    end

    rednet.open("back")
    drawWindow("Connecting..."); term.setCursorPos(2, 4); term.write("Finding Bank Server...")
    bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
    if not bankServerId then
        showMessage("Error", "Could not connect to the bank server.", true)
        rednet.close("back"); return
    end
    
    term.setCursorPos(2, 5); term.write("Finding Vault Clerk...")
    turtleClerkId = rednet.lookup(TURTLE_CLERK_PROTOCOL)
    if not turtleClerkId then
        showMessage("Error", "Could not connect to the vault clerk.", true)
        rednet.close("back"); return
    end

    drawWindow("Drunken Beard Bank")
    term.setCursorPos(2, 4); term.write("Please insert your bank card...")
    
    local user_from_card = nil
    while not user_from_card do
        local event, side = os.pullEvent("disk")
        
        if drive.isDiskPresent() then
            local mount_path = drive.getMountPath()
            if mount_path and fs.exists(mount_path .. "/.bankcard") then
                local file = fs.open(mount_path .. "/.bankcard", "r")
                if file then
                    user_from_card = file.readAll()
                    file.close()
                end
            end
        end
    end
    
    if not login(user_from_card) then
        drive.ejectDisk()
        showMessage("Login Failed", "Please take your card.", true)
        rednet.close("back"); return
    end

    -- Fetch latest rates after successful login
    rednet.send(bankServerId, { type = "get_balance_and_rates", user = username }, BANK_PROTOCOL)
    local _, response = rednet.receive(BANK_PROTOCOL, 5)
    if response then
        balance = response.balance or balance
        currencyRates = response.rates or {}
    end

    local options = {"View Balance & Rates", "Deposit", "Withdraw", "Exit"}
    local selected = 1
    while true do
        drawWindow("Drunken Beard Bank")
        term.setCursorPos(2, 4); term.write("Welcome, " .. username)
        term.setCursorPos(2, 5); term.write("Current Balance: $" .. balance)
        drawMenu(options, selected, 2, 8)
        
        local event, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then
            if selected == 1 then
                rednet.send(bankServerId, { type = "get_balance_and_rates", user = username }, BANK_PROTOCOL)
                local _, rate_response = rednet.receive(BANK_PROTOCOL, 5)
                if rate_response and rate_response.balance then
                    balance = rate_response.balance
                    currencyRates = rate_response.rates
                    drawWindow("Balance & Rates")
                    term.setCursorPos(2, 4); term.write("Current Balance: $" .. balance)
                    term.setCursorPos(2, 6); term.write("--- Live Exchange Rates ---")
                    local y = 7
                    for item, data in pairs(currencyRates) do
                        local name = item:gsub("minecraft:", ""):gsub("_", " ")
                        term.setCursorPos(2, y); term.write(string.format("1 %s = $%d", name, data.current))
                        y = y + 1
                    end
                    term.setCursorPos(2, y+1); term.write("Press any key to return...")
                    os.pullEvent("key")
                end
            elseif selected == 2 then deposit()
            elseif selected == 3 then withdraw()
            elseif selected == 4 then break end
        elseif key == keys.tab or key == keys.q then break end
    end

    drive.ejectDisk()
    rednet.close("back")
    clear(); print("Thank you for banking with Drunken Beard Bank!")
    sleep(2) -- Pause before the program reboots
end

--==============================================================================
-- Main Program Loop
--==============================================================================

while true do
    local ok, err = pcall(runSession)
    if not ok then
        -- If an error occurred, log it and reboot
        local file = fs.open("atm_crash.log", "a")
        if file then
            file.writeLine(os.date() .. " - FATAL ERROR: " .. tostring(err))
            file.close()
        end
        
        clear()
        term.setTextColor(colors.red)
        print("A fatal error occurred. The ATM will now reboot.")
        print(err)
        sleep(5)
        os.reboot()
    end
    -- If the session ended normally (user exited), the loop will just restart
end
