--[[
    Drunken Beard Bank - ATM Terminal (v4.17 - Transactional Client)
    by Gemini Gem & MuhendizBey

    Purpose:
    This definitive version implements the client-side logic for the new
    transactional withdrawal system, ensuring funds are only deducted
    after a successful physical item transfer.

    Key Changes:
    - The `withdraw` function is now a multi-stage process.
    - It first requests authorization from the server.
    - If authorized, it commands the turtle to dispense items.
    - If the turtle succeeds, it sends a finalization request to the server.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local card_data = nil -- This will be populated by runSession
local balance = 0
local currencyRates = {}

local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- UI & Theme (Preserved from original v4.3)
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(c) if hasColor then return c else return colors.white end end

local function clear() term.setBackgroundColor(colors.black); term.clear() end

local function showMessage(title, message)
    local w, h = term.getSize()
    local bg = hasColor and colors.red or colors.gray
    local text = hasColor and colors.white or colors.black
    
    term.setBackgroundColor(bg)
    term.setTextColor(text)
    term.clear()
    term.setCursorPos(1,1)
    
    local titleText = " " .. title .. " "
    term.setCursorPos(math.floor((w - #titleText) / 2), 2)
    print(titleText)

    local lines = {}
    for line in message:gmatch("[^\n]+") do
        while #line > w - 4 do
            table.insert(lines, line:sub(1, w - 4))
            line = line:sub(w - 3)
        end
        table.insert(lines, line)
    end

    for i, line in ipairs(lines) do
        term.setCursorPos(3, 4 + i)
        print(line)
    end

    term.setCursorPos(3, 5 + #lines)
    print("Press any key to continue...")
    os.pullEvent("key")
end

local function drawMenu(title, options, help)
    local w, h = term.getSize()
    local selected = 1
    while true do
        term.setBackgroundColor(colors.black)
        term.clear()
        term.setCursorPos(1,1)
        term.setTextColor(colors.yellow)
        print(title)
        term.setCursorPos(1,2)
        print(string.rep("-", #title))
        
        for i, opt in ipairs(options) do
            term.setCursorPos(3, 3 + i)
            if i == selected then
                term.setTextColor(colors.black)
                term.setBackgroundColor(colors.white)
            else
                term.setTextColor(colors.white)
                term.setBackgroundColor(colors.black)
            end
            term.write(opt)
        end

        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.gray)
        term.setCursorPos(1, h)
        term.write(help or "Use UP/DOWN and ENTER to select.")

        local event, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then return selected
        elseif key == keys.tab or key == keys.q then return nil
        end
    end
end

--==============================================================================
-- Core Application Logic (from v4.3, with one fix)
--==============================================================================

local function login()
    clear()
    term.setCursorPos(1,1)
    print("Please enter your Drunken OS password.")
    write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)

    if not pass or pass == "" then return false end

    local pass_hash = crypto.hex(pass)

    if pass_hash == card_data.pass_hash then
        print("Password verified. Contacting bank server...")
        
        -- THE ONLY CHANGE IS HERE. We now send the verified hash to the server.
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = pass_hash }, BANK_PROTOCOL)
        
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            print("Login successful!")
            sleep(1)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.")
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.")
        return false
    end
end

local function deposit()
    clear()
    term.setCursorPos(1,1)
    print("Requesting deposit...")
    rednet.send(turtleClerkId, {type = "request_deposit"}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Deposit complete. Your new balance is $" .. balance)
    else
        showMessage("Deposit Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

local function withdraw()
    local options = {}
    local item_names = {}
    for name, data in pairs(currencyRates) do
        local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
        table.insert(options, string.format("%s ($%d)", clean_name, data.current))
        table.insert(item_names, name)
    end
    table.insert(options, "Cancel")
    
    local choice = drawMenu("Select Item to Withdraw", options, "Your balance: $" .. balance)
    if choice == nil or choice > #item_names then return end
    
    local item_name = item_names[choice]
    
    term.clear(); term.setCursorPos(1,1)
    print("How many " .. item_name:gsub("minecraft:", ""):gsub("_", " ") .. " would you like to withdraw?")
    write("> ")
    term.setCursorBlink(true)
    local amount_str = read()
    term.setCursorBlink(false)
    
    local amount = tonumber(amount_str)
    if not amount or amount <= 0 then
        showMessage("Error", "Invalid amount.")
        return
    end

    -- PHASE 1: Request Authorization
    print("Contacting bank to authorize transaction...")
    rednet.send(bankServerId, {
        type = "withdraw_item", user = username,
        item_name = item_name, count = amount
    }, BANK_PROTOCOL)
    local _, authResponse = rednet.receive(BANK_PROTOCOL, 10)

    if not authResponse or not authResponse.authorized then
        showMessage("Transaction Denied", (authResponse and authResponse.reason) or "No response from server.")
        return
    end

    -- PHASE 2: Command Turtle
    print("Authorization received. Commanding clerk...")
    rednet.send(turtleClerkId, {
        type = "request_dispense", item_name = item_name, count = amount
    }, TURTLE_CLERK_PROTOCOL)
    local _, turtleResponse = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)

    if not turtleResponse or not turtleResponse.success then
        showMessage("Withdrawal Failed", (turtleResponse and turtleResponse.reason) or "Clerk did not respond.")
        return
    end

    -- PHASE 3: Finalize Transaction
    print("Items dispensed. Finalizing with bank...")
    rednet.send(bankServerId, {
        type = "finalize_withdrawal", user = username,
        item_name = item_name, count = amount
    }, BANK_PROTOCOL)
    local _, finalResponse = rednet.receive(BANK_PROTOCOL, 10)

    if finalResponse and finalResponse.success then
        balance = finalResponse.newBalance
        showMessage("Success", "Withdrawal complete. Your new balance is $" .. balance)
    else
        -- This is a critical error state. The user has the items, but the server
        -- failed to deduct the balance. This needs to be flagged.
        showMessage("CRITICAL ERROR", "Could not finalize transaction with server. Please contact an admin.")
    end
end

local function mainMenu()
    local drive = peripheral.find("drive")
    while true do
        local options = { "Check Balance / Rates", "Deposit Items", "Withdraw Items", "Exit" }
        local choice = drawMenu("ATM Main Menu", options, "Welcome, " .. username .. " | Balance: $" .. balance)

        if not choice or choice == 4 then break end
        
        if choice == 1 then
            clear(); term.setCursorPos(1,1); print("Current Exchange Rates:")
            local y = 3
            for name, data in pairs(currencyRates) do
                local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
                term.setCursorPos(2, y); print(string.format("1 %s = $%d", clean_name, data.current))
                y = y + 1
            end
            term.setCursorPos(2, y+1); print("Press any key to return...")
            os.pullEvent("key")
        elseif choice == 2 then deposit()
        elseif choice == 3 then withdraw()
        end
    end

    drive.ejectDisk()
    rednet.close("back")
    clear(); print("Thank you for banking with Drunken Beard Bank!")
    sleep(2)
end

local function runSession()
    local modem = peripheral.find("modem")
    if not modem then error("No modem attached.", 0) end
    rednet.open(peripheral.getName(modem))

    bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
    if not bankServerId then error("Could not find bank server.", 0) end
    
    turtleClerkId = rednet.lookup(TURTLE_CLERK_PROTOCOL, "bank_turtle")
    if not turtleClerkId then error("Could not find Vault Clerk turtle.", 0) end

    clear()
    print("Drunken Beard Bank")
    print("Please insert your bank card...")

    local drive = peripheral.find("drive")
    if not drive then error("No Disk Drive is attached to this terminal.", 0) end
    
    local event, p1 = os.pullEvent("disk")

    local disk_label = disk.getLabel(p1)
    if not disk_label or not disk_label:match("^DrunkenBeard_Card_.+") then
        showMessage("Card Error", "This is not a valid Drunken Beard Bank card.")
        disk.eject(p1)
        return
    end
    
    username = disk_label:match("^DrunkenBeard_Card_(.+)")
    local handle = fs.open(disk.getMountPath(p1) .. "/.card_data", "r")
    if not handle then
        showMessage("Card Error", "Card is missing its data file.")
        disk.eject(p1)
        return
    end

    local card_contents = handle.readAll()
    handle.close()
    local ok, data = pcall(textutils.unserialize, card_contents)

    if not ok or not data then
        showMessage("Card Error", "Card data is corrupt.")
        disk.eject(p1)
        return
    end
    
    card_data = data

    if login() then
        mainMenu()
    else
        disk.eject(p1)
        print("\nCard ejected.")
        sleep(2)
    end
end

--==============================================================================
-- Main Program Loop
--==============================================================================

while true do
    local ok, err = pcall(runSession)
    if not ok then
        local file = fs.open("atm_crash.log", "a")
        if file then
            file.writeLine(os.date() .. " - FATAL ERROR: " .. tostring(err))
            file.close()
        end
        
        clear()
        term.setTextColor(colors.red)
        print("A fatal error occurred. The ATM will now reboot.")
        print(err)
        sleep(5)
        os.reboot()
    end
end
