--[[
    Drunken Beard Bank - ATM Terminal (v5.4 - Type-Safe Login)
    by Gemini Gem & MuhendizBey

    Purpose:
    This version provides a hotfix to the login function to make it robust
    against data type mismatches, ensuring passwords that look like numbers
    are handled correctly.

    Changelog:
    v5.4:
    - Hardened the 'login' function by converting both password hashes to strings
      before comparison. This fixes a bug where numeric passwords would fail
      due to type mismatches from the bank card's data file.
    v5.3:
    - Implemented a modular pairing and setup system.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

local crypto = require("lib.sha1_hmac")

local CONFIG_PATH = "atm.conf" -- Define the config file path

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local card_data = nil
local balance = 0
local currencyRates = {}

local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- Graphical UI & Theme (With new "Beer" theme and text wrapping)
--==============================================================================
-- A new table for reusable utility functions.
local utils = {}

-- A universal word-wrap function.
-- @param text The string to wrap.
-- @param maxWidth The maximum width of each line.
-- @return A table of strings, where each entry is a wrapped line.
function utils.wordWrap(text, maxWidth)
    local lines = {}
    for line in text:gmatch("[^\n]+") do
        while #line > maxWidth do
            local breakPoint = maxWidth
            -- Try to find a space to break at.
            while breakPoint > 0 and line:sub(breakPoint, breakPoint) ~= " " do
                breakPoint = breakPoint - 1
            end
            if breakPoint == 0 then breakPoint = maxWidth end -- Force break if no space
            
            table.insert(lines, line:sub(1, breakPoint))
            line = line:sub(breakPoint + 1)
        end
        table.insert(lines, line)
    end
    return lines
end
-- A theme table to make color changes simple and consistent.
local theme = {
    bg = colors.black,
    text = colors.white,
    border = colors.brown,
    titleBg = colors.orange,
    titleText = colors.white,
    highlightBg = colors.yellow,
    highlightText = colors.brown,
    errorBg = colors.red,
    errorText = colors.white,
}

-- (The 'drawFrame' function is unchanged)
local function drawFrame(title)
    local w, h = term.getSize()
    term.setBackgroundColor(theme.bg); term.clear()
    term.setBackgroundColor(theme.border)
    for y=1,h do term.setCursorPos(1,y); term.write(" "); term.setCursorPos(w,y); term.write(" ") end
    for x=1,w do term.setCursorPos(x,1); term.write(" "); term.setCursorPos(x,h); term.write(" ") end
    term.setBackgroundColor(theme.titleBg); term.setTextColor(theme.titleText)
    local titleText = " " .. (title or "Drunken Beard Bank") .. " "
    local titleStart = math.floor((w - #titleText) / 2) + 1
    term.setCursorPos(titleStart, 1)
    term.write(titleText)
    term.setBackgroundColor(theme.bg); term.setTextColor(theme.text)
end

-- NEW: A word-wrapping version of printCentered to prevent text overflow.
local function printCenteredWrapped(startY, text)
    local w, h = term.getSize()
    local lines = utils.wordWrap(text, w - 4)

    for i, line in ipairs(lines) do
        local x = math.floor((w - #line) / 2) + 1
        term.setCursorPos(x, startY + i - 1)
        term.write(line)
    end
end

local function printCentered(startY, text)
    local w, h = term.getSize()
    local lines = utils.wordWrap(text, w - 4)

    for i, line in ipairs(lines) do
        local x = math.floor((w - #line) / 2) + 1
        term.setCursorPos(x, startY + i - 1)
        term.write(line)
    end
end

local function showMessage(title, message, isError)
    local w, h = term.getSize()
    local boxBg = isError and theme.errorBg or theme.titleBg
    local boxText = isError and theme.errorText or theme.titleText
    local boxW, boxH = math.floor(w * 0.8), math.floor(h * 0.7)
    local boxX, boxY = math.floor((w - boxW) / 2), math.floor((h - boxH) / 2)

    term.setBackgroundColor(boxBg)
    for y = boxY, boxY + boxH - 1 do
        term.setCursorPos(boxX, y); term.write(string.rep(" ", boxW))
    end
    
    term.setTextColor(boxText)
    local titleText = " " .. title .. " ";
    term.setCursorPos(math.floor((w - #titleText) / 2) + 1, boxY + 1); term.write(titleText)
    
    -- THE FIX: Use the smart word-wrapper
    local lines = utils.wordWrap(message, boxW - 4)

    for i, line in ipairs(lines) do
        term.setCursorPos(boxX + 2, boxY + 3 + i)
        print(line)
    end

    local continueText = "Press any key to continue..."
    term.setCursorPos(math.floor((w - #continueText) / 2) + 1, boxY + boxH - 2)
    print(continueText)
    
    os.pullEvent("key")
end

local function drawMenu(title, options, help)
    local w, h = term.getSize()
    local selected = 1
    while true do
        drawFrame(title)
        for i, opt in ipairs(options) do
            term.setCursorPos(4, 4 + i)
            if i == selected then
                term.setBackgroundColor(theme.highlightBg)
                term.setTextColor(theme.highlightText)
            else
                term.setBackgroundColor(theme.bg)
                term.setTextColor(theme.text)
            end
            term.write(" " .. opt .. string.rep(" ", w - 6 - #opt) .. " ")
        end
        term.setBackgroundColor(theme.bg)
        term.setTextColor(colors.yellow)
        if help then
            printCentered(h - 2, help)
        end
        local _, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then
            term.setBackgroundColor(theme.bg)
            term.setTextColor(theme.text)
            return selected
        elseif key == keys.q or key == keys.tab then return nil
        end
    end
end

--==============================================================================
-- Core Application Logic (With Corrected 'deposit' function)
--==============================================================================

local function login()
    drawFrame("Login")
    term.setCursorPos(3, 4)
    print("Please enter your Drunken OS password.")
    term.setCursorPos(3, 6)
    write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)

    if not pass or pass == "" then return false end

    local pass_hash = crypto.hex(pass)

    -- THE FIX: Convert both hashes to strings before comparing them.
    if tostring(pass_hash) == tostring(card_data.pass_hash) then
        printCenteredWrapped(10, "Password verified. Contacting bank server...")
        
        -- Send the verified hash (as a string) to the server.
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = tostring(pass_hash) }, BANK_PROTOCOL)
        
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            printCenteredWrapped(12, "Login successful!")
            sleep(1.5)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.", true)
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.", true)
        return false
    end
end

-- NEW: Corrected deposit function with full handshake logic
local function deposit()
    drawFrame("Deposit")
    printCentered(6, "Requesting deposit from Vault Clerk...")
    printCentered(8, "Please place items in the deposit barrel.")
    
    rednet.send(turtleClerkId, {type = "request_deposit"}, TURTLE_CLERK_PROTOCOL)

    -- 1. Wait for the turtle to report back with the items it collected.
    printCentered(10, "Waiting for clerk to collect items...")
    local _, turtle_response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)

    if not turtle_response or turtle_response.type ~= "deposit_count" or not turtle_response.items or #turtle_response.items == 0 then
        showMessage("Deposit Failed", (turtle_response and turtle_response.reason) or "No valid items were deposited.", true)
        return
    end

    -- 2. Send the collected items to the bank server for valuation.
    printCentered(12, "Items collected. Contacting bank for valuation...")
    rednet.send(bankServerId, {type = "deposit", user = username, items = turtle_response.items}, BANK_PROTOCOL)
    local _, server_response = rednet.receive(BANK_PROTOCOL, 15)

    if server_response and server_response.success then
        -- 3. If server is happy, tell the turtle to confirm and store the items.
        printCentered(14, "Valuation complete. Confirming with clerk...")
        rednet.send(turtleClerkId, { type = "confirm_deposit", new_balance = server_response.newBalance }, TURTLE_CLERK_PROTOCOL)

        -- 4. Wait for the turtle's final confirmation that items are stored.
        local _, final_response = rednet.receive(TURTLE_CLERK_PROTOCOL, 15)
        if final_response and final_response.success then
            balance = final_response.new_balance
            showMessage("Success", "Deposit complete. Your new balance is $" .. balance)
        else
            -- This is a serious error state - the server gave value but turtle failed to store.
            showMessage("CRITICAL ERROR", "Clerk failed to store items, but the transaction may have been partially processed. Please contact an admin.", true)
        end
    else
        -- 5. If server rejected the deposit, tell the turtle to return the items.
        rednet.send(turtleClerkId, {type = "cancel_deposit"}, TURTLE_CLERK_PROTOCOL)
        showMessage("Deposit Failed", (server_response and server_response.reason) or "Bank server did not respond.", true)
    end
end


local function withdraw()
    local options = {}
    local item_names = {}
    for name, data in pairs(currencyRates) do
        local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
        table.insert(options, string.format("%s ($%d)", clean_name, data.current))
        table.insert(item_names, name)
    end
    table.insert(options, "Cancel")
    
    local choice = drawMenu("Select Item to Withdraw", options, "Your balance: $" .. balance)
    if choice == nil or choice > #item_names then return end
    
    local item_name = item_names[choice]
    local rate = currencyRates[item_name].current

    drawFrame("Withdraw Amount")
    term.setCursorPos(3, 4); print("How many " .. item_name:gsub("minecraft:", ""):gsub("_", " ") .. " would you like?")
    term.setCursorPos(3, 5); print("(Cost: $"..rate.." each | Your balance: $"..balance..")")
    term.setCursorPos(3, 7); write("> "); term.setCursorBlink(true)
    local amount_str = read()
    term.setCursorBlink(false)
    
    local amount = tonumber(amount_str)
    if not amount or amount <= 0 then
        showMessage("Error", "Invalid amount entered.", true)
        return
    end

    -- THE FIX: Implement the 3-phase withdrawal protocol.
    
    -- Phase 1: Authorize with the Bank Server
    printCentered(10, "Contacting bank server for authorization...")
    rednet.send(bankServerId, {
        type = "withdraw_item",
        user = username,
        item_name = item_name,
        count = amount
    }, BANK_PROTOCOL)
    
    local _, server_response = rednet.receive(BANK_PROTOCOL, 15)
    
    if not server_response or not server_response.success then
        showMessage("Withdrawal Failed", (server_response and server_response.reason) or "No response from server.", true)
        return
    end
    
    -- Phase 2: If authorized, request physical dispense from the Turtle
    printCentered(12, "Authorization received. Requesting item dispense...")
    rednet.send(turtleClerkId, {
        type = "request_dispense",
        item_name = item_name,
        count = amount
    }, TURTLE_CLERK_PROTOCOL)
    
    local _, turtle_response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    
    if not turtle_response or not turtle_response.success then
        showMessage("Withdrawal Failed", (turtle_response and turtle_response.reason) or "Clerk turtle did not respond.", true)
        -- NOTE: We do not contact the server here, as no items were dispensed and no funds should be deducted.
        return
    end
    
    -- Phase 3: If turtle succeeds, finalize the transaction with the Bank Server
    printCentered(14, "Dispense successful. Finalizing transaction...")
    rednet.send(bankServerId, {
        type = "finalize_withdrawal",
        user = username,
        item_name = item_name,
        count = amount
    }, BANK_PROTOCOL)
    
    local _, final_response = rednet.receive(BANK_PROTOCOL, 15)
    
    if final_response and final_response.success then
        balance = final_response.newBalance
        showMessage("Success", "Please collect your items. New balance: $" .. balance)
    else
        -- This is a critical error state. The user has the items but their balance was not updated.
        showMessage("CRITICAL ERROR", "Could not finalize transaction. Please contact an admin.", true)
    end
end

local function mainMenu()
    local drive = peripheral.find("drive")
    while true do
        local options = { "Check Balance / Rates", "Deposit Items", "Withdraw Items", "Exit" }
        local choice = drawMenu("ATM Main Menu", options, "Welcome, " .. username .. " | Balance: $" .. balance)

        if not choice or choice == 4 then break end
        
        if choice == 1 then
            drawFrame("Current Exchange Rates")
            local w,h = term.getSize()
            
            -- THE FIX: Create a two-column layout
            local itemColWidth = math.floor((w - 6) * 0.7)
            local rateColWidth = w - 6 - itemColWidth
            
            term.setCursorPos(3, 4)
            term.setTextColor(colors.yellow)
            term.write(string.format("%-"..itemColWidth.."s %"..rateColWidth.."s", " Item", "Value "))
            term.setCursorPos(3, 5)
            term.write(string.rep("-", w - 4))
            term.setTextColor(colors.white)

            local y = 6
            for name, data in pairs(currencyRates) do
                local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
                -- Truncate name if it's too long for the column
                if #clean_name > itemColWidth - 1 then
                    clean_name = clean_name:sub(1, itemColWidth - 4) .. "..."
                end
                
                local rate = "$" .. data.current
                
                term.setCursorPos(3, y)
                term.write(string.format(" %-"..itemColWidth-1 .."s %"..rateColWidth.."s", clean_name, rate))
                y = y + 1
            end
            
            printCenteredWrapped(h - 2, "Press any key to return...")
            os.pullEvent("key")
        elseif choice == 2 then deposit()
        elseif choice == 3 then withdraw()
        end
    end

    drive.ejectDisk()
    rednet.close(peripheral.getName(peripheral.find("modem")))
    drawFrame("Goodbye")
    printCenteredWrapped(8, "Thank you for banking with Drunken Beard Bank!")
    sleep(2)
end

local function runFirstTimeSetup()
    drawFrame("First Time Setup")
    printCenteredWrapped(4, "This ATM has not been configured.")
    printCenteredWrapped(6, "Please start the Bank Clerk Turtle and enter its Computer ID below.")
    
    term.setCursorPos(3, 9)
    term.write("Enter Turtle ID > ")
    term.setCursorBlink(true)
    local id_str = read()
    term.setCursorBlink(false)
    
    local turtle_id = tonumber(id_str)
    if not turtle_id then
        showMessage("Setup Failed", "Invalid ID. The ID must be a number.", true)
        return nil -- Return nil to signal setup failure
    end

    printCenteredWrapped(12, "Verifying connection to turtle ID " .. turtle_id .. "...")
    if rednet.isOpen() then
        -- Ping the turtle to make sure it's real
        rednet.send(turtle_id, {type = "ping"}, TURTLE_CLERK_PROTOCOL)
        local sender, msg = rednet.receive(TURTLE_CLERK_PROTOCOL, 5)
        if sender == turtle_id and msg and msg.type == "pong" then
            -- Success! Save the config.
            local config = { turtleClerkId = turtle_id }
            local file = fs.open(CONFIG_PATH, "w")
            file.write(textutils.serialize(config))
            file.close()
            showMessage("Success", "ATM has been successfully paired with turtle " .. turtle_id .. ". The system will now restart.")
            os.reboot()
        else
            showMessage("Setup Failed", "Could not communicate with a turtle at that ID. Please check the ID and that the turtle is running.", true)
            return nil
        end
    else
        showMessage("Setup Failed", "Modem is not open. Cannot verify turtle.", true)
        return nil
    end
end

local function runSession()
    local modem = peripheral.find("modem")
    if not modem then error("No modem attached.", 0) end
    rednet.open(peripheral.getName(modem))

    -- THE FIX: Load the paired turtle ID from the config file.
    if not fs.exists(CONFIG_PATH) then
        runFirstTimeSetup()
        -- After setup, the ATM reboots. If setup fails, we'll just error here.
        error("Configuration not found. Please run setup.", 0)
    end
    
    local file = fs.open(CONFIG_PATH, "r")
    local data = textutils.unserialize(file.readAll())
    file.close()
    
    if not data or not data.turtleClerkId then
        fs.delete(CONFIG_PATH)
        error("Configuration file is corrupt. Deleting and restarting.", 0)
    end
    
    turtleClerkId = data.turtleClerkId
    
    -- The ATM no longer looks up the turtle, it knows its private ID.
    bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
    if not bankServerId then error("Could not find bank server.", 0) end
    
    drawFrame("Welcome")
    -- THE FIX: Use the new word-wrapping function.
    printCenteredWrapped(8, "Welcome to Drunken Beard Bank")
    printCenteredWrapped(10, "Please insert your bank card...")

    local drive = peripheral.find("drive")
    if not drive then error("No Disk Drive is attached to this terminal.", 0) end
    
    local event, p1 = os.pullEvent("disk")
    local disk_label = disk.getLabel(p1)
    if not disk_label or not disk_label:match("^DrunkenBeard_Card_.+") then
        showMessage("Card Error", "This is not a valid Drunken Beard Bank card.", true)
        disk.eject(p1)
        return
    end
    username = disk_label:match("^DrunkenBeard_Card_(.+)")
    local handle = fs.open(disk.getMountPath(p1) .. "/.card_data", "r")
    if not handle then
        showMessage("Card Error", "Card is missing its data file.", true)
        disk.eject(p1)
        return
    end
    local card_contents = handle.readAll()
    handle.close()
    local ok, data = pcall(textutils.unserialize, card_contents)
    if not ok or not data then
        showMessage("Card Error", "Card data is corrupt.", true)
        disk.eject(p1)
        return
    end
    card_data = data
    if login() then
        mainMenu()
    else
        disk.eject(p1)
        drawFrame("Login Failed")
        printCentered(8, "Card ejected.")
        sleep(2)
    end
end

--==============================================================================
-- Main Program Loop (Unchanged)
--==============================================================================

while true do
    local ok, err = pcall(runSession)
    if not ok then
        local file = fs.open("atm_crash.log", "a")
        if file then
            file.writeLine(os.date() .. " - FATAL ERROR: " .. tostring(err))
            file.close()
        end
        drawFrame("FATAL ERROR")
        term.setBackgroundColor(colors.red)
        term.setTextColor(colors.white)
        term.setCursorPos(2, 4); print("A fatal error occurred. The ATM will now reboot.")
        term.setCursorPos(2, 6); print(tostring(err))
        sleep(5)
        os.reboot()
    end
end
