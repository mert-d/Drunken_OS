--[[
    Drunken Beard Bank - ATM Terminal (v5.1 - UI Polish & Theming)
    by Gemini Gem & MuhendizBey

    Purpose:
    This is the definitive, feature-complete ATM client. It provides a full
    graphical user interface and implements the server's required three-phase
    transactional protocols for both deposits and withdrawals, ensuring maximum
    security and reliability.

    Changelog:
    v5.1:
    - Implemented a new "Drunken Bank" color theme (orange, yellow, brown).
    - Fixed text overflow bugs by creating a new 'printCenteredWrapped'
      function that automatically handles word wrapping for long messages.
    - Adjusted padding on all UI elements to ensure text stays within the
      graphical border.
    v5.0:
    - Re-engineered all transaction logic to be fully compliant with the
      server's secure protocol.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local card_data = nil
local balance = 0
local currencyRates = {}

local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- Graphical UI & Theme (Unchanged from v4.17)
--==============================================================================

--==============================================================================
-- Graphical UI & Theme (With new "Beer" theme and text wrapping)
--==============================================================================

-- A theme table to make color changes simple and consistent.
local theme = {
    bg = colors.black,
    text = colors.white,
    border = colors.brown,
    titleBg = colors.orange,
    titleText = colors.white,
    highlightBg = colors.yellow,
    highlightText = colors.brown,
    errorBg = colors.red,
    errorText = colors.white,
}

-- (The 'drawFrame' function is unchanged)
local function drawFrame(title)
    local w, h = term.getSize()
    term.setBackgroundColor(theme.bg); term.clear()
    term.setBackgroundColor(theme.border)
    for y=1,h do term.setCursorPos(1,y); term.write(" "); term.setCursorPos(w,y); term.write(" ") end
    for x=1,w do term.setCursorPos(x,1); term.write(" "); term.setCursorPos(x,h); term.write(" ") end
    term.setBackgroundColor(theme.titleBg); term.setTextColor(theme.titleText)
    local titleText = " " .. (title or "Drunken Beard Bank") .. " "
    local titleStart = math.floor((w - #titleText) / 2) + 1
    term.setCursorPos(titleStart, 1)
    term.write(titleText)
    term.setBackgroundColor(theme.bg); term.setTextColor(theme.text)
end

-- NEW: A word-wrapping version of printCentered to prevent text overflow.
local function printCenteredWrapped(startY, text)
    local w, h = term.getSize()
    local maxLen = w - 4 -- Maximum line length inside the border

    -- Word wrapping logic
    local lines = {}
    for line in text:gmatch("[^\n]+") do
        while #line > maxLen do
            local breakPoint = maxLen
            while breakPoint > 0 and line:sub(breakPoint, breakPoint) ~= " " do
                breakPoint = breakPoint - 1
            end
            if breakPoint == 0 then breakPoint = maxLen end -- Force break if no space
            
            table.insert(lines, line:sub(1, breakPoint))
            line = line:sub(breakPoint + 1)
        end
        table.insert(lines, line)
    end

    -- Print the centered lines
    for i, line in ipairs(lines) do
        local x = math.floor((w - #line) / 2) + 1
        term.setCursorPos(x, startY + i - 1)
        term.write(line)
    end
end

local function printCentered(y, text)
    local w, h = term.getSize()
    local x = math.floor((w - #text) / 2)
    term.setCursorPos(x, y)
    term.write(text)
end

local function showMessage(title, message, isError)
    local w, h = term.getSize()
    local boxBg = isError and theme.errorBg or theme.titleBg
    local boxText = isError and theme.errorText or theme.titleText
    local boxW, boxH = math.floor(w * 0.8), math.floor(h * 0.6)
    local boxX, boxY = math.floor((w - boxW) / 2), math.floor((h - boxH) / 2)
    term.setBackgroundColor(boxBg)
    for y = boxY, boxY + boxH - 1 do
        term.setCursorPos(boxX, y)
        term.write(string.rep(" ", boxW))
    end
    term.setTextColor(boxText)
    local titleText = " " .. title .. " "
    term.setCursorPos(math.floor(w - #titleText) / 2, boxY + 1)
    term.write(titleText)
    local lines = {}
    local maxLen = boxW - 4
    for line in message:gmatch("[^\n]+") do
        while #line > maxLen do
            table.insert(lines, line:sub(1, maxLen))
            line = line:sub(maxLen + 1)
        end
        table.insert(lines, line)
    end
    for i, line in ipairs(lines) do
        term.setCursorPos(boxX + 2, boxY + 3 + i)
        print(line)
    end
    local continueText = "Press any key to continue..."
    term.setCursorPos(math.floor((w - #continueText) / 2), boxY + boxH - 2)
    print(continueText)
    os.pullEvent("key")
end

local function drawMenu(title, options, help)
    local w, h = term.getSize()
    local selected = 1
    while true do
        drawFrame(title)
        for i, opt in ipairs(options) do
            term.setCursorPos(4, 4 + i)
            if i == selected then
                term.setBackgroundColor(theme.highlightBg)
                term.setTextColor(theme.highlightText)
            else
                term.setBackgroundColor(theme.bg)
                term.setTextColor(theme.text)
            end
            term.write(" " .. opt .. string.rep(" ", w - 6 - #opt) .. " ")
        end
        term.setBackgroundColor(theme.bg)
        term.setTextColor(colors.yellow)
        if help then
            printCentered(h - 2, help)
        end
        local _, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then
            term.setBackgroundColor(theme.bg)
            term.setTextColor(theme.text)
            return selected
        elseif key == keys.q or key == keys.tab then return nil
        end
    end
end

--==============================================================================
-- Core Application Logic (With Corrected 'deposit' function)
--==============================================================================

local function login()
    drawFrame("Login")
    term.setCursorPos(3, 4); print("Please enter your Drunken OS password.")
    term.setCursorPos(3, 6); write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)
    if not pass or pass == "" then return false end
    local pass_hash = crypto.hex(pass)
    if pass_hash == card_data.pass_hash then
        printCentered(10, "Password verified. Contacting bank server...")
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = pass_hash }, BANK_PROTOCOL)
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            printCentered(12, "Login successful!")
            sleep(1.5)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.", true)
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.", true)
        return false
    end
end

-- NEW: Corrected deposit function with full handshake logic
local function deposit()
    drawFrame("Deposit")
    printCentered(6, "Requesting deposit from Vault Clerk...")
    printCentered(8, "Please place items in the deposit barrel.")
    
    rednet.send(turtleClerkId, {type = "request_deposit"}, TURTLE_CLERK_PROTOCOL)

    -- 1. Wait for the turtle to report back with the items it collected.
    printCentered(10, "Waiting for clerk to collect items...")
    local _, turtle_response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)

    if not turtle_response or turtle_response.type ~= "deposit_count" or not turtle_response.items or #turtle_response.items == 0 then
        showMessage("Deposit Failed", (turtle_response and turtle_response.reason) or "No valid items were deposited.", true)
        return
    end

    -- 2. Send the collected items to the bank server for valuation.
    printCentered(12, "Items collected. Contacting bank for valuation...")
    rednet.send(bankServerId, {type = "deposit", user = username, items = turtle_response.items}, BANK_PROTOCOL)
    local _, server_response = rednet.receive(BANK_PROTOCOL, 15)

    if server_response and server_response.success then
        -- 3. If server is happy, tell the turtle to confirm and store the items.
        printCentered(14, "Valuation complete. Confirming with clerk...")
        rednet.send(turtleClerkId, { type = "confirm_deposit", new_balance = server_response.newBalance }, TURTLE_CLERK_PROTOCOL)

        -- 4. Wait for the turtle's final confirmation that items are stored.
        local _, final_response = rednet.receive(TURTLE_CLERK_PROTOCOL, 15)
        if final_response and final_response.success then
            balance = final_response.new_balance
            showMessage("Success", "Deposit complete. Your new balance is $" .. balance)
        else
            -- This is a serious error state - the server gave value but turtle failed to store.
            showMessage("CRITICAL ERROR", "Clerk failed to store items, but the transaction may have been partially processed. Please contact an admin.", true)
        end
    else
        -- 5. If server rejected the deposit, tell the turtle to return the items.
        rednet.send(turtleClerkId, {type = "cancel_deposit"}, TURTLE_CLERK_PROTOCOL)
        showMessage("Deposit Failed", (server_response and server_response.reason) or "Bank server did not respond.", true)
    end
end


local function withdraw()
    local options = {}
    local item_names = {}
    for name, data in pairs(currencyRates) do
        local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
        table.insert(options, string.format("%s ($%d)", clean_name, data.current))
        table.insert(item_names, name)
    end
    table.insert(options, "Cancel")
    
    local choice = drawMenu("Select Item to Withdraw", options, "Your balance: $" .. balance)
    if choice == nil or choice > #item_names then return end
    
    local item_name = item_names[choice]
    local rate = currencyRates[item_name].current

    drawFrame("Withdraw Amount")
    term.setCursorPos(3, 4); print("How many " .. item_name:gsub("minecraft:", ""):gsub("_", " ") .. " would you like?")
    term.setCursorPos(3, 5); print("(Cost: $"..rate.." each | Your balance: $"..balance..")")
    term.setCursorPos(3, 7); write("> "); term.setCursorBlink(true)
    local amount_str = read()
    term.setCursorBlink(false)
    
    local amount = tonumber(amount_str)
    if not amount or amount <= 0 then
        showMessage("Error", "Invalid amount entered.", true)
        return
    end

    -- THE FIX: Implement the 3-phase withdrawal protocol.
    
    -- Phase 1: Authorize with the Bank Server
    printCentered(10, "Contacting bank server for authorization...")
    rednet.send(bankServerId, {
        type = "withdraw_item",
        user = username,
        item_name = item_name,
        count = amount
    }, BANK_PROTOCOL)
    
    local _, server_response = rednet.receive(BANK_PROTOCOL, 15)
    
    if not server_response or not server_response.success then
        showMessage("Withdrawal Failed", (server_response and server_response.reason) or "No response from server.", true)
        return
    end
    
    -- Phase 2: If authorized, request physical dispense from the Turtle
    printCentered(12, "Authorization received. Requesting item dispense...")
    rednet.send(turtleClerkId, {
        type = "request_dispense",
        item_name = item_name,
        count = amount
    }, TURTLE_CLERK_PROTOCOL)
    
    local _, turtle_response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    
    if not turtle_response or not turtle_response.success then
        showMessage("Withdrawal Failed", (turtle_response and turtle_response.reason) or "Clerk turtle did not respond.", true)
        -- NOTE: We do not contact the server here, as no items were dispensed and no funds should be deducted.
        return
    end
    
    -- Phase 3: If turtle succeeds, finalize the transaction with the Bank Server
    printCentered(14, "Dispense successful. Finalizing transaction...")
    rednet.send(bankServerId, {
        type = "finalize_withdrawal",
        user = username,
        item_name = item_name,
        count = amount
    }, BANK_PROTOCOL)
    
    local _, final_response = rednet.receive(BANK_PROTOCOL, 15)
    
    if final_response and final_response.success then
        balance = final_response.newBalance
        showMessage("Success", "Please collect your items. New balance: $" .. balance)
    else
        -- This is a critical error state. The user has the items but their balance was not updated.
        showMessage("CRITICAL ERROR", "Could not finalize transaction. Please contact an admin.", true)
    end
end

local function mainMenu()
    local drive = peripheral.find("drive")
    while true do
        local options = { "Check Balance / Rates", "Deposit Items", "Withdraw Items", "Exit" }
        local choice = drawMenu("ATM Main Menu", options, "Welcome, " .. username .. " | Balance: $" .. balance)
        if not choice or choice == 4 then break end
        if choice == 1 then
            drawFrame("Current Exchange Rates")
            term.setCursorPos(3, 3); print("Current Exchange Rates:")
            local y = 5
            for name, data in pairs(currencyRates) do
                local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
                term.setCursorPos(4, y)
                print(string.format("1 %s = $%d", clean_name, data.current))
                y = y + 1
            end
            term.setCursorPos(4, y + 1); print("Press any key to return...")
            os.pullEvent("key")
        elseif choice == 2 then deposit()
        elseif choice == 3 then withdraw()
        end
    end
    drive.ejectDisk()
    rednet.close("back")
    drawFrame("Goodbye")
    printCentered(8, "Thank you for banking with Drunken Beard Bank!")
    sleep(2)
end

local function runSession()
    local function runSession()
    local modem = peripheral.find("modem")
    if not modem then error("No modem attached.", 0) end
    rednet.open(peripheral.getName(modem))

    bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
    if not bankServerId then error("Could not find bank server.", 0) end
    
    turtleClerkId = rednet.lookup(TURTLE_CLERK_PROTOCOL, "bank_turtle")
    if not turtleClerkId then error("Could not find Vault Clerk turtle.", 0) end

    drawFrame("Welcome")
    -- THE FIX: Use the new word-wrapping function.
    printCenteredWrapped(8, "Welcome to Drunken Beard Bank")
    printCenteredWrapped(10, "Please insert your bank card...")

    local drive = peripheral.find("drive")
    if not drive then error("No Disk Drive is attached to this terminal.", 0) end
    
    local event, p1 = os.pullEvent("disk")
    local disk_label = disk.getLabel(p1)
    if not disk_label or not disk_label:match("^DrunkenBeard_Card_.+") then
        showMessage("Card Error", "This is not a valid Drunken Beard Bank card.", true)
        disk.eject(p1)
        return
    end
    username = disk_label:match("^DrunkenBeard_Card_(.+)")
    local handle = fs.open(disk.getMountPath(p1) .. "/.card_data", "r")
    if not handle then
        showMessage("Card Error", "Card is missing its data file.", true)
        disk.eject(p1)
        return
    end
    local card_contents = handle.readAll()
    handle.close()
    local ok, data = pcall(textutils.unserialize, card_contents)
    if not ok or not data then
        showMessage("Card Error", "Card data is corrupt.", true)
        disk.eject(p1)
        return
    end
    card_data = data
    if login() then
        mainMenu()
    else
        disk.eject(p1)
        drawFrame("Login Failed")
        printCentered(8, "Card ejected.")
        sleep(2)
    end
end
end

--==============================================================================
-- Main Program Loop (Unchanged)
--==============================================================================

while true do
    local ok, err = pcall(runSession)
    if not ok then
        local file = fs.open("atm_crash.log", "a")
        if file then
            file.writeLine(os.date() .. " - FATAL ERROR: " .. tostring(err))
            file.close()
        end
        drawFrame("FATAL ERROR")
        term.setBackgroundColor(colors.red)
        term.setTextColor(colors.white)
        term.setCursorPos(2, 4); print("A fatal error occurred. The ATM will now reboot.")
        term.setCursorPos(2, 6); print(tostring(err))
        sleep(5)
        os.reboot()
    end
end
