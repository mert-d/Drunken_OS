--[[
    Drunken Beard Bank - ATM Terminal (v4.16 - Definitive Stable Upgrade)
    by Gemini Gem & MuhendizBey

    Purpose:
    This is the definitive, stable version of the ATM script, built directly
    upon the user-provided working baseline (ATM_Test.txt). It incorporates
    the two necessary fixes for the card data scope and the login handshake,
    while preserving all original, working logic, UI, and discovery methods.

    Key Changes:
    - Fixed the scope issue by correctly assigning read card data to the
      main 'card_data' variable in the `runSession` function.
    - The login function now correctly sends the password hash to the Bank Server.
    - All other logic is identical to the trusted baseline.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local bankServerId = nil
local turtleClerkId = nil
local username = nil
local card_data = nil -- This will be populated by runSession
local balance = 0
local currencyRates = {}

local BANK_PROTOCOL = "DB_Bank"
local TURTLE_CLERK_PROTOCOL = "DB_ATM_Turtle"

--==============================================================================
-- UI & Theme (Preserved from original baseline)
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(c) if hasColor then return c else return colors.white end end

local function clear() term.setBackgroundColor(colors.black); term.clear() end

local function showMessage(title, message)
    local w, h = term.getSize()
    local bg = hasColor and colors.red or colors.gray
    local text = hasColor and colors.white or colors.black
    
    term.setBackgroundColor(bg)
    term.setTextColor(text)
    term.clear()
    term.setCursorPos(1,1)
    
    local titleText = " " .. title .. " "
    term.setCursorPos(math.floor((w - #titleText) / 2), 2)
    print(titleText)

    local lines = {}
    for line in message:gmatch("[^\n]+") do
        while #line > w - 4 do
            table.insert(lines, line:sub(1, w - 4))
            line = line:sub(w - 3)
        end
        table.insert(lines, line)
    end

    for i, line in ipairs(lines) do
        term.setCursorPos(3, 4 + i)
        print(line)
    end

    term.setCursorPos(3, 5 + #lines)
    print("Press any key to continue...")
    os.pullEvent("key")
end

local function drawMenu(title, options, help)
    local w, h = term.getSize()
    local selected = 1
    while true do
        term.setBackgroundColor(colors.black)
        term.clear()
        term.setCursorPos(1,1)
        term.setTextColor(colors.yellow)
        print(title)
        term.setCursorPos(1,2)
        print(string.rep("-", #title))
        
        for i, opt in ipairs(options) do
            term.setCursorPos(3, 3 + i)
            if i == selected then
                term.setTextColor(colors.black)
                term.setBackgroundColor(colors.white)
            else
                term.setTextColor(colors.white)
                term.setBackgroundColor(colors.black)
            end
            term.write(opt)
        end

        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.gray)
        term.setCursorPos(1, h)
        term.write(help or "Use UP/DOWN and ENTER to select.")

        local event, key = os.pullEvent("key")
        if key == keys.up then selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then return selected
        elseif key == keys.tab or key == keys.q then return nil
        end
    end
end

--==============================================================================
-- Core Application Logic (from baseline, with targeted fixes)
--==============================================================================

local function login()
    clear()
    term.setCursorPos(1,1)
    print("Please enter your Drunken OS password.")
    write("> ")
    term.setCursorBlink(true)
    local pass = read("*")
    term.setCursorBlink(false)

    if not pass or pass == "" then return false end

    local pass_hash = crypto.hex(pass)

    if pass_hash == card_data.pass_hash then
        print("Password verified. Contacting bank server...")
        
        -- FIX #1: Send the verified hash to the server.
        rednet.send(bankServerId, { type = "login", user = username, pass_hash = pass_hash }, BANK_PROTOCOL)
        
        local _, response = rednet.receive(BANK_PROTOCOL, 10)
        
        if response and response.success then
            balance = response.balance
            currencyRates = response.rates
            print("Login successful!")
            sleep(1)
            return true
        else
            showMessage("Login Failed", (response and response.reason) or "No response from server.")
            return false
        end
    else
        showMessage("Login Failed", "Invalid password.")
        return false
    end
end

local function deposit()
    clear()
    term.setCursorPos(1,1)
    print("Requesting deposit...")
    rednet.send(turtleClerkId, {type = "request_deposit"}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Deposit complete. Your new balance is $" .. balance)
    else
        showMessage("Deposit Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

local function withdraw()
    local options = {}
    local item_names = {}
    for name, data in pairs(currencyRates) do
        local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
        table.insert(options, string.format("%s ($%d)", clean_name, data.current))
        table.insert(item_names, name)
    end
    table.insert(options, "Cancel")
    
    local choice = drawMenu("Select Item to Withdraw", options, "Your balance: $" .. balance)
    if choice == nil or choice > #item_names then return end
    
    local item_name = item_names[choice]
    local rate = currencyRates[item_name].current

    clear()
    term.setCursorPos(1,1)
    print("How many " .. item_name:gsub("minecraft:", ""):gsub("_", " ") .. " would you like to withdraw?")
    write("> ")
    term.setCursorBlink(true)
    local amount_str = read()
    term.setCursorBlink(false)
    
    local amount = tonumber(amount_str)
    if not amount or amount <= 0 or (amount * rate > balance) then
        showMessage("Error", "Invalid amount or insufficient funds.")
        return
    end

    print("Requesting withdrawal of " .. amount .. " " .. item_name .. "...")
    rednet.send(turtleClerkId, {type = "request_dispense", item_name = item_name, count = amount}, TURTLE_CLERK_PROTOCOL)
    local _, response = rednet.receive(TURTLE_CLERK_PROTOCOL, 30)
    
    if response and response.success then
        balance = response.new_balance
        showMessage("Success", "Please collect your items. New balance: $" .. balance)
    else
        showMessage("Withdrawal Failed", (response and response.reason) or "Turtle did not respond.")
    end
end

local function mainMenu()
    local drive = peripheral.find("drive")
    while true do
        local options = { "Check Balance / Rates", "Deposit Items", "Withdraw Items", "Exit" }
        local choice = drawMenu("ATM Main Menu", options, "Welcome, " .. username .. " | Balance: $" .. balance)

        if not choice or choice == 4 then break end
        
        if choice == 1 then
            clear(); term.setCursorPos(1,1); print("Current Exchange Rates:")
            local y = 3
            for name, data in pairs(currencyRates) do
                local clean_name = name:gsub("minecraft:", ""):gsub("_", " ")
                term.setCursorPos(2, y); print(string.format("1 %s = $%d", clean_name, data.current))
                y = y + 1
            end
            term.setCursorPos(2, y+1); print("Press any key to return...")
            os.pullEvent("key")
        elseif choice == 2 then deposit()
        elseif choice == 3 then withdraw()
        end
    end

    drive.ejectDisk()
    rednet.close("back")
    clear(); print("Thank you for banking with Drunken Beard Bank!")
    sleep(2)
end

local function runSession()
    local modem = peripheral.find("modem")
    if not modem then error("No modem attached.", 0) end
    rednet.open(peripheral.getName(modem))

    bankServerId = rednet.lookup(BANK_PROTOCOL, "bank.server")
    if not bankServerId then error("Could not find bank server.", 0) end
    
    turtleClerkId = rednet.lookup(TURTLE_CLERK_PROTOCOL, "bank_turtle")
    if not turtleClerkId then error("Could not find Vault Clerk turtle.", 0) end

    clear()
    print("Drunken Beard Bank")
    print("Please insert your bank card...")

    local drive = peripheral.find("drive")
    if not drive then error("No Disk Drive is attached to this terminal.", 0) end
    
    local event, p1 = os.pullEvent("disk")

    local disk_label = disk.getLabel(p1)
    if not disk_label or not disk_label:match("^DrunkenBeard_Card_.+") then
        showMessage("Card Error", "This is not a valid Drunken Beard Bank card.")
        disk.eject(p1)
        return
    end
    
    username = disk_label:match("^DrunkenBeard_Card_(.+)")
    local handle = fs.open(disk.getMountPath(p1) .. "/.card_data", "r")
    if not handle then
        showMessage("Card Error", "Card is missing its data file.")
        disk.eject(p1)
        return
    end

    local card_contents = handle.readAll()
    handle.close()
    local ok, data = pcall(textutils.unserialize, card_contents)

    if not ok or not data then
        showMessage("Card Error", "Card data is corrupt.")
        disk.eject(p1)
        return
    end
    
    -- FIX #2: Assign the data we just read to the main variable.
    card_data = data

    if login() then
        mainMenu()
    else
        disk.eject(p1)
        print("\nCard ejected.")
        sleep(2)
    end
end

--==============================================================================
-- Main Program Loop
--==============================================================================

while true do
    local ok, err = pcall(runSession)
    if not ok then
        local file = fs.open("atm_crash.log", "a")
        if file then
            file.writeLine(os.date() .. " - FATAL ERROR: " .. tostring(err))
            file.close()
        end
        
        clear()
        term.setTextColor(colors.red)
        print("A fatal error occurred. The ATM will now reboot.")
        print(err)
        sleep(5)
        os.reboot()
    end
end

