--[[
    Drunken OS - Bank Server (v2.3 - UI Polish & Card Creation)
    by Gemini Gem

    Purpose:
    This version polishes the GUI and re-introduces the 'makecard' command
    in a secure, multi-server context.

    Key Changes:
    - Log messages are now properly silenced and no longer appear on the main GUI dashboard.
    - Added the 'makecard <username>' command back to the Admin Terminal.
    - The 'makecard' command now securely verifies with the Mainframe server
      that a user exists before creating a card.
    - Card labels now include the username, e.g., "DB_Bank Card (User)".

    Setup:
    - An ADVANCED MONITOR must be placed on any side of this computer.
    - A WIRELESS modem must be attached for public communication.
    - A WIRED modem must be attached and cabled to the Mainframe Server.
]]

--==============================================================================
-- Embedded SHA1 & HMAC Library
--==============================================================================
-- (SHA1 Library code remains unchanged)
local sha1 = {}
do
    local lshift, rshift, bor, band, bxor = bit32.lshift, bit32.rshift, bit32.bor, bit32.band, bit32.bxor
    local function rol(n, c) return bor(lshift(n, c), rshift(n, 32 - c)) end
    local function str_to_bin(str) local t = {}; for i = 1, #str do t[i] = string.byte(str, i) end; return t end
    local function bin_to_hex(bin) local hex = ""; for i = 1, #bin do hex = hex .. string.format("%02x", bin[i]) end; return hex end
    local function bin_to_str(bin) return string.char(table.unpack(bin)) end
    function sha1.hex(s) return bin_to_hex(sha1.bin(s)) end
    function sha1.bin(s)
      local H0, H1, H2, H3, H4 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
      local str = str_to_bin(s); local len = #str; str[len + 1] = 0x80
      for i = len + 2, (len + 64) - ((len + 8) % 64) do str[i] = 0 end
      local bit_len = len * 8
      for i = 0, 7 do str[#str + 1] = band(rshift(bit_len, (7 - i) * 8), 0xff) end
      for i = 1, #str, 64 do
        local W = {}; for j = 0, 15 do W[j] = bor(lshift(str[i+j*4], 24), lshift(str[i+j*4+1], 16), lshift(str[i+j*4+2], 8), str[i+j*4+3]) end
        for j = 16, 79 do W[j] = rol(bxor(W[j-3], W[j-8], W[j-14], W[j-16]), 1) end
        local a,b,c,d,e = H0,H1,H2,H3,H4
        for j = 0, 79 do
          local f, k
          if j < 20 then f = bxor(d, band(b, bxor(c, d))); k = 0x5A827999
          elseif j < 40 then f = bxor(b, c, d); k = 0x6ED9EBA1
          elseif j < 60 then f = bor(band(b, c), band(b, d), band(c, d)); k = 0x8F1BBCDC
          else f = bxor(b, c, d); k = 0xCA62C1D6 end
          local temp = rol(a, 5) + f + e + W[j] + k; e=d; d=c; c=rol(b, 30); b=a; a=temp
        end
        H0=(H0+a); H1=(H1+b); H2=(H2+c); H3=(H3+d); H4=(H4+e)
      end
      local result = {}; for i=0,3 do result[i+1]=band(rshift(H0,(3-i)*8),0xff) end; for i=0,3 do result[i+5]=band(rshift(H1,(3-i)*8),0xff) end; for i=0,3 do result[i+9]=band(rshift(H2,(3-i)*8),0xff) end; for i=0,3 do result[i+13]=band(rshift(H3,(3-i)*8),0xff) end; for i=0,3 do result[i+17]=band(rshift(H4,(3-i)*8),0xff) end
      return result
    end
    function sha1.hmac_hex(key, message)
        local blocksize = 64
        if #key > blocksize then key = bin_to_str(sha1.bin(key)) end
        local key_padding = {}; for i = 1, blocksize do key_padding[i] = string.byte(key, i) or 0 end
        local o_key_pad = ""; local i_key_pad = ""
        for i = 1, blocksize do
            o_key_pad = o_key_pad .. string.char(bxor(key_padding[i], 0x5c))
            i_key_pad = i_key_pad .. string.char(bxor(key_padding[i], 0x36))
        end
        local inner_hash = bin_to_str(sha1.bin(i_key_pad .. message))
        local final_hash = sha1.bin(o_key_pad .. inner_hash)
        return bin_to_hex(final_hash)
    end
end

--==============================================================================
-- Configuration & State
--==============================================================================

local accounts, currencyRates, currentStock = {}, {}, {}
local mainServerId = nil
local wired_modem_name, wireless_modem_name = nil, nil
local adminInput = ""
local logHistory = {}
local monitor = nil
local startupComplete = false -- Flag to control logging to terminal

-- Database file paths
local LOGS_DIR = "logs"
local TRANSACTIONS_DIR = LOGS_DIR .. "/transactions"
local CURRENCIES_DIR = "currencies"
local ACCOUNTS_DB = "bank_accounts.db"
local STOCK_DB = "bank_stock.db"
local LOG_FILE = LOGS_DIR .. "/bank_server.log"

-- Rednet Protocols
local BANK_PROTOCOL = "DB_Bank"
local AUDIT_PROTOCOL = "DB_Audit"
local AUTH_INTERLINK_PROTOCOL = "Drunken_Auth_Interlink"

-- Auditor Turtle Configuration
local AUDIT_SECRET_KEY = "YourSecretAuditKeyHere"

--==============================================================================
-- UI & Theme Configuration
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then return colors[colorName] end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    title = safeColor("lightBlue", colors.lightBlue),
    prompt = safeColor("cyan", colors.cyan),
    statusBarBg = safeColor("gray", colors.lightGray),
    statusBarText = safeColor("white", colors.white),
    highlightBg = safeColor("blue", colors.blue),
    highlightText = safeColor("white", colors.white),
    error = safeColor("red", colors.red),
}

local currentScreen = "main"
local selectedMenuItem = 1
local needsRedraw = true

--==============================================================================
-- Logging Functions
--==============================================================================

local function logActivity(message, isError)
    local prefix = isError and "[ERROR] " or "[INFO] "
    local logEntry = os.date("[%Y-%m-%d %H:%M:%S] ") .. prefix .. message
    
    if not startupComplete then
        -- Only print to the physical terminal during startup
        term.write(logEntry .. "\n")
    end
    
    if not fs.exists(LOGS_DIR) then fs.makeDir(LOGS_DIR) end
    local file = fs.open(LOG_FILE, "a")
    if file then
        file.writeLine(logEntry)
        file.close()
    end

    table.insert(logHistory, logEntry)
    if #logHistory > 200 then table.remove(logHistory, 1) end
    
    if currentScreen == "log" then
        needsRedraw = true
    end
end

local function logTransaction(username, message)
    local logEntry = os.date("[%Y-%m-%d %H:%M:%S] ") .. message
    if not fs.exists(LOGS_DIR) then fs.makeDir(LOGS_DIR) end
    if not fs.exists(TRANSACTIONS_DIR) then fs.makeDir(TRANSACTIONS_DIR) end

    local file = fs.open(TRANSACTIONS_DIR .. "/" .. username .. ".log", "a")
    if file then
        file.writeLine(logEntry)
        file.close()
    end
end

--==============================================================================
-- Graphical UI Functions
--==============================================================================

local function drawMainMenu()
    if not monitor then return end
    local w, h = monitor.getSize()
    monitor.setBackgroundColor(theme.windowBg)
    monitor.clear()
    
    monitor.setBackgroundColor(theme.title)
    monitor.setCursorPos(1, 1); monitor.write(string.rep(" ", w))
    monitor.setTextColor(colors.white)
    local titleText = " Drunken OS Bank Server "
    monitor.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1)
    monitor.write(titleText)

    monitor.setBackgroundColor(theme.windowBg)
    monitor.setTextColor(theme.text)
    monitor.setCursorPos(3, 3); monitor.write("System Status: "); monitor.setTextColor(colors.green); monitor.write("ONLINE")
    monitor.setTextColor(theme.text)
    monitor.setCursorPos(3, 4); monitor.write("Mainframe Link: "); monitor.setTextColor(mainServerId and colors.green or colors.red); monitor.write(mainServerId and "CONNECTED" or "DISCONNECTED")
    
    local numAccounts = 0; for _ in pairs(accounts) do numAccounts = numAccounts + 1 end
    monitor.setCursorPos(3, 5); monitor.write("Managed Accounts: " .. numAccounts)
    local numCurrencies = 0; for _ in pairs(currencyRates) do numCurrencies = numCurrencies + 1 end
    monitor.setCursorPos(3, 6); monitor.write("Tracked Currencies: " .. numCurrencies)

    local menuOptions = { "View Rates & Stock", "View Server Log", "Open Admin Terminal", "Shutdown Server" }
    for i, option in ipairs(menuOptions) do
        monitor.setCursorPos(3, 8 + i)
        if i == selectedMenuItem then
            monitor.setBackgroundColor(theme.highlightBg); monitor.setTextColor(theme.highlightText)
            monitor.write("> " .. option .. string.rep(" ", w - 6 - #option))
        else
            monitor.setBackgroundColor(theme.windowBg); monitor.setTextColor(theme.text)
            monitor.write("  " .. option .. string.rep(" ", w - 6 - #option))
        end
    end

    monitor.setBackgroundColor(theme.statusBarBg)
    monitor.setCursorPos(1, h); monitor.write(string.rep(" ", w))
    monitor.setTextColor(theme.statusBarText)
    local footerText = "Use UP/DOWN & ENTER or Click to Navigate"
    monitor.setCursorPos(math.floor((w - #footerText) / 2) + 1, h)
    monitor.write(footerText)
    
    needsRedraw = false
end

local function drawLogScreen()
    if not monitor then return end
    local w, h = monitor.getSize()
    monitor.setBackgroundColor(theme.windowBg); monitor.clear()
    monitor.setBackgroundColor(theme.title); monitor.setCursorPos(1, 1); monitor.write(string.rep(" ", w))
    monitor.setTextColor(colors.white); local titleText = " Live Server Log "; monitor.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1); monitor.write(titleText)
    
    local logAreaHeight = h - 2
    local y = h - 1
    for i = #logHistory, 1, -1 do
        if y < 2 then break end
        local line = logHistory[i]
        monitor.setCursorPos(2, y); monitor.write(string.sub(line, 1, w-2))
        y = y - 1
    end

    monitor.setBackgroundColor(theme.statusBarBg); monitor.setCursorPos(1, h); monitor.write(string.rep(" ", w))
    monitor.setTextColor(theme.statusBarText); local footerText = "Press any key to return to main menu"; monitor.setCursorPos(math.floor((w - #footerText) / 2) + 1, h); monitor.write(footerText)
    
    needsRedraw = false
end

--==============================================================================
-- Data Persistence & Core Logic
--==============================================================================

local function saveTableToFile(path, data)
    local file = fs.open(path, "w")
    if not file then logActivity("Could not open " .. path .. " for writing.", true); return false end
    local success, err = pcall(function() file.write(textutils.serializeJSON(data)); file.close() end)
    if not success then logActivity("Failed to write to " .. path .. ": " .. tostring(err), true); return false end
    return true
end

local function loadTableFromFile(path)
    if fs.exists(path) then
        local file = fs.open(path, "r")
        if file then
            local data = file.readAll(); file.close()
            local success, result = pcall(textutils.unserializeJSON, data)
            if success and type(result) == "table" then return result
            else logActivity("Corrupted data in " .. path .. ". A new file will be created.", true) end
        end
    end
    return {}
end

local function loadAllData()
    accounts = loadTableFromFile(ACCOUNTS_DB)
    
    currencyRates = {}
    if fs.exists(CURRENCIES_DIR) then
        for _, file in ipairs(fs.list(CURRENCIES_DIR)) do
            local itemName = file:match("(.+)%.json$")
            if itemName then
                currencyRates[itemName] = loadTableFromFile(fs.combine(CURRENCIES_DIR, file))
            end
        end
    end

    currentStock = loadTableFromFile(STOCK_DB)
    logActivity("All banking data loaded successfully.")
end

local function adjustCurrencyRates()
    logActivity("Adjusting currency rates based on new stock report...")
    local changed = false
    for item, data in pairs(currencyRates) do
        if data.target and data.target > 0 then
            local stock = currentStock[item] or 0
            if stock == 0 then stock = 1 end
            local ratio = data.target / stock
            local price_multiplier = ratio ^ 0.5
            local new_price = math.floor(data.base * price_multiplier + 0.5)
            local max_price = data.base * 5
            local min_price = 1
            new_price = math.max(min_price, math.min(max_price, new_price))

            if new_price ~= data.current then
                logActivity(string.format("'%s' price changed from $%d to $%d (Stock: %d/%d)", item, data.current, new_price, currentStock[item] or 0, data.target))
                currencyRates[item].current = new_price
                changed = true
            end
        end
    end

    if changed then
        for itemName, data in pairs(currencyRates) do
            if not saveTableToFile(fs.combine(CURRENCIES_DIR, itemName .. ".json"), data) then
                 logActivity("Failed to save updated rate for " .. itemName, true)
            end
        end
    end
end

local bankHandlers = {}

function bankHandlers.login(senderId, message)
    logActivity("Forwarding login request for '" .. message.user .. "' to main server via wired modem.")
    rednet.send(mainServerId, {
        type = "auth_check",
        user = message.user,
        pass_hash = sha1.hex(message.pass)
    }, AUTH_INTERLINK_PROTOCOL)

    local _, response, proto = rednet.receive(AUTH_INTERLINK_PROTOCOL, 5)

    if response and response.user == message.user and response.success then
        logActivity("Auth success for '" .. message.user .. "'.")
        if not accounts[message.user] then accounts[message.user] = 0 end
        rednet.send(senderId, { success = true, balance = accounts[message.user] }, BANK_PROTOCOL)
    else
        logActivity("Auth failed for '" .. message.user .. "'.", true)
        rednet.send(senderId, { success = false, reason = "Invalid username or password." }, BANK_PROTOCOL)
    end
end

function bankHandlers.get_balance_and_rates(senderId, message)
    rednet.send(senderId, {
        balance = accounts[message.user] or 0,
        rates = currencyRates
    }, BANK_PROTOCOL)
end

function bankHandlers.deposit(senderId, message)
    local user, items = message.user, message.items
    local total_value = 0
    local transaction_summary = {}
    for _, item in ipairs(items) do
        if currencyRates[item.name] then
            local value = item.count * currencyRates[item.name].current
            total_value = total_value + value
            table.insert(transaction_summary, string.format("%d %s for $%d", item.count, item.name, value))
        end
    end

    if total_value > 0 then
        accounts[user] = (accounts[user] or 0) + total_value
        if saveTableToFile(ACCOUNTS_DB, accounts) then
            rednet.send(senderId, { success = true, newBalance = accounts[user], deposited_value = total_value }, BANK_PROTOCOL)
            local log_msg = string.format("DEPOSIT of $%d. Details: %s", total_value, table.concat(transaction_summary, ", "))
            logTransaction(user, log_msg)
            logActivity(string.format("User '%s' deposited items for $%d.", user, total_value))
        else
            rednet.send(senderId, { success = false, reason = "Server database error." }, BANK_PROTOCOL)
        end
    else
        rednet.send(senderId, { success = false, reason = "No valid currency detected." }, BANK_PROTOCOL)
    end
end

function bankHandlers.withdraw_item(senderId, message)
    local user, itemName, count = message.user, message.item_name, message.count
    local rateInfo = currencyRates[itemName]

    if not rateInfo then
        rednet.send(senderId, { success = false, reason = "Invalid currency type." }, BANK_PROTOCOL)
        return
    end

    local totalCost = rateInfo.current * count
    if (accounts[user] or 0) >= totalCost then
        if (currentStock[itemName] or 0) >= count then
            accounts[user] = accounts[user] - totalCost
            if saveTableToFile(ACCOUNTS_DB, accounts) then
                rednet.send(senderId, { success = true, newBalance = accounts[user] }, BANK_PROTOCOL)
                local log_msg = string.format("WITHDRAW of $%d (%d x %s)", totalCost, count, itemName)
                logTransaction(user, log_msg)
                logActivity(string.format("User '%s' approved for withdrawal of %d %s for $%d.", user, count, itemName, totalCost))
            else
                accounts[user] = accounts[user] + totalCost -- Refund on DB error
                rednet.send(senderId, { success = false, reason = "Server database error." }, BANK_PROTOCOL)
            end
        else
            rednet.send(senderId, { success = false, reason = "Insufficient stock in vault." }, BANK_PROTOCOL)
        end
    else
        rednet.send(senderId, { success = false, reason = "Insufficient funds." }, BANK_PROTOCOL)
    end
end

--==============================================================================
-- Admin Command Handlers & Terminal
--==============================================================================

local adminCommands = {}

local function parseAdminArgs(args)
    local command = table.remove(args, 1)
    if not args or #args == 0 then return command, nil, nil end
    local itemName = args[1]
    local numberValue = tonumber(args[2])
    if #args > 2 and not tonumber(args[2]) then
        itemName = table.concat(args, " ", 1, 2)
        numberValue = tonumber(args[3])
    end
    return command, itemName, numberValue
end

function adminCommands.help()
    print("--- Bank Admin Commands ---")
    print("balance <user>")
    print("setbalance <user> <amount>")
    print("give <user> <amount>")
    print("makecard <user>")
    print("addcurrency <item_name> <base_rate>")
    print("delcurrency <item_name>")
    print("listrates")
    print("settarget <item_name> <target_amount>")
    print("exit - Closes the terminal and returns to the GUI.")
end

function adminCommands.balance(args)
    local _, user = parseAdminArgs(args)
    if not user then print("Usage: balance <user>"); return end
    print("Balance for " .. user .. ": " .. (accounts[user] or 0))
end

function adminCommands.setbalance(args)
    local _, user, amount = parseAdminArgs(args)
    if not user or not amount then print("Usage: setbalance <user> <amount>"); return end
    accounts[user] = amount; saveTableToFile(ACCOUNTS_DB, accounts)
    print("Set balance for " .. user .. " to " .. amount)
end

function adminCommands.give(args)
    local _, user, amount = parseAdminArgs(args)
    if not user or not amount then print("Usage: give <user> <amount>"); return end
    accounts[user] = (accounts[user] or 0) + amount; saveTableToFile(ACCOUNTS_DB, accounts)
    print("Gave " .. amount .. " to " .. user .. ". New balance: " .. accounts[user])
end

function adminCommands.makecard(args)
    local _, user = parseAdminArgs(args)
    if not user then
        print("Usage: makecard <username>")
        return
    end
    
    print("Verifying user with Mainframe...")
    rednet.send(mainServerId, { type = "user_exists_check", user = user }, AUTH_INTERLINK_PROTOCOL)
    local _, response = rednet.receive(AUTH_INTERLINK_PROTOCOL, 5)

    if not response or not response.exists then
        print("Error: Mainframe reports user '" .. user .. "' does not exist.")
        return
    end

    print("User verified. Please insert a blank disk.")
    local disk = peripheral.find("drive")
    if not disk then
        print("Error: No disk drive attached to this server.")
        return
    end

    if not disk.isDiskPresent() then
        print("Error: No disk in the drive.")
        return
    end

    local mount_path = disk.getMountPath()
    if not mount_path then
        print("Error: Could not get disk mount path.")
        return
    end

    disk.setDiskLabel("Drunken Beard Bank Card (" .. user .. ")")
    local cardFile = fs.open(mount_path .. "/.bankcard", "w")
    if cardFile then
        cardFile.write(user)
        cardFile.close()
    else
        print("Error: Could not write main card file to disk.")
        return
    end

    local descFile = fs.open(mount_path .. "/.description", "w")
    if descFile then
        local description = "Property of: " .. user .. "\n" ..
                            "Account Type: Standard\n\n" ..
                            "A proud member of the Drunken Beard banking system."
        descFile.write(description)
        descFile.close()
        print("Successfully created bank card with description for " .. user)
    else
        print("Error: Could not write description file to disk.")
    end
end

function adminCommands.addcurrency(args)
    local _, itemName, baseRate = parseAdminArgs(args)
    if not itemName or not baseRate then print("Usage: addcurrency <item_name> <base_rate>"); return end
    if currencyRates[itemName] then print("Currency '" .. itemName .. "' already exists."); return end
    if not fs.isDir(CURRENCIES_DIR) then fs.makeDir(CURRENCIES_DIR) end

    currencyRates[itemName] = { base = baseRate, current = baseRate, target = nil }
    if saveTableToFile(fs.combine(CURRENCIES_DIR, itemName .. ".json"), currencyRates[itemName]) then
        print("Added new currency '" .. itemName .. "' with base rate $" .. baseRate)
    else
        currencyRates[itemName] = nil -- Revert change if save failed
        print("Failed to save new currency.")
    end
end

function adminCommands.delcurrency(args)
    local _, itemName = parseAdminArgs(args)
    if not itemName then print("Usage: delcurrency <item_name>"); return end
    if not currencyRates[itemName] then print("Currency '" .. itemName .. "' does not exist."); return end
    currencyRates[itemName] = nil
    
    local path = fs.combine(CURRENCIES_DIR, itemName .. ".json")
    if fs.exists(path) then fs.delete(path) end
    
    print("Removed currency '" .. itemName .. "'.")
end

function adminCommands.listrates()
    print("--- Current Exchange Rates ---")
    for name, data in pairs(currencyRates) do
        local stock = currentStock[name] or 0
        local target = data.target and ("/" .. data.target) or "/N/A"
        print(string.format("- %s: $%d (Base: $%d) | Stock: %d%s", name, data.current, data.base, stock, target))
    end
end

function adminCommands.settarget(args)
    local _, itemName, targetAmount = parseAdminArgs(args)
    if not itemName or not targetAmount then print("Usage: settarget <item_name> <target_amount>"); return end
    if not currencyRates[itemName] then print("Currency '" .. itemName .. "' does not exist."); return end
    
    currencyRates[itemName].target = targetAmount
    if saveTableToFile(fs.combine(CURRENCIES_DIR, itemName .. ".json"), currencyRates[itemName]) then
        print("Set target stock for '" .. itemName .. "' to " .. targetAmount)
    else
        print("Failed to set target.")
    end
end

local function handleAdminCommand(command)
    local args = {}; for arg in string.gmatch(command, "[^%s]+") do table.insert(args, arg) end
    local cmd = args[1]
    if cmd == "exit" then return false end -- Signal to exit terminal
    if adminCommands[cmd] then adminCommands[cmd](args) else print("Unknown command. Type 'help'.") end
    return true -- Continue terminal session
end

local function adminTerminal()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1,1)
    print("Bank Admin Terminal. Type 'exit' to return to GUI.")
    
    while true do
        term.write("> ")
        local input = read()
        if not handleAdminCommand(input) then
            break
        end
    end
    
    currentScreen = "main"
    needsRedraw = true
end

--==============================================================================
-- Main Event Loops
--==============================================================================

local function networkListener()
    while true do
        local senderId, message, protocolReceived = rednet.receive()
        
        if protocolReceived == BANK_PROTOCOL and message and message.type and bankHandlers[message.type] then
            bankHandlers[message.type](senderId, message)
        
        elseif protocolReceived == AUDIT_PROTOCOL and message and message.type == "stock_report" then
            local messageToVerify = textutils.serializeJSON(message.report)
            local signature = sha1.hmac_hex(AUDIT_SECRET_KEY, messageToVerify)
            if signature == message.signature then
                logActivity("Received valid, signed stock report from Auditor.")
                currentStock = message.report
                saveTableToFile(STOCK_DB, currentStock)
                adjustCurrencyRates()
                needsRedraw = true -- Update dashboard stats
            else
                logActivity("Received an INVALID or TAMPERED stock report! Ignoring.", true)
            end
        end
    end
end

local function guiHandler()
    while true do
        if needsRedraw then
            if currentScreen == "main" then
                drawMainMenu()
            elseif currentScreen == "log" then
                drawLogScreen()
            end
        end

        local event, p1, p2, p3 = os.pullEvent()
        if event == "key" then
            if currentScreen == "main" then
                local menuSize = 4
                if p1 == keys.up then
                    selectedMenuItem = (selectedMenuItem == 1) and menuSize or selectedMenuItem - 1
                    needsRedraw = true
                elseif p1 == keys.down then
                    selectedMenuItem = (selectedMenuItem == menuSize) and 1 or selectedMenuItem + 1
                    needsRedraw = true
                elseif p1 == keys.enter then
                    if selectedMenuItem == 1 then -- View Rates
                        -- Placeholder for rates screen
                    elseif selectedMenuItem == 2 then -- View Log
                        currentScreen = "log"
                        needsRedraw = true
                    elseif selectedMenuItem == 3 then -- Open Terminal
                        currentScreen = "terminal"
                        adminTerminal()
                    elseif selectedMenuItem == 4 then -- Shutdown
                        return -- End the GUI handler
                    end
                end
            elseif currentScreen == "log" then
                currentScreen = "main"
                needsRedraw = true
            end
        elseif event == "monitor_touch" then
            if currentScreen == "main" and p2 >= 9 and p2 <= 12 then
                selectedMenuItem = p2 - 8
                os.queueEvent("key", keys.enter)
            end
        elseif event == "terminate" then
            return
        end
    end
end

local function main()
    local computerTerm = term.current()
    computerTerm.clear()
    computerTerm.setCursorPos(1,1)
    
    print("Drunken OS Bank Server Initializing...")

    monitor = peripheral.find("monitor")
    if not monitor then
        print("FATAL: No advanced monitor attached. GUI cannot start.")
        return
    end

    loadAllData()
    
    print("Scanning for modems...")
    for _, name in ipairs(peripheral.getNames()) do
        if peripheral.getType(name) == "modem" then
            local modem_p = peripheral.wrap(name)
            if modem_p.isWireless() then
                wireless_modem_name = name
            else
                wired_modem_name = name
            end
        end
    end

    if not wireless_modem_name then print("FATAL: No wireless modem attached."); return end
    if not wired_modem_name then print("FATAL: No wired modem for secure interlink."); return end
    
    print("Found Wireless Modem on: " .. wireless_modem_name)
    print("Found Wired Modem on: " .. wired_modem_name)

    print("Identifying Mainframe via secure wired link...")
    local wired_periph = peripheral.wrap(wired_modem_name)
    local remote_names = wired_periph.getNamesRemote()
    for _, name in ipairs(remote_names) do
        if peripheral.getType(name) == "computer" then
            mainServerId = peripheral.call(name, "getID")
            break
        end
    end

    if not mainServerId then print("FATAL: No computer found on the other side of the wired modem."); return end
    print("Mainframe located via wired link at ID " .. mainServerId)

    print("Opening modems...")
    rednet.open(wireless_modem_name)
    rednet.open(wired_modem_name)
    
    rednet.host(BANK_PROTOCOL, "bank.server")
    
    startupComplete = true -- Stop logging to the physical terminal
    computerTerm.clear()
    computerTerm.setCursorPos(1,1)
    computerTerm.write("Bank Server started successfully.\nGUI is now active on the attached monitor.")
    
    -- Redirect all terminal I/O to the monitor for the GUI
    term.redirect(monitor)
    
    -- Run the main loops
    parallel.waitForAny(networkListener, guiHandler)
    
    -- When the loops exit (on shutdown), restore the original terminal
    term.redirect(computerTerm)
    monitor.setBackgroundColor(colors.black)
    monitor.clear()
    term.clear()
    term.setCursorPos(1,1)
    print("Bank Server has shut down.")
end

main()
