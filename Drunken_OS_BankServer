--[[
    Drunken OS - Bank Server (v1.2 - Admin Console)
    by Gemini Gem

    Purpose:
    This version adds a full terminal-based admin console to the Bank Server,
    allowing for direct management of the economy. It includes commands to
    add/remove currencies, view exchange rates, and set stock targets. It also
    includes basic user account management commands.

    Setup:
    - This computer must have a WIRELESS modem attached for general communication.
    - It must ALSO have a WIRED modem attached, connected via cable to the
      main Drunken_OS_Server.
    - An advanced monitor can optionally be placed for a future GUI.
]]

--==============================================================================
-- Embedded SHA1 & HMAC Library
--==============================================================================

local sha1 = {}
do
    local lshift, rshift, bor, band, bxor = bit32.lshift, bit32.rshift, bit32.bor, bit32.band, bit32.bxor
    local function rol(n, c) return bor(lshift(n, c), rshift(n, 32 - c)) end
    local function str_to_bin(str) local t = {}; for i = 1, #str do t[i] = string.byte(str, i) end; return t end
    local function bin_to_hex(bin) local hex = ""; for i = 1, #bin do hex = hex .. string.format("%02x", bin[i]) end; return hex end
    local function bin_to_str(bin) return string.char(table.unpack(bin)) end
    function sha1.hex(s) return bin_to_hex(sha1.bin(s)) end
    function sha1.bin(s)
      local H0, H1, H2, H3, H4 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
      local str = str_to_bin(s); local len = #str; str[len + 1] = 0x80
      for i = len + 2, (len + 64) - ((len + 8) % 64) do str[i] = 0 end
      local bit_len = len * 8
      for i = 0, 7 do str[#str + 1] = band(rshift(bit_len, (7 - i) * 8), 0xff) end
      for i = 1, #str, 64 do
        local W = {}; for j = 0, 15 do W[j] = bor(lshift(str[i+j*4], 24), lshift(str[i+j*4+1], 16), lshift(str[i+j*4+2], 8), str[i+j*4+3]) end
        for j = 16, 79 do W[j] = rol(bxor(W[j-3], W[j-8], W[j-14], W[j-16]), 1) end
        local a,b,c,d,e = H0,H1,H2,H3,H4
        for j = 0, 79 do
          local f, k
          if j < 20 then f = bxor(d, band(b, bxor(c, d))); k = 0x5A827999
          elseif j < 40 then f = bxor(b, c, d); k = 0x6ED9EBA1
          elseif j < 60 then f = bor(band(b, c), band(b, d), band(c, d)); k = 0x8F1BBCDC
          else f = bxor(b, c, d); k = 0xCA62C1D6 end
          local temp = rol(a, 5) + f + e + W[j] + k; e=d; d=c; c=rol(b, 30); b=a; a=temp
        end
        H0=(H0+a); H1=(H1+b); H2=(H2+c); H3=(H3+d); H4=(H4+e)
      end
      local result = {}; for i=0,3 do result[i+1]=band(rshift(H0,(3-i)*8),0xff) end; for i=0,3 do result[i+5]=band(rshift(H1,(3-i)*8),0xff) end; for i=0,3 do result[i+9]=band(rshift(H2,(3-i)*8),0xff) end; for i=0,3 do result[i+13]=band(rshift(H3,(3-i)*8),0xff) end; for i=0,3 do result[i+17]=band(rshift(H4,(3-i)*8),0xff) end
      return result
    end
    function sha1.hmac_hex(key, message)
        local blocksize = 64
        if #key > blocksize then key = bin_to_str(sha1.bin(key)) end
        local key_padding = {}; for i = 1, blocksize do key_padding[i] = string.byte(key, i) or 0 end
        local o_key_pad = ""; local i_key_pad = ""
        for i = 1, blocksize do
            o_key_pad = o_key_pad .. string.char(bxor(key_padding[i], 0x5c))
            i_key_pad = i_key_pad .. string.char(bxor(key_padding[i], 0x36))
        end
        local inner_hash = bin_to_str(sha1.bin(i_key_pad .. message))
        local final_hash = sha1.bin(o_key_pad .. inner_hash)
        return bin_to_hex(final_hash)
    end
end

--==============================================================================
-- Configuration & State
--==============================================================================

local accounts, currencyRates, currentStock = {}, {}, {}
local mainServerId = nil
local wired_modem_name = nil
local wireless_modem_name = nil
local adminInput = ""

-- Database file paths
local ACCOUNTS_DB = "bank_accounts.db"
local RATES_DB = "bank_rates.db"
local STOCK_DB = "bank_stock.db"
local LOG_FILE = "bank_server.log"

-- Rednet Protocols
local BANK_PROTOCOL = "DB_Bank"
local AUDIT_PROTOCOL = "DB_Audit"
local AUTH_INTERLINK_PROTOCOL = "Drunken_Auth_Interlink"

-- Auditor Turtle Configuration
local AUDIT_SECRET_KEY = "YourSecretAuditKeyHere"

--==============================================================================
-- UI & Logging (Terminal)
--==============================================================================

local function logActivity(message, isError)
    local prefix = isError and "[ERROR] " or "[INFO] "
    local logEntry = os.date("[%Y-%m-%d %H:%M:%S] ") .. prefix .. message
    
    term.setCursorPos(1, term.getCursorPos())
    term.clearLine()
    print(logEntry)
    
    local file = fs.open(LOG_FILE, "a")
    if file then
        file.writeLine(logEntry)
        file.close()
    end
    
    term.write("> " .. adminInput)
end

--==============================================================================
-- Data Persistence Functions
--==============================================================================

local function saveTableToFile(path, data)
    local file = fs.open(path, "w")
    if not file then logActivity("Could not open " .. path .. " for writing.", true); return false end
    local success, err = pcall(function() file.write(textutils.serialize(data)); file.close() end)
    if not success then logActivity("Failed to write to " .. path .. ": " .. tostring(err), true); return false end
    return true
end

local function loadTableFromFile(path)
    if fs.exists(path) then
        local file = fs.open(path, "r")
        if file then
            local data = file.readAll(); file.close()
            local success, result = pcall(textutils.unserialize, data)
            if success and type(result) == "table" then return result
            else logActivity("Corrupted data in " .. path .. ". A new file will be created.", true) end
        end
    end
    return {}
end

local function loadAllData()
    accounts = loadTableFromFile(ACCOUNTS_DB)
    currencyRates = loadTableFromFile(RATES_DB)
    currentStock = loadTableFromFile(STOCK_DB)
    logActivity("All banking data loaded successfully.")
end

--==============================================================================
-- Dynamic Economy Engine
--==============================================================================

local function adjustCurrencyRates()
    logActivity("Adjusting currency rates based on new stock report...")
    local changed = false
    for item, data in pairs(currencyRates) do
        if data.target and data.target > 0 then
            local stock = currentStock[item] or 0
            if stock == 0 then stock = 1 end
            local ratio = data.target / stock
            local price_multiplier = ratio ^ 0.5
            local new_price = math.floor(data.base * price_multiplier + 0.5)
            local max_price = data.base * 5
            local min_price = 1
            new_price = math.max(min_price, math.min(max_price, new_price))

            if new_price ~= data.current then
                logActivity(string.format("'%s' price changed from $%d to $%d (Stock: %d/%d)", item, data.current, new_price, currentStock[item] or 0, data.target))
                currencyRates[item].current = new_price
                changed = true
            end
        end
    end

    if changed then
        if not saveTableToFile(RATES_DB, currencyRates) then
            logActivity("Failed to save updated currency rates.", true)
        end
    end
end

--==============================================================================
-- Network Request Handlers
--==============================================================================

local bankHandlers = {}

function bankHandlers.login(senderId, message)
    logActivity("Forwarding login request for '" .. message.user .. "' to main server via wired modem.")
    rednet.send(mainServerId, {
        type = "auth_check",
        user = message.user,
        pass_hash = sha1.hex(message.pass)
    }, AUTH_INTERLINK_PROTOCOL)

    local _, response, proto = rednet.receive(AUTH_INTERLINK_PROTOCOL, 5)

    if response and response.user == message.user and response.success then
        logActivity("Auth success for '" .. message.user .. "'.")
        if not accounts[message.user] then accounts[message.user] = 0 end
        rednet.send(senderId, { success = true, balance = accounts[message.user] }, BANK_PROTOCOL)
    else
        logActivity("Auth failed for '" .. message.user .. "'.", true)
        rednet.send(senderId, { success = false, reason = "Invalid username or password." }, BANK_PROTOCOL)
    end
end

function bankHandlers.get_balance_and_rates(senderId, message)
    rednet.send(senderId, {
        balance = accounts[message.user] or 0,
        rates = currencyRates
    }, BANK_PROTOCOL)
end

function bankHandlers.deposit(senderId, message)
    local user, items = message.user, message.items
    local total_value = 0
    for _, item in ipairs(items) do
        if currencyRates[item.name] then
            total_value = total_value + (item.count * currencyRates[item.name].current)
        end
    end

    if total_value > 0 then
        accounts[user] = (accounts[user] or 0) + total_value
        if saveTableToFile(ACCOUNTS_DB, accounts) then
            rednet.send(senderId, { success = true, newBalance = accounts[user], deposited_value = total_value }, BANK_PROTOCOL)
            logActivity(string.format("User '%s' deposited items for $%d.", user, total_value))
        else
            rednet.send(senderId, { success = false, reason = "Server database error." }, BANK_PROTOCOL)
        end
    else
        rednet.send(senderId, { success = false, reason = "No valid currency detected." }, BANK_PROTOCOL)
    end
end

function bankHandlers.withdraw_item(senderId, message)
    local user, itemName, count = message.user, message.item_name, message.count
    local rateInfo = currencyRates[itemName]

    if not rateInfo then
        rednet.send(senderId, { success = false, reason = "Invalid currency type." }, BANK_PROTOCOL)
        return
    end

    local totalCost = rateInfo.current * count
    if (accounts[user] or 0) >= totalCost then
        if (currentStock[itemName] or 0) >= count then
            accounts[user] = accounts[user] - totalCost
            if saveTableToFile(ACCOUNTS_DB, accounts) then
                rednet.send(senderId, { success = true, newBalance = accounts[user] }, BANK_PROTOCOL)
                logActivity(string.format("User '%s' approved for withdrawal of %d %s for $%d.", user, count, itemName, totalCost))
            else
                accounts[user] = accounts[user] + totalCost -- Refund on DB error
                rednet.send(senderId, { success = false, reason = "Server database error." }, BANK_PROTOCOL)
            end
        else
            rednet.send(senderId, { success = false, reason = "Insufficient stock in vault." }, BANK_PROTOCOL)
        end
    else
        rednet.send(senderId, { success = false, reason = "Insufficient funds." }, BANK_PROTOCOL)
    end
end

--==============================================================================
-- Admin Command Handlers
--==============================================================================

local adminCommands = {}

local function parseAdminArgs(args)
    local command = table.remove(args, 1)
    if not args or #args == 0 then return command, nil, nil end
    local itemName = args[1]
    local numberValue = tonumber(args[2])
    if #args > 2 and not tonumber(args[2]) then
        itemName = table.concat(args, " ", 1, 2)
        numberValue = tonumber(args[3])
    end
    return command, itemName, numberValue
end

function adminCommands.help()
    logActivity("--- Bank Admin Commands ---")
    logActivity("balance <user>")
    logActivity("setbalance <user> <amount>")
    logActivity("give <user> <amount>")
    logActivity("addcurrency <item_name> <base_rate>")
    logActivity("delcurrency <item_name>")
    logActivity("listrates")
    logActivity("settarget <item_name> <target_amount>")
end

function adminCommands.balance(args)
    local _, user = parseAdminArgs(args)
    if not user then logActivity("Usage: balance <user>", true); return end
    logActivity("Balance for " .. user .. ": " .. (accounts[user] or 0))
end

function adminCommands.setbalance(args)
    local _, user, amount = parseAdminArgs(args)
    if not user or not amount then logActivity("Usage: setbalance <user> <amount>", true); return end
    accounts[user] = amount; saveTableToFile(ACCOUNTS_DB, accounts)
    logActivity("Set balance for " .. user .. " to " .. amount)
end

function adminCommands.give(args)
    local _, user, amount = parseAdminArgs(args)
    if not user or not amount then logActivity("Usage: give <user> <amount>", true); return end
    accounts[user] = (accounts[user] or 0) + amount; saveTableToFile(ACCOUNTS_DB, accounts)
    logActivity("Gave " .. amount .. " to " .. user .. ". New balance: " .. accounts[user])
end

function adminCommands.addcurrency(args)
    local _, itemName, baseRate = parseAdminArgs(args)
    if not itemName or not baseRate then logActivity("Usage: addcurrency <item_name> <base_rate>", true); return end
    if currencyRates[itemName] then logActivity("Currency '" .. itemName .. "' already exists.", true); return end
    currencyRates[itemName] = { base = baseRate, current = baseRate, target = nil }
    if saveTableToFile(RATES_DB, currencyRates) then logActivity("Added new currency '" .. itemName .. "' with base rate $" .. baseRate)
    else logActivity("Failed to save new currency.", true) end
end

function adminCommands.delcurrency(args)
    local _, itemName = parseAdminArgs(args)
    if not itemName then logActivity("Usage: delcurrency <item_name>", true); return end
    if not currencyRates[itemName] then logActivity("Currency '" .. itemName .. "' does not exist.", true); return end
    currencyRates[itemName] = nil
    if saveTableToFile(RATES_DB, currencyRates) then logActivity("Removed currency '" .. itemName .. "'.")
    else logActivity("Failed to remove currency.", true) end
end

function adminCommands.listrates()
    logActivity("--- Current Exchange Rates ---")
    for name, data in pairs(currencyRates) do
        local stock = currentStock[name] or 0
        local target = data.target and ("/" .. data.target) or "/N/A"
        logActivity(string.format("- %s: $%d (Base: $%d) | Stock: %d%s", name, data.current, data.base, stock, target))
    end
end

function adminCommands.settarget(args)
    local _, itemName, targetAmount = parseAdminArgs(args)
    if not itemName or not targetAmount then logActivity("Usage: settarget <item_name> <target_amount>", true); return end
    if not currencyRates[itemName] then logActivity("Currency '" .. itemName .. "' does not exist. Use addcurrency first.", true); return end
    currencyRates[itemName].target = targetAmount
    if saveTableToFile(RATES_DB, currencyRates) then logActivity("Set target stock for '" .. itemName .. "' to " .. targetAmount)
    else logActivity("Failed to set target.", true) end
end

local function handleAdminCommand(command)
    local args = {}; for arg in string.gmatch(command, "[^%s]+") do table.insert(args, arg) end
    local cmd = args[1]; if adminCommands[cmd] then adminCommands[cmd](args) else logActivity("Unknown command. Type 'help'.") end
end

--==============================================================================
-- Main Event Loops
--==============================================================================

local function networkListener()
    while true do
        local senderId, message, protocolReceived = rednet.receive()
        
        if protocolReceived == BANK_PROTOCOL and message and message.type and bankHandlers[message.type] then
            bankHandlers[message.type](senderId, message)
        
        elseif protocolReceived == AUDIT_PROTOCOL and message and message.type == "stock_report" then
            local messageToVerify = textutils.serialize(message.report)
            local signature = sha1.hmac_hex(AUDIT_SECRET_KEY, messageToVerify)
            if signature == message.signature then
                logActivity("Received valid, signed stock report from Auditor.")
                currentStock = message.report
                saveTableToFile(STOCK_DB, currentStock)
                adjustCurrencyRates()
            else
                logActivity("Received an INVALID or TAMPERED stock report! Ignoring.", true)
            end
        end
    end
end

local function adminTerminal()
    while true do
        term.write("> ")
        adminInput = read()
        if adminInput and adminInput ~= "" then
            handleAdminCommand(adminInput)
        end
    end
end

local function main()
    term.clear()
    term.setCursorPos(1,1)
    print("Drunken OS Bank Server Initializing...")

    loadAllData()
    
    print("Scanning for modems...")
    for _, name in ipairs(peripheral.getNames()) do
        if peripheral.getType(name) == "modem" then
            local modem = peripheral.wrap(name)
            if modem.isWireless() then
                wireless_modem_name = name
            else
                wired_modem_name = name
            end
        end
    end

    if not wireless_modem_name then print("FATAL: No wireless modem attached."); return end
    if not wired_modem_name then print("FATAL: No wired modem for secure interlink."); return end
    
    print("Found Wireless Modem on: " .. wireless_modem_name)
    print("Found Wired Modem on: " .. wired_modem_name)

    print("Identifying Mainframe via secure wired link...")
    local wired_periph = peripheral.wrap(wired_modem_name)
    local remote_names = wired_periph.getNamesRemote()
    mainServerId = nil
    for _, name in ipairs(remote_names) do
        if peripheral.getType(name) == "computer" then
            mainServerId = peripheral.call(name, "getID")
            break
        end
    end

    if not mainServerId then print("FATAL: No computer found on the other side of the wired modem."); return end
    print("Mainframe located via wired link at ID " .. mainServerId)

    print("Opening wireless modem on: " .. wireless_modem_name)
    rednet.open(wireless_modem_name)
    print("Opening wired modem on: " .. wired_modem_name)
    rednet.open(wired_modem_name)
    
    rednet.host(BANK_PROTOCOL, "bank.server")
    
    print("------------------------------------------")
    logActivity("Bank Server started successfully.")
    print("Listening for bank and audit messages.")
    print("Type 'help' for a list of commands.")
    print("------------------------------------------")
    
    parallel.waitForAny(networkListener, adminTerminal)
end

main()

