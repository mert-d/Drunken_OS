--[[
    Drunken OS - Bank Server (v2.8 - Transaction Fix)
    by Gemini Gem & MuhendizBey

    Purpose:
    This definitive version fixes a critical data type mismatch in the
    deposit and withdrawal functions, which caused a server-side crash
    when processing transactions.

    Key Changes:
    - The `deposit` and `withdraw_item` network handlers have been repaired.
    - They now correctly perform arithmetic on the `account.balance` number,
      not the entire account table.
    - This resolves the "attempt to perform arithmetic on a table value" error.
]]

--==============================================================================
-- API & Library Initialization
--==============================================================================

-- Load our new, centralized cryptography library.
local crypto = require("lib.sha1_hmac")

--==============================================================================
-- Configuration & State
--==============================================================================

local accounts, currencyRates, currentStock = {}, {}, {}
local mainServerId = nil
local wired_modem_name, wireless_modem_name = nil, nil
local adminInput = ""
local logHistory = {}
local monitor = nil
local startupComplete = false -- Flag to control logging to terminal

-- Database file paths
local LOGS_DIR = "logs"
local TRANSACTIONS_DIR = LOGS_DIR .. "/transactions"
local CURRENCIES_DIR = "currencies"
local ACCOUNTS_DB = "bank_accounts.db"
local STOCK_DB = "bank_stock.db"
local LOG_FILE = LOGS_DIR .. "/bank_server.log"

-- Rednet Protocols
local BANK_PROTOCOL = "DB_Bank"
local AUDIT_PROTOCOL = "DB_Audit"
local AUTH_INTERLINK_PROTOCOL = "Drunken_Auth_Interlink"

-- Auditor Turtle Configuration
local AUDIT_SECRET_KEY = "YourSecretAuditKeyHere"

--==============================================================================
-- UI & Theme Configuration
--==============================================================================

local hasColor = term.isColor and term.isColor()
local function safeColor(colorName, fallbackColor)
    if hasColor and colors[colorName] ~= nil then return colors[colorName] end
    return fallbackColor
end

local theme = {
    bg = safeColor("black", colors.black),
    text = safeColor("white", colors.white),
    windowBg = safeColor("darkGray", colors.gray),
    title = safeColor("lightBlue", colors.lightBlue),
    prompt = safeColor("cyan", colors.cyan),
    statusBarBg = safeColor("gray", colors.lightGray),
    statusBarText = safeColor("white", colors.white),
    highlightBg = safeColor("blue", colors.blue),
    highlightText = safeColor("white", colors.white),
    error = safeColor("red", colors.red),
}

local currentScreen = "main"
local selectedMenuItem = 1
local needsRedraw = true

--==============================================================================
-- Logging Functions
--==============================================================================

local function logActivity(message, isError)
    local prefix = isError and "[ERROR] " or "[INFO] "
    local logEntry = os.date("[%Y-%m-%d %H:%M:%S] ") .. prefix .. message
    
    if not startupComplete then
        term.write(logEntry .. "\n")
    end
    
    if not fs.exists(LOGS_DIR) then fs.makeDir(LOGS_DIR) end
    local file = fs.open(LOG_FILE, "a")
    if file then
        file.writeLine(logEntry)
        file.close()
    end

    table.insert(logHistory, logEntry)
    if #logHistory > 200 then table.remove(logHistory, 1) end
    
    if currentScreen == "log" then
        needsRedraw = true
    end
end

local function logTransaction(username, message)
    local logEntry = os.date("[%Y-%m-%d %H:%M:%S] ") .. message
    if not fs.exists(LOGS_DIR) then fs.makeDir(LOGS_DIR) end
    if not fs.exists(TRANSACTIONS_DIR) then fs.makeDir(TRANSACTIONS_DIR) end

    local file = fs.open(TRANSACTIONS_DIR .. "/" .. username .. ".log", "a")
    if file then
        file.writeLine(logEntry)
        file.close()
    end
end

--==============================================================================
-- Graphical UI Functions
--==============================================================================

local function drawMainMenu()
    if not monitor then return end
    local w, h = monitor.getSize()
    monitor.setBackgroundColor(theme.windowBg)
    monitor.clear()
    
    monitor.setBackgroundColor(theme.title)
    monitor.setCursorPos(1, 1); monitor.write(string.rep(" ", w))
    monitor.setTextColor(colors.white)
    local titleText = " Drunken OS Bank Server "
    monitor.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1)
    monitor.write(titleText)

    monitor.setBackgroundColor(theme.windowBg)
    monitor.setTextColor(theme.text)
    monitor.setCursorPos(3, 3); monitor.write("System Status: "); monitor.setTextColor(colors.green); monitor.write("ONLINE")
    monitor.setTextColor(theme.text)
    monitor.setCursorPos(3, 4); monitor.write("Mainframe Link: "); monitor.setTextColor(mainServerId and colors.green or colors.red); monitor.write(mainServerId and "CONNECTED" or "DISCONNECTED")
    
    local numAccounts = 0; for _ in pairs(accounts) do numAccounts = numAccounts + 1 end
    monitor.setCursorPos(3, 5); monitor.write("Managed Accounts: " .. numAccounts)
    local numCurrencies = 0; for _ in pairs(currencyRates) do numCurrencies = numCurrencies + 1 end
    monitor.setCursorPos(3, 6); monitor.write("Tracked Currencies: " .. numCurrencies)

    local menuOptions = { "View Rates & Stock", "View Server Log", "Open Admin Terminal", "Shutdown Server" }
    for i, option in ipairs(menuOptions) do
        monitor.setCursorPos(3, 8 + i)
        if i == selectedMenuItem then
            monitor.setBackgroundColor(theme.highlightBg); monitor.setTextColor(theme.highlightText)
            monitor.write("> " .. option .. string.rep(" ", w - 6 - #option))
        else
            monitor.setBackgroundColor(theme.windowBg); monitor.setTextColor(theme.text)
            monitor.write("  " .. option .. string.rep(" ", w - 6 - #option))
        end
    end

    monitor.setBackgroundColor(theme.statusBarBg)
    monitor.setCursorPos(1, h); monitor.write(string.rep(" ", w))
    monitor.setTextColor(theme.statusBarText)
    local footerText = "Use UP/DOWN & ENTER or Click to Navigate"
    monitor.setCursorPos(math.floor((w - #footerText) / 2) + 1, h)
    monitor.write(footerText)
    
    needsRedraw = false
end

local function drawLogScreen()
    if not monitor then return end
    local w, h = monitor.getSize()
    monitor.setBackgroundColor(theme.windowBg); monitor.clear()
    monitor.setBackgroundColor(theme.title); monitor.setCursorPos(1, 1); monitor.write(string.rep(" ", w))
    monitor.setTextColor(colors.white); local titleText = " Live Server Log "; monitor.setCursorPos(math.floor((w - #titleText) / 2) + 1, 1); monitor.write(titleText)
    
    local logAreaHeight = h - 2
    local y = h - 1
    for i = #logHistory, 1, -1 do
        if y < 2 then break end
        local line = logHistory[i]
        monitor.setCursorPos(2, y); monitor.write(string.sub(line, 1, w-2))
        y = y - 1
    end

    monitor.setBackgroundColor(theme.statusBarBg); monitor.setCursorPos(1, h); monitor.write(string.rep(" ", w))
    monitor.setTextColor(theme.statusBarText); local footerText = "Press any key to return to main menu"; monitor.setCursorPos(math.floor((w - #footerText) / 2) + 1, h); monitor.write(footerText)
    
    needsRedraw = false
end

--==============================================================================
-- Data Persistence & Core Logic
--==============================================================================

local function saveTableToFile(path, data)
    local file = fs.open(path, "w")
    if not file then logActivity("Could not open " .. path .. " for writing.", true); return false end
    local success, err = pcall(function() file.write(textutils.serializeJSON(data)); file.close() end)
    if not success then logActivity("Failed to write to " .. path .. ": " .. tostring(err), true); return false end
    return true
end

local function loadTableFromFile(path)
    if fs.exists(path) then
        local file = fs.open(path, "r")
        if file then
            local data = file.readAll(); file.close()
            local success, result = pcall(textutils.unserializeJSON, data)
            if success and type(result) == "table" then return result
            else logActivity("Corrupted data in " .. path .. ". A new file will be created.", true) end
        end
    end
    return {}
end

local function loadAllData()
    accounts = loadTableFromFile(ACCOUNTS_DB)
    
    currencyRates = {}
    if fs.exists(CURRENCIES_DIR) then
        for _, file in ipairs(fs.list(CURRENCIES_DIR)) do
            local itemName = file:match("(.+)%.json$")
            if itemName then
                currencyRates[itemName] = loadTableFromFile(fs.combine(CURRENCIES_DIR, file))
            end
        end
    end

    currentStock = loadTableFromFile(STOCK_DB)
    logActivity("All banking data loaded successfully.")
end

local function adjustCurrencyRates()
    logActivity("Adjusting currency rates based on new stock report...")
    local changed = false
    for item, data in pairs(currencyRates) do
        if data.target and data.target > 0 then
            local stock = currentStock[item] or 0
            if stock == 0 then stock = 1 end
            local ratio = data.target / stock
            local price_multiplier = ratio ^ 0.5
            local new_price = math.floor(data.base * price_multiplier + 0.5)
            local max_price = data.base * 5
            local min_price = 1
            new_price = math.max(min_price, math.min(max_price, new_price))

            if new_price ~= data.current then
                logActivity(string.format("'%s' price changed from $%d to $%d (Stock: %d/%d)", item, data.current, new_price, currentStock[item] or 0, data.target))
                currencyRates[item].current = new_price
                changed = true
            end
        end
    end

    if changed then
        for itemName, data in pairs(currencyRates) do
            if not saveTableToFile(fs.combine(CURRENCIES_DIR, itemName .. ".json"), data) then
                 logActivity("Failed to save updated rate for " .. itemName, true)
            end
        end
    end
end

local bankHandlers = {}

-- THE FIX: The handler now correctly uses message.pass_hash.
function bankHandlers.login(senderId, message)
    local user, pass_hash = message.user, message.pass_hash
    local account = accounts[user]

    if account then
        -- This is an existing bank customer.
        if account.pass_hash == pass_hash then
            logTransaction(user, "login", "SUCCESS")
            rednet.send(senderId, {
                success = true,
                balance = account.balance, -- THE FIX: Send the number, not the table.
                rates = currencyRates
            }, BANK_PROTOCOL)
        else
            logTransaction(user, "login", "FAIL - Invalid Credentials")
            rednet.send(senderId, { success = false, reason = "Invalid credentials." }, BANK_PROTOCOL)
        end
    else
        -- This is a potential new bank customer.
        logActivity("New customer login attempt: '" .. user .. "'. Verifying with Mainframe...")
        
        rednet.send(mainServerId, { type = "user_exists_check", user = user }, AUTH_INTERLINK_PROTOCOL)
        local _, response = rednet.receive(AUTH_INTERLINK_PROTOCOL, 5)

        if response and response.exists then
            logActivity("Mainframe verified user. Creating new bank account for '" .. user .. "'.")
            accounts[user] = {
                pass_hash = pass_hash,
                balance = 0
            }
            if saveTableToFile(ACCOUNTS_DB, accounts) then
                rednet.send(senderId, {
                    success = true,
                    balance = 0, -- Send the number 0 for new accounts.
                    rates = currencyRates
                }, BANK_PROTOCOL)
                logTransaction(user, "login", "SUCCESS - New account created")
            else
                logActivity("Failed to save new account for " .. user, true)
                rednet.send(senderId, { success = false, reason = "Bank database error." }, BANK_PROTOCOL)
            end
        else
            logActivity("Mainframe verification failed for '" .. user .. "'. Denying access.", true)
            rednet.send(senderId, { success = false, reason = "User is not registered in the Mainframe." }, BANK_PROTOCOL)
            logTransaction(user, "login", "FAIL - User does not exist in Mainframe")
        end
    end
end

function bankHandlers.get_balance_and_rates(senderId, message)
    local account = accounts[message.user]
    rednet.send(senderId, {
        -- THE FIX: Send account.balance (number) or 0, not the whole table.
        balance = account and account.balance or 0,
        rates = currencyRates
    }, BANK_PROTOCOL)
end

function bankHandlers.deposit(senderId, message)
    local user, items = message.user, message.items
    local total_value = 0
    local transaction_summary = {}

    for _, item in ipairs(items) do
        if currencyRates[item.name] then
            local value = item.count * currencyRates[item.name].current
            total_value = total_value + value
            table.insert(transaction_summary, string.format("%d %s for $%d", item.count, item.name, value))
        end
    end

    if total_value > 0 then
        -- THE FIX: We now correctly add to the .balance field.
        accounts[user].balance = accounts[user].balance + total_value
        
        if saveTableToFile(ACCOUNTS_DB, accounts) then
            rednet.send(senderId, { success = true, newBalance = accounts[user].balance, deposited_value = total_value }, BANK_PROTOCOL)
            local log_msg = string.format("DEPOSIT of $%d. Details: %s", total_value, table.concat(transaction_summary, ", "))
            logTransaction(user, log_msg)
            logActivity(string.format("User '%s' deposited items for $%d.", user, total_value))
        else
            rednet.send(senderId, { success = false, reason = "Server database error." }, BANK_PROTOCOL)
        end
    else
        rednet.send(senderId, { success = false, reason = "No valid currency detected." }, BANK_PROTOCOL)
    end
end

function bankHandlers.withdraw_item(senderId, message)
    local user, itemName, count = message.user, message.item_name, message.count
    local rateInfo = currencyRates[itemName]

    if not rateInfo then
        rednet.send(senderId, { success = false, reason = "Invalid currency type." }, BANK_PROTOCOL)
        return
    end

    local totalCost = rateInfo.current * count
    if accounts[user].balance >= totalCost then
        if (currentStock[itemName] or 0) >= count then
            -- THE FIX: We now correctly subtract from the .balance field.
            accounts[user].balance = accounts[user].balance - totalCost
            
            if saveTableToFile(ACCOUNTS_DB, accounts) then
                rednet.send(senderId, { success = true, newBalance = accounts[user].balance }, BANK_PROTOCOL)
                local log_msg = string.format("WITHDRAW of $%d (%d x %s)", totalCost, count, itemName)
                logTransaction(user, log_msg)
                logActivity(string.format("User '%s' approved for withdrawal of %d %s for $%d.", user, count, itemName, totalCost))
            else
                accounts[user].balance = accounts[user].balance + totalCost -- Refund on DB error
                rednet.send(senderId, { success = false, reason = "Server database error." }, BANK_PROTOCOL)
            end
        else
            rednet.send(senderId, { success = false, reason = "Insufficient stock in vault." }, BANK_PROTOCOL)
        end
    else
        rednet.send(senderId, { success = false, reason = "Insufficient funds." }, BANK_PROTOCOL)
    end
end

--==============================================================================
-- Admin Command Handlers & Terminal
--==============================================================================

local adminCommands = {}

local function parseAdminArgs(args)
    local command = table.remove(args, 1)
    if not args or #args == 0 then return command, nil, nil end
    local itemName = args[1]
    local numberValue = tonumber(args[2])
    if #args > 2 and not tonumber(args[2]) then
        itemName = table.concat(args, " ", 1, 2)
        numberValue = tonumber(args[3])
    end
    return command, itemName, numberValue
end

function adminCommands.help()
    print("--- Bank Admin Commands ---")
    print("balance <user>")
    print("setbalance <user> <amount>")
    print("give <user> <amount>")
    print("makecard <user>")
    print("addcurrency <item_name> <base_rate>")
    print("delcurrency <item_name>")
    print("listrates")
    print("settarget <item_name> <target_amount>")
    print("exit - Closes the terminal and returns to the GUI.")
end

function adminCommands.balance(args)
    local _, user = parseAdminArgs(args)
    if not user then print("Usage: balance <user>"); return end
    print("Balance for " .. user .. ": " .. (accounts[user] or 0))
end

function adminCommands.setbalance(args)
    local _, user, amount = parseAdminArgs(args)
    if not user or not amount then print("Usage: setbalance <user> <amount>"); return end
    accounts[user] = amount; saveTableToFile(ACCOUNTS_DB, accounts)
    print("Set balance for " .. user .. " to " .. amount)
end

function adminCommands.give(args)
    local _, user, amount = parseAdminArgs(args)
    if not user or not amount then print("Usage: give <user> <amount>"); return end
    accounts[user] = (accounts[user] or 0) + amount; saveTableToFile(ACCOUNTS_DB, accounts)
    print("Gave " .. amount .. " to " .. user .. ". New balance: " .. accounts[user])
end

function adminCommands.makecard(args)
    local _, user = parseAdminArgs(args)
    if not user then
        print("Usage: makecard <username>")
        return
    end
    
    print("Verifying user with Mainframe...")
    rednet.send(mainServerId, { type = "user_exists_check", user = user }, AUTH_INTERLINK_PROTOCOL)
    local _, response = rednet.receive(AUTH_INTERLINK_PROTOCOL, 5)

    if not response or not response.exists then
        print("Error: Mainframe reports user '" .. user .. "' does not exist.")
        return
    end

    print("User verified. Please insert a blank disk.")
    local disk = peripheral.find("drive")
    if not disk then
        print("Error: No disk drive attached to this server.")
        return
    end

    if not disk.isDiskPresent() then
        print("Error: No disk in the drive.")
        return
    end

    local mount_path = disk.getMountPath()
    if not mount_path then
        print("Error: Could not get disk mount path.")
        return
    end

    disk.setDiskLabel("Drunken Beard Bank Card (" .. user .. ")")
    local cardFile = fs.open(mount_path .. "/.bankcard", "w")
    if cardFile then
        cardFile.write(user)
        cardFile.close()
    else
        print("Error: Could not write main card file to disk.")
        return
    end

    local descFile = fs.open(mount_path .. "/.description", "w")
    if descFile then
        local description = "Property of: " .. user .. "\n" ..
                            "Account Type: Standard\n\n" ..
                            "A proud member of the Drunken Beard banking system."
        descFile.write(description)
        descFile.close()
        print("Successfully created bank card with description for " .. user)
    else
        print("Error: Could not write description file to disk.")
    end
end

function adminCommands.addcurrency(args)
    local _, itemName, baseRate = parseAdminArgs(args)
    if not itemName or not baseRate then print("Usage: addcurrency <item_name> <base_rate>"); return end
    if currencyRates[itemName] then print("Currency '" .. itemName .. "' already exists."); return end
    if not fs.isDir(CURRENCIES_DIR) then fs.makeDir(CURRENCIES_DIR) end

    currencyRates[itemName] = { base = baseRate, current = baseRate, target = nil }
    if saveTableToFile(fs.combine(CURRENCIES_DIR, itemName .. ".json"), currencyRates[itemName]) then
        print("Added new currency '" .. itemName .. "' with base rate $" .. baseRate)
    else
        currencyRates[itemName] = nil -- Revert change if save failed
        print("Failed to save new currency.")
    end
end

function adminCommands.delcurrency(args)
    local _, itemName = parseAdminArgs(args)
    if not itemName then print("Usage: delcurrency <item_name>"); return end
    if not currencyRates[itemName] then print("Currency '" .. itemName .. "' does not exist."); return end
    currencyRates[itemName] = nil
    
    local path = fs.combine(CURRENCIES_DIR, itemName .. ".json")
    if fs.exists(path) then fs.delete(path) end
    
    print("Removed currency '" .. itemName .. "'.")
end

function adminCommands.listrates()
    print("--- Current Exchange Rates ---")
    for name, data in pairs(currencyRates) do
        local stock = currentStock[name] or 0
        local target = data.target and ("/" .. data.target) or "/N/A"
        print(string.format("- %s: $%d (Base: $%d) | Stock: %d%s", name, data.current, data.base, stock, target))
    end
end

function adminCommands.settarget(args)
    local _, itemName, targetAmount = parseAdminArgs(args)
    if not itemName or not targetAmount then print("Usage: settarget <item_name> <target_amount>"); return end
    if not currencyRates[itemName] then print("Currency '" .. itemName .. "' does not exist."); return end
    
    currencyRates[itemName].target = targetAmount
    if saveTableToFile(fs.combine(CURRENCIES_DIR, itemName .. ".json"), currencyRates[itemName]) then
        print("Set target stock for '" .. itemName .. "' to " .. targetAmount)
    else
        print("Failed to set target.")
    end
end

local function handleAdminCommand(command)
    local args = {}; for arg in string.gmatch(command, "[^%s]+") do table.insert(args, arg) end
    local cmd = args[1]
    if cmd == "exit" then return false end -- Signal to exit terminal
    if adminCommands[cmd] then adminCommands[cmd](args) else print("Unknown command. Type 'help'.") end
    return true -- Continue terminal session
end

local function adminTerminal()
    term.setBackgroundColor(colors.black)
    term.setTextColor(colors.white)
    term.clear()
    term.setCursorPos(1,1)
    print("Bank Admin Terminal. Type 'exit' to return to GUI.")
    
    while true do
        term.write("> ")
        local input = read()
        if not handleAdminCommand(input) then
            break
        end
    end
    
    currentScreen = "main"
    needsRedraw = true
end

--==============================================================================
-- Main Event Loops
--==============================================================================

local function networkListener()
    while true do
        local senderId, message, protocolReceived = rednet.receive()
        
        if protocolReceived == BANK_PROTOCOL and message and message.type and bankHandlers[message.type] then
            bankHandlers[message.type](senderId, message)
        
        elseif protocolReceived == AUDIT_PROTOCOL and message and message.type == "stock_report" then
            local messageToVerify = textutils.serializeJSON(message.report)
            local signature = crypto.hmac_hex(AUDIT_SECRET_KEY, messageToVerify)
            if signature == message.signature then
                logActivity("Received valid, signed stock report from Auditor.")
                currentStock = message.report
                saveTableToFile(STOCK_DB, currentStock)
                adjustCurrencyRates()
                needsRedraw = true -- Update dashboard stats
            else
                logActivity("Received an INVALID or TAMPERED stock report! Ignoring.", true)
            end
        end
    end
end

local function guiHandler()
    while true do
        if needsRedraw then
            if currentScreen == "main" then
                drawMainMenu()
            elseif currentScreen == "log" then
                drawLogScreen()
            end
        end

        local event, p1, p2, p3 = os.pullEvent()
        if event == "key" then
            if currentScreen == "main" then
                local menuSize = 4
                if p1 == keys.up then
                    selectedMenuItem = (selectedMenuItem == 1) and menuSize or selectedMenuItem - 1
                    needsRedraw = true
                elseif p1 == keys.down then
                    selectedMenuItem = (selectedMenuItem == menuSize) and 1 or selectedMenuItem + 1
                    needsRedraw = true
                elseif p1 == keys.enter then
                    if selectedMenuItem == 1 then -- View Rates
                        -- Placeholder for rates screen
                    elseif selectedMenuItem == 2 then -- View Log
                        currentScreen = "log"
                        needsRedraw = true
                    elseif selectedMenuItem == 3 then -- Open Terminal
                        currentScreen = "terminal"
                        adminTerminal()
                    elseif selectedMenuItem == 4 then -- Shutdown
                        return -- End the GUI handler
                    end
                end
            elseif currentScreen == "log" then
                currentScreen = "main"
                needsRedraw = true
            end
        elseif event == "monitor_touch" then
            if currentScreen == "main" and p2 >= 9 and p2 <= 12 then
                selectedMenuItem = p2 - 8
                os.queueEvent("key", keys.enter)
            end
        elseif event == "terminate" then
            return
        end
    end
end

local function main()
    local computerTerm = term.current()
    computerTerm.clear()
    computerTerm.setCursorPos(1,1)
    
    print("Drunken OS Bank Server Initializing...")

    monitor = peripheral.find("monitor")
    if not monitor then
        print("FATAL: No advanced monitor attached. GUI cannot start.")
        return
    end

    loadAllData()
    
    print("Scanning for modems...")
    for _, name in ipairs(peripheral.getNames()) do
        if peripheral.getType(name) == "modem" then
            local modem_p = peripheral.wrap(name)
            if modem_p.isWireless() then
                wireless_modem_name = name
            else
                wired_modem_name = name
            end
        end
    end

    if not wireless_modem_name then print("FATAL: No wireless modem attached."); return end
    if not wired_modem_name then print("FATAL: No wired modem for secure interlink."); return end
    
    print("Found Wireless Modem on: " .. wireless_modem_name)
    print("Found Wired Modem on: " .. wired_modem_name)

    print("Identifying Mainframe via secure wired link...")
    local wired_periph = peripheral.wrap(wired_modem_name)
    local remote_names = wired_periph.getNamesRemote()
    for _, name in ipairs(remote_names) do
        if peripheral.getType(name) == "computer" then
            mainServerId = peripheral.call(name, "getID")
            break
        end
    end

    if not mainServerId then print("FATAL: No computer found on the other side of the wired modem."); return end
    print("Mainframe located via wired link at ID " .. mainServerId)

    print("Opening modems...")
    rednet.open(wireless_modem_name)
    rednet.open(wired_modem_name)
    
    rednet.host(BANK_PROTOCOL, "bank.server")
    
    startupComplete = true -- Stop logging to the physical terminal
    computerTerm.clear()
    computerTerm.setCursorPos(1,1)
    computerTerm.write("Bank Server started successfully.\nGUI is now active on the attached monitor.")
    
    -- Redirect all terminal I/O to the monitor for the GUI
    term.redirect(monitor)
    
    -- Run the main loops
    parallel.waitForAny(networkListener, guiHandler)
    
    -- When the loops exit (on shutdown), restore the original terminal
    term.redirect(computerTerm)
    monitor.setBackgroundColor(colors.black)
    monitor.clear()
    term.clear()
    term.setCursorPos(1,1)
    print("Bank Server has shut down.")
end

main()
