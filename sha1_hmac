--[[
    SHA1 and HMAC-SHA1 Cryptography Library (v1.0)
    by Gemini Gem

    Purpose:
    Provides standardized and reusable functions for SHA1 hashing and
    HMAC-SHA1 message signing. This library is intended to be used by
    other programs via `require()`.

    Functions:
    - sha1.hex(string): Returns the hexadecimal SHA1 hash of a string.
    - sha1.bin(string): Returns the binary SHA1 hash of a string.
    - sha1.hmac_hex(key, message): Returns the hexadecimal HMAC-SHA1
      signature of a message using a secret key.
]]

local sha1 = {}

local lshift, rshift, bor, band, bxor = bit32.lshift, bit32.rshift, bit32.bor, bit32.band, bit32.bxor
local function rol(n, c) return bor(lshift(n, c), rshift(n, 32 - c)) end
local function str_to_bin(str) local t = {}; for i = 1, #str do t[i] = string.byte(str, i) end; return t end
local function bin_to_hex(bin) local hex = ""; for i = 1, #bin do hex = hex .. string.format("%02x", bin[i]) end; return hex end
local function bin_to_str(bin) return string.char(table.unpack(bin)) end

function sha1.bin(s)
  local H0, H1, H2, H3, H4 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
  local str = str_to_bin(s); local len = #str; str[len + 1] = 0x80
  for i = len + 2, (len + 64) - ((len + 8) % 64) do str[i] = 0 end
  local bit_len = len * 8
  for i = 0, 7 do str[#str + 1] = band(rshift(bit_len, (7 - i) * 8), 0xff) end
  for i = 1, #str, 64 do
    local W = {}; for j = 0, 15 do W[j] = bor(lshift(str[i+j*4], 24), lshift(str[i+j*4+1], 16), lshift(str[i+j*4+2], 8), str[i+j*4+3]) end
    for j = 16, 79 do W[j] = rol(bxor(W[j-3], W[j-8], W[j-14], W[j-16]), 1) end
    local a,b,c,d,e = H0,H1,H2,H3,H4
    for j = 0, 79 do
      local f, k
      if j < 20 then f = bxor(d, band(b, bxor(c, d))); k = 0x5A827999
      elseif j < 40 then f = bxor(b, c, d); k = 0x6ED9EBA1
      elseif j < 60 then f = bor(band(b, c), band(b, d), band(c, d)); k = 0x8F1BBCDC
      else f = bxor(b, c, d); k = 0xCA62C1D6 end
      local temp = rol(a, 5) + f + e + W[j] + k; e=d; d=c; c=rol(b, 30); b=a; a=temp
    end
    H0=(H0+a); H1=(H1+b); H2=(H2+c); H3=(H3+d); H4=(H4+e)
  end
  local result = {}; for i=0,3 do result[i+1]=band(rshift(H0,(3-i)*8),0xff) end; for i=0,3 do result[i+5]=band(rshift(H1,(3-i)*8),0xff) end; for i=0,3 do result[i+9]=band(rshift(H2,(3-i)*8),0xff) end; for i=0,3 do result[i+13]=band(rshift(H3,(3-i)*8),0xff) end; for i=0,3 do result[i+17]=band(rshift(H4,(3-i)*8),0xff) end
  return result
end

function sha1.hex(s) return bin_to_hex(sha1.bin(s)) end

function sha1.hmac_hex(key, message)
    local blocksize = 64
    if #key > blocksize then key = bin_to_str(sha1.bin(key)) end
    local key_padding = {}; for i = 1, blocksize do key_padding[i] = string.byte(key, i) or 0 end
    local o_key_pad = ""; local i_key_pad = ""
    for i = 1, blocksize do
        o_key_pad = o_key_pad .. string.char(bxor(key_padding[i], 0x5c))
        i_key_pad = i_key_pad .. string.char(bxor(key_padding[i], 0x36))
    end
    local inner_hash = bin_to_str(sha1.bin(i_key_pad .. message))
    local final_hash = sha1.bin(o_key_pad .. inner_hash)
    return bin_to_hex(final_hash)
end

return sha1
