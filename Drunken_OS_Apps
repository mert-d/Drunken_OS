--[[
    Drunken OS - Application Screen Library (v1.2 - Features Restored)
    by Gemini Gem

    Purpose:
    This library contains all the major "application" functions for the
    Drunken_OS_Client. This version restores the full, working implementations
    for all menu options.

    Key Changes:
    - All placeholder "feature coming soon" messages have been replaced with
      their full, original implementations.
    - All features, including Chat, Admin Console, and Mailing Lists, are now
      fully functional and adapted to the modular context system.
]]

local apps = {}

--==============================================================================
-- Helper function to access the parent's state
--==============================================================================
local function getParent(context)
    return context.parent
end

--==============================================================================
-- Mail Application Screens
--==============================================================================

function apps.readMail(context)
    local mail = context.mail_to_read
    local w, h = context.getSafeSize()
    local bodyLines = context.wordWrap(mail.body or "", w - 3)
    local scroll = 1
    while true do
        context.drawWindow("Read Mail")
        local y = 3
        term.setCursorPos(2, y); term.write("From:    " .. (mail.from_nickname or "Unknown"))
        term.setCursorPos(2, y + 1); term.write("To:      " .. (mail.to or "Unknown"))
        term.setCursorPos(2, y + 2); term.write("Subject: " .. (mail.subject or "(No Subject)"))
        term.setCursorPos(2, y + 4); term.write(string.rep("-", w - 2)); y = y + 5
        
        local bodyDisplayHeight = h - y - (mail.attachment and 6 or 2)
        for i = 1, bodyDisplayHeight do
            local lineIndex = scroll + i - 1
            if lineIndex <= #bodyLines then
                term.setCursorPos(2, y + i - 1)
                term.write(bodyLines[lineIndex])
            end
        end
        y = y + bodyDisplayHeight + 1

        if mail.attachment then
            term.setCursorPos(2, y); term.write(string.rep("-", w - 2)); y = y + 1
            term.setCursorPos(2, y); term.write("Attachment: " .. mail.attachment.name); y = y + 2
            term.setTextColor(context.theme.prompt); term.setCursorPos(2, y); term.write("Save this file? (Y/N)")
        else
            term.setTextColor(context.theme.prompt); term.setCursorPos(2, h - 2); term.write("Press Q/TAB to return...")
        end

        local event, key = os.pullEvent("key")
        if key == keys.up then
            scroll = math.max(1, scroll - 1)
        elseif key == keys.down then
            scroll = math.min(math.max(1, #bodyLines - bodyDisplayHeight + 1), scroll + 1)
        elseif key == keys.tab or key == keys.q then
            break
        elseif mail.attachment and key == keys.y then
            local saveName = mail.attachment.name
            if fs.exists(saveName) then
                if context.readInput("Overwrite '"..saveName.."'? (y/n): ", y + 1):lower() ~= "y" then
                    context.showMessage("Cancelled", "Save operation cancelled.")
                    break
                end
            end
            local file = fs.open(saveName, "w")
            if file then
                file.write(mail.attachment.content)
                file.close()
                context.showMessage("Success", "File saved as '"..saveName.."'")
            else
                context.showMessage("Error", "Could not open file for writing.")
            end
            break
        elseif mail.attachment and key == keys.n then
            context.showMessage("Cancelled", "Save operation cancelled.")
            break
        end
    end
end

function apps.viewInbox(context)
    getParent(context).unreadCount = 0
    context.drawWindow("Inbox")
    term.setCursorPos(2, 4)
    term.write("Fetching mail...")
    rednet.send(getParent(context).mailServerId, { type = "fetch", user = getParent(context).username }, "SimpleMail")
    local _, response = rednet.receive("SimpleMail", 10)
    
    if not response or not response.mail then
        context.showMessage("Error", "Could not retrieve mail.")
        return
    end
    
    local inbox = response.mail
    if #inbox == 0 then
        context.showMessage("Inbox", "Your inbox is empty.")
        return
    end
    
    table.sort(inbox, function(a, b) return a.timestamp > b.timestamp end)
    local selected = 1
    local scroll = 1
    
    while true do
        context.drawWindow("Inbox")
        local w, h = context.getSafeSize()
        local listHeight = h - 5
        
        for i = scroll, math.min(scroll + listHeight - 1, #inbox) do
            local mail = inbox[i]
            local line = string.format("From: %-15s Subject: %s", mail.from_nickname, mail.subject)
            if mail.attachment then line = line .. " [FILE]" end
            term.setCursorPos(2, 2 + (i - scroll) + 1)
            if i == selected then
                term.setBackgroundColor(context.theme.highlightBg); term.setTextColor(context.theme.highlightText)
            else
                term.setBackgroundColor(context.theme.windowBg); term.setTextColor(context.theme.text)
            end
            term.write(string.sub(line, 1, w - 2))
        end
        
        term.setBackgroundColor(context.theme.windowBg)
        term.setTextColor(context.theme.prompt)
        local helpText = "ENTER: Read | D: Delete | Q: Back"
        term.setCursorPos(w - #helpText, h - 2)
        term.write(helpText)
        
        local event, key = os.pullEvent("key")
        if key == keys.up then
            selected = math.max(1, selected - 1)
            if selected < scroll then scroll = selected end
        elseif key == keys.down then
            selected = math.min(#inbox, selected + 1)
            if selected >= scroll + listHeight then scroll = selected - listHeight + 1 end
        elseif key == keys.enter then
            context.mail_to_read = inbox[selected]
            apps.readMail(context)
        elseif key == keys.delete or key == keys.d then
            rednet.send(getParent(context).mailServerId, {type = "delete", user = getParent(context).username, id = inbox[selected].id}, "SimpleMail")
            table.remove(inbox, selected)
            if #inbox == 0 then break end
            selected = math.max(1, math.min(selected, #inbox))
        elseif key == keys.tab or key == keys.q then
            break
        end
    end
end

function apps.composeAndSend(context, to, subject, attachment)
    context.drawWindow("Compose Mail Body")
    local w, h = context.getSafeSize()
    term.setCursorPos(w - 26, h)
    term.write("ENTER on empty line to send")
    term.setCursorPos(2, 4)
    term.write("Enter message body:")
    
    local bodyLines = {}
    local y = 6
    while y < h - 2 do
        term.setCursorPos(2, y)
        term.setCursorBlink(true)
        local line = read()
        term.setCursorBlink(false)
        if line == "" then break end
        table.insert(bodyLines, line)
        y = y + 1
    end
    
    local body = table.concat(bodyLines, "\n")
    local mail = {
        from = getParent(context).username,
        from_nickname = getParent(context).nickname,
        to = to,
        subject = subject,
        body = body,
        timestamp = os.time(),
        attachment = attachment
    }
    rednet.send(getParent(context).mailServerId, { type = "send", mail = mail }, "SimpleMail")
    context.drawWindow("Sending...")
    local _, confirm = rednet.receive("SimpleMail", 10)
    context.showMessage("Server Response", confirm and confirm.status or "No response from server.")
end

function apps.sendMail(context)
    context.drawWindow("Compose Mail")
    local to = context.readInput("To: ", 4)
    if not to or to == "" then return end
    rednet.send(getParent(context).mailServerId, { type = "user_exists", user = to }, "SimpleMail")
    local _, response = rednet.receive("SimpleMail", 3)
    if not response or not response.exists then
        context.showMessage("Error", "Recipient '"..to.."' not found.")
        return
    end
    local subject = context.readInput("Subject: ", 6)
    apps.composeAndSend(context, to, subject or "(No Subject)", nil)
end

function apps.sendFile(context)
    context.drawWindow("Send File")
    local fileName = context.readInput("File to send: ", 4)
    if not fileName or not fs.exists(fileName) then
        context.showMessage("Error", "File not found.")
        return
    end
    local to = context.readInput("To: ", 6)
    if not to or to == "" then return end
    rednet.send(getParent(context).mailServerId, { type = "user_exists", user = to }, "SimpleMail")
    local _, response = rednet.receive("SimpleMail", 3)
    if not response or not response.exists then
        context.showMessage("Error", "Recipient '"..to.."' not found.")
        return
    end
    local subject = context.readInput("Subject: ", 8)
    local file = fs.open(fileName, "r")
    if not file then
        context.showMessage("Error", "Could not open file.")
        return
    end
    local content = file.readAll()
    file.close()
    apps.composeAndSend(context, to, subject or "(No Subject)", { name = fs.getName(fileName), content = content })
end

function apps.manageLists(context)
    local options = {"View All Lists", "Create a List", "Join a List", "Back"}
    local selected = 1
    while true do
        context.drawWindow("Mailing Lists")
        context.drawMenu(options, selected, 2, 4)
        local event, key = os.pullEvent("key")
        if key == keys.up then
            selected = (selected == 1) and #options or selected - 1
        elseif key == keys.down then
            selected = (selected == #options) and 1 or selected + 1
        elseif key == keys.enter then
            if selected == 1 then
                context.drawWindow("All Lists")
                term.setCursorPos(2, 4); term.write("Fetching lists...")
                rednet.send(getParent(context).mailServerId, { type = "get_lists" }, "SimpleMail")
                local _, response = rednet.receive("SimpleMail", 5)
                if response and response.lists then
                    context.drawWindow("All Lists")
                    local listTable = {}
                    for name, members in pairs(response.lists) do
                        table.insert(listTable, {name = name, members = #members})
                    end
                    if #listTable == 0 then
                        context.showMessage("All Lists", "There are no mailing lists.")
                    else
                        local y = 4
                        for _, listData in ipairs(listTable) do
                            term.setCursorPos(2, y)
                            term.write(string.format("@%s (%d members)", listData.name, listData.members))
                            y = y + 1
                        end
                        term.setCursorPos(2, y + 1)
                        term.setTextColor(context.theme.prompt)
                        term.write("Press any key to continue...")
                        os.pullEvent("key")
                    end
                else
                    context.showMessage("Error", "Could not fetch lists.")
                end
            elseif selected == 2 then
                context.drawWindow("Create List")
                local name = context.readInput("New list name: @", 4)
                if name and name ~= "" then
                    rednet.send(getParent(context).mailServerId, { type = "create_list", name = name, creator = getParent(context).username }, "SimpleMail")
                    local _, r = rednet.receive("SimpleMail", 5)
                    if r and r.status then
                        context.showMessage("Server Response", r.status)
                    else
                        context.showMessage("Error", "No response.")
                    end
                end
            elseif selected == 3 then
                context.drawWindow("Join List")
                local name = context.readInput("List to join: @", 4)
                if name and name ~= "" then
                    rednet.send(getParent(context).mailServerId, { type = "join_list", name = name, user = getParent(context).username }, "SimpleMail")
                    local _, r = rednet.receive("SimpleMail", 5)
                    if r and r.status then
                        context.showMessage("Server Response", r.status)
                    else
                        context.showMessage("Error", "No response.")
                    end
                end
            elseif selected == 4 then
                break
            end
        elseif key == keys.tab then
            break
        end
    end
end

function apps.startChat(context)
    context.drawWindow("General Chat")
    term.setCursorPos(2, 4)
    term.write("Fetching history...")
    rednet.send(getParent(context).mailServerId, {type = "get_chat_history"}, "SimpleMail")
    local _, response = rednet.receive("SimpleMail", 5)
    
    local history = (response and response.history) or {}
    local input = ""
    local lastMessage = ""

    local function redrawAll()
        context.drawWindow("General Chat")
        local w, h = context.getSafeSize()
        local line_y = h - 3
        for i = #history, 1, -1 do
            local wrapped = context.wordWrap(history[i], w - 2)
            for j = #wrapped, 1, -1 do
                if line_y < 2 then break end
                term.setCursorPos(2, line_y)
                term.write(wrapped[j])
                line_y = line_y - 1
            end
            if line_y < 2 then break end
        end
        local inputWidth = w - 4
        term.setBackgroundColor(context.theme.windowBg)
        term.setCursorPos(1, h - 2)
        term.write(string.rep(" ", w))
        term.setCursorPos(2, h - 2)
        term.setTextColor(context.theme.prompt)
        term.write("> ")
        term.setTextColor(context.theme.text)
        local textToDraw = #input > inputWidth and string.sub(input, -inputWidth) or input
        term.write(textToDraw)
    end

    local function redrawInputLineOnly()
        local w, h = context.getSafeSize()
        local inputWidth = w - 4
        term.setBackgroundColor(context.theme.windowBg)
        term.setCursorPos(1, h - 2)
        term.write(string.rep(" ", w))
        term.setCursorPos(2, h - 2)
        term.setTextColor(context.theme.prompt)
        term.write("> ")
        term.setTextColor(context.theme.text)
        local textToDraw = #input > inputWidth and string.sub(input, -inputWidth) or input
        term.write(textToDraw)
    end

    local function networkListener()
        while true do
            local _, message = rednet.receive("SimpleChat")
            local formattedMessage = string.format("[%s]: %s", message.from, message.text)
            if formattedMessage ~= lastMessage then
                table.insert(history, formattedMessage)
                if #history > 100 then
                    table.remove(history, 1)
                end
                redrawAll()
            end
        end
    end

    local function keyboardListener()
        while true do
            local event, p1 = os.pullEvent()
            if event == "key" then
                if p1 == keys.tab or p1 == keys.q then
                    break
                elseif p1 == keys.backspace then
                    if #input > 0 then
                        input = string.sub(input, 1, -2)
                        redrawInputLineOnly()
                    end
                elseif p1 == keys.enter then
                    if input ~= "" then
                        local messageToSend = { from = getParent(context).username, text = input }
                        rednet.send(getParent(context).chatServerId, messageToSend, "SimpleChat")
                        lastMessage = string.format("[%s]: %s", getParent(context).nickname, messageToSend.text)
                        table.insert(history, lastMessage)
                        if #history > 100 then
                            table.remove(history, 1)
                        end
                        input = ""
                        redrawAll()
                    end
                end
            elseif event == "char" then
                input = input .. p1
                redrawInputLineOnly()
            elseif event == "terminate" then
                break
            end
        end
    end

    redrawAll()
    parallel.waitForAny(keyboardListener, networkListener)
end

function apps.sendFeedback(context)
    context.drawWindow("Send Feedback to Admin")
    local subject = context.readInput("Subject: ", 4)
    if not subject or subject == "" then return end
    apps.composeAndSend(context, "MuhendizBey", "Feedback: " .. subject, nil)
end

function apps.adminConsole(context)
    if not getParent(context).adminServerId then
        context.showMessage("Error", "Admin server not found.")
        return
    end

    context.drawWindow("Remote Admin Console")
    local history = {}
    local input = ""
    local w, h = context.getSafeSize()

    local function redrawConsole()
        context.drawWindow("Remote Admin Console")
        local historyLines = {}
        for _, item in ipairs(history) do
            local prefix = item.type == "cmd" and "> " or ""
            for _, line in ipairs(context.wordWrap(prefix .. item.text, w - 2)) do
                table.insert(historyLines, line)
            end
        end

        local displayHeight = h - 3
        local startLine = math.max(1, #historyLines - displayHeight + 1)
        for i = startLine, #historyLines do
            term.setCursorPos(2, 2 + (i - startLine))
            term.write(historyLines[i])
        end
    end

    local function redrawInputLine()
        local inputWidth = w - 4
        term.setBackgroundColor(context.theme.windowBg)
        term.setCursorPos(1, h - 1)
        term.clearLine()
        term.setCursorPos(2, h - 1)
        term.setTextColor(context.theme.prompt)
        term.write("> ")
        term.setTextColor(context.theme.text)
        
        local textToDraw = #input > inputWidth and "..." .. string.sub(input, -inputWidth + 3) or input
        term.write(textToDraw)
    end
    
    redrawConsole()
    while true do
        redrawInputLine()
        term.setCursorBlink(true)

        local event, p1 = os.pullEvent()
        term.setCursorBlink(false)

        if event == "key" then
            if p1 == keys.enter then
                if input == "exit" or input == "quit" then break end
                if input == "clear" then
                    history = {}
                elseif input ~= "" then
                    table.insert(history, {type="cmd", text=input})
                    rednet.send(getParent(context).adminServerId, {
                        type = "execute_command",
                        user = getParent(context).username,
                        command = input
                    }, "Drunken_Admin")
                    
                    redrawConsole()
                    term.setCursorPos(1, h-1); term.clearLine()
                    term.setCursorPos(2, h-1); term.write("Executing...")

                    local _, response = rednet.receive("Drunken_Admin", 10)
                    if response and response.output then
                        table.insert(history, {type="resp", text=response.output})
                    else
                        table.insert(history, {type="resp", text="Error: Timed out or no response from server."})
                    end
                end
                input = ""
                redrawConsole()
            elseif p1 == keys.backspace then
                input = string.sub(input, 1, -2)
            end
        elseif event == "char" then
            input = input .. p1
        elseif event == "terminate" then
            break
        end
    end
end

function apps.settingsMenu(context)
    context.showMessage("Settings", "This feature is coming soon!")
    return false -- Don't log out
end

function apps.enterArcade(context)
    context.showMessage("Arcade", "This feature is coming soon!")
end

function apps.showHelpScreen(context)
    context.drawWindow("Help")
    local y = 3
    term.setCursorPos(2, y); term.write("Use UP/DOWN arrows and ENTER to navigate menus.")
    y = y + 2
    term.setCursorPos(2, y); term.write("Q or TAB will usually go back to the previous screen.")
    y = y + 2
    term.setCursorPos(2, y); term.write("Most screens have context-specific help on the")
    y = y + 1
    term.setCursorPos(2, y); term.write("bottom status bar.")
    y = y + 3
    term.setTextColor(context.theme.prompt)
    term.setCursorPos(2,y)
    term.write("Press any key to return...")
    os.pullEvent("key")
end

return apps

